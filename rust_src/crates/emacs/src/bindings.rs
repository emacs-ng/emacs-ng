use crate::{globals::emacs_globals, sys::Lisp_Object};

use libc::timespec;
/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const AMPERSAND_FULL_NAME: u32 = 1;
pub const COPYRIGHT: &'static [u8; 50usize] =
    b"Copyright (C) 2021 Free Software Foundation, Inc.\0";
pub const DEFAULT_SOUND_DEVICE: &'static [u8; 9usize] = b"/dev/dsp\0";
pub const DIRECTORY_SEP: u8 = 47u8;
pub const EMACS_CONFIGURATION: &'static [u8; 20usize] = b"x86_64-pc-linux-gnu\0";
pub const EMACS_CONFIG_FEATURES : & 'static [ u8 ; 120usize ] = b"ACL DBUS GMP GNUTLS GPM JSON LCMS2 LIBSYSTEMD LIBXML2 MODULES NATIVE_COMP NOTIFY INOTIFY PDUMPER SOUND THREADS XIM ZLIB\0" ;
pub const EMACS_CONFIG_OPTIONS: &'static [u8; 65usize] =
    b"with_javascript=yes with_native_compilation=yes --with-webrender\0";
pub const FUNC_REALPATH_WORKS: u32 = 1;
pub const GCC_LINT: u32 = 1;
pub const GC_SETJMP_WORKS: u32 = 1;
pub const GNULIB_CANONICALIZE_LGPL: u32 = 1;
pub const GNULIB_CLOSE_STREAM: u32 = 1;
pub const GNULIB_FACCESSAT: u32 = 1;
pub const GNULIB_FDOPENDIR: u32 = 1;
pub const GNULIB_FSCANF: u32 = 1;
pub const GNULIB_MKOSTEMP: u32 = 1;
pub const GNULIB_SCANF: u32 = 1;
pub const GNULIB_TEMPNAME: u32 = 1;
pub const HAVE_ACCEPT4: u32 = 1;
pub const HAVE_ACL_DELETE_DEF_FILE: u32 = 1;
pub const HAVE_ACL_ENTRIES: u32 = 1;
pub const HAVE_ACL_EXTENDED_FILE: u32 = 1;
pub const HAVE_ACL_FIRST_ENTRY: u32 = 1;
pub const HAVE_ACL_FREE: u32 = 1;
pub const HAVE_ACL_FROM_MODE: u32 = 1;
pub const HAVE_ACL_FROM_TEXT: u32 = 1;
pub const HAVE_ACL_GET_FD: u32 = 1;
pub const HAVE_ACL_GET_FILE: u32 = 1;
pub const HAVE_ACL_LIBACL_H: u32 = 1;
pub const HAVE_ACL_SET_FD: u32 = 1;
pub const HAVE_ACL_SET_FILE: u32 = 1;
pub const HAVE_ALIGNED_ALLOC: u32 = 1;
pub const HAVE_ALLOCA: u32 = 1;
pub const HAVE_ALLOCA_H: u32 = 1;
pub const HAVE_ALSA: u32 = 1;
pub const HAVE_BYTESWAP_H: u32 = 1;
pub const HAVE_CANONICALIZE_FILE_NAME: u32 = 1;
pub const HAVE_CFMAKERAW: u32 = 1;
pub const HAVE_CFSETSPEED: u32 = 1;
pub const HAVE_CLOCK_GETTIME: u32 = 1;
pub const HAVE_CLOCK_SETTIME: u32 = 1;
pub const HAVE_C_VARARRAYS: u32 = 1;
pub const HAVE_DBUS: u32 = 1;
pub const HAVE_DBUS_TYPE_IS_VALID: u32 = 1;
pub const HAVE_DBUS_VALIDATE_BUS_NAME: u32 = 1;
pub const HAVE_DBUS_VALIDATE_INTERFACE: u32 = 1;
pub const HAVE_DBUS_VALIDATE_MEMBER: u32 = 1;
pub const HAVE_DBUS_VALIDATE_PATH: u32 = 1;
pub const HAVE_DBUS_WATCH_GET_UNIX_FD: u32 = 1;
pub const HAVE_DECL_ALARM: u32 = 1;
pub const HAVE_DECL_ALIGNED_ALLOC: u32 = 1;
pub const HAVE_DECL_CLEARERR_UNLOCKED: u32 = 1;
pub const HAVE_DECL_ECVT: u32 = 1;
pub const HAVE_DECL_EXECVPE: u32 = 1;
pub const HAVE_DECL_FCLOSEALL: u32 = 1;
pub const HAVE_DECL_FCVT: u32 = 1;
pub const HAVE_DECL_FDOPENDIR: u32 = 1;
pub const HAVE_DECL_FEOF_UNLOCKED: u32 = 1;
pub const HAVE_DECL_FERROR_UNLOCKED: u32 = 1;
pub const HAVE_DECL_FFLUSH_UNLOCKED: u32 = 1;
pub const HAVE_DECL_FGETS_UNLOCKED: u32 = 1;
pub const HAVE_DECL_FPUTC_UNLOCKED: u32 = 1;
pub const HAVE_DECL_FPUTS_UNLOCKED: u32 = 1;
pub const HAVE_DECL_FREAD_UNLOCKED: u32 = 1;
pub const HAVE_DECL_FWRITE_UNLOCKED: u32 = 1;
pub const HAVE_DECL_GCVT: u32 = 1;
pub const HAVE_DECL_GETCHAR_UNLOCKED: u32 = 1;
pub const HAVE_DECL_GETC_UNLOCKED: u32 = 1;
pub const HAVE_DECL_GETDTABLESIZE: u32 = 1;
pub const HAVE_DECL_ISBLANK: u32 = 1;
pub const HAVE_DECL_LOCALTIME_R: u32 = 1;
pub const HAVE_DECL_MEMMEM: u32 = 1;
pub const HAVE_DECL_MEMRCHR: u32 = 1;
pub const HAVE_DECL_PUTCHAR_UNLOCKED: u32 = 1;
pub const HAVE_DECL_PUTC_UNLOCKED: u32 = 1;
pub const HAVE_DECL_STRMODE: u32 = 0;
pub const HAVE_DECL_STRNLEN: u32 = 1;
pub const HAVE_DECL_STRTOIMAX: u32 = 1;
pub const HAVE_DECL___FPENDING: u32 = 1;
pub const HAVE_DIRENT_H: u32 = 1;
pub const HAVE_DLADDR: u32 = 1;
pub const HAVE_ENDGRENT: u32 = 1;
pub const HAVE_ENDPWENT: u32 = 1;
pub const HAVE_ENVIRON_DECL: u32 = 1;
pub const HAVE_EXECINFO_H: u32 = 1;
pub const HAVE_EXPLICIT_BZERO: u32 = 1;
pub const HAVE_FACCESSAT: u32 = 1;
pub const HAVE_FCHDIR: u32 = 1;
pub const HAVE_FCHMOD: u32 = 1;
pub const HAVE_FCHMODAT: u32 = 1;
pub const HAVE_FCNTL: u32 = 1;
pub const HAVE_FDOPENDIR: u32 = 1;
pub const HAVE_FORK: u32 = 1;
pub const HAVE_FREEIFADDRS: u32 = 1;
pub const HAVE_FSEEKO: u32 = 1;
pub const HAVE_FSTATAT: u32 = 1;
pub const HAVE_FSYNC: u32 = 1;
pub const HAVE_FUTIMENS: u32 = 1;
pub const HAVE_FUTIMES: u32 = 1;
pub const HAVE_FUTIMESAT: u32 = 1;
pub const HAVE_GAI_STRERROR: u32 = 1;
pub const HAVE_GETADDRINFO_A: u32 = 1;
pub const HAVE_GETCWD: u32 = 1;
pub const HAVE_GETDTABLESIZE: u32 = 1;
pub const HAVE_GETGRENT: u32 = 1;
pub const HAVE_GETHOSTNAME: u32 = 1;
pub const HAVE_GETIFADDRS: u32 = 1;
pub const HAVE_GETOPT_H: u32 = 1;
pub const HAVE_GETOPT_LONG_ONLY: u32 = 1;
pub const HAVE_GETPAGESIZE: u32 = 1;
pub const HAVE_GETPT: u32 = 1;
pub const HAVE_GETPWENT: u32 = 1;
pub const HAVE_GETRANDOM: u32 = 1;
pub const HAVE_GETRLIMIT: u32 = 1;
pub const HAVE_GETRUSAGE: u32 = 1;
pub const HAVE_GETSOCKNAME: u32 = 1;
pub const HAVE_GETTIMEOFDAY: u32 = 1;
pub const HAVE_GET_CURRENT_DIR_NAME: u32 = 1;
pub const HAVE_GMP_H: u32 = 1;
pub const HAVE_GNUTLS: u32 = 1;
pub const HAVE_GPM: u32 = 1;
pub const HAVE_GRANTPT: u32 = 1;
pub const HAVE_IEEE754_H: u32 = 1;
pub const HAVE_IFADDRS_H: u32 = 1;
pub const HAVE_INOTIFY: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_ISBLANK: u32 = 1;
pub const HAVE_ISWCTYPE: u32 = 1;
pub const HAVE_JSON: u32 = 1;
pub const HAVE_LANGINFO_CODESET: u32 = 1;
pub const HAVE_LANGINFO__NL_PAPER_WIDTH: u32 = 1;
pub const HAVE_LCHMOD: u32 = 1;
pub const HAVE_LCMS2: u32 = 1;
pub const HAVE_LIBGCCJIT: u32 = 1;
pub const HAVE_LIBGCCJIT_H: u32 = 1;
pub const HAVE_LIBINTL_H: u32 = 1;
pub const HAVE_LIBSYSTEMD: u32 = 1;
pub const HAVE_LIBXML2: u32 = 1;
pub const HAVE_LIMITS_H: u32 = 1;
pub const HAVE_LINUX_FS_H: u32 = 1;
pub const HAVE_LINUX_SYSINFO: u32 = 1;
pub const HAVE_LOCALTIME_R: u32 = 1;
pub const HAVE_LOG2: u32 = 1;
pub const HAVE_LONG_LONG_INT: u32 = 1;
pub const HAVE_LRAND48: u32 = 1;
pub const HAVE_LSTAT: u32 = 1;
pub const HAVE_LUTIMES: u32 = 1;
pub const HAVE_MALLOC_H: u32 = 1;
pub const HAVE_MBSTATE_T: u32 = 1;
pub const HAVE_MEMMEM: u32 = 1;
pub const HAVE_MEMPCPY: u32 = 1;
pub const HAVE_MEMRCHR: u32 = 1;
pub const HAVE_MINMAX_IN_SYS_PARAM_H: u32 = 1;
pub const HAVE_MKOSTEMP: u32 = 1;
pub const HAVE_MMAP: u32 = 1;
pub const HAVE_MODULES: u32 = 1;
pub const HAVE_NATIVE_COMP: u32 = 1;
pub const HAVE_NET_IF_H: u32 = 1;
pub const HAVE_NEWLOCALE: u32 = 1;
pub const HAVE_PDUMPER: u32 = 1;
pub const HAVE_PERSONALITY_ADDR_NO_RANDOMIZE: u32 = 1;
pub const HAVE_PIPE2: u32 = 1;
pub const HAVE_POSIX_MADVISE: u32 = 1;
pub const HAVE_POSIX_OPENPT: u32 = 1;
pub const HAVE_PROCFS: u32 = 1;
pub const HAVE_PSELECT: u32 = 1;
pub const HAVE_PTHREAD: u32 = 1;
pub const HAVE_PTHREAD_H: u32 = 1;
pub const HAVE_PTHREAD_SETNAME_NP: u32 = 1;
pub const HAVE_PTHREAD_SIGMASK: u32 = 1;
pub const HAVE_PTYS: u32 = 1;
pub const HAVE_PTY_H: u32 = 1;
pub const HAVE_PWD_H: u32 = 1;
pub const HAVE_RANDOM: u32 = 1;
pub const HAVE_READLINK: u32 = 1;
pub const HAVE_READLINKAT: u32 = 1;
pub const HAVE_REALPATH: u32 = 1;
pub const HAVE_RECVFROM: u32 = 1;
pub const HAVE_RINT: u32 = 1;
pub const HAVE_SANITIZER_LSAN_INTERFACE_H: u32 = 1;
pub const HAVE_SBRK: u32 = 1;
pub const HAVE_SELECT: u32 = 1;
pub const HAVE_SENDTO: u32 = 1;
pub const HAVE_SETITIMER: u32 = 1;
pub const HAVE_SETLOCALE: u32 = 1;
pub const HAVE_SETRLIMIT: u32 = 1;
pub const HAVE_SHUTDOWN: u32 = 1;
pub const HAVE_SIGDESCR_NP: u32 = 1;
pub const HAVE_SIGSETJMP: u32 = 1;
pub const HAVE_SIGSET_T: u32 = 1;
pub const HAVE_SNPRINTF: u32 = 1;
pub const HAVE_SOCKETS: u32 = 1;
pub const HAVE_SOUND: u32 = 1;
pub const HAVE_STACK_OVERFLOW_HANDLING: u32 = 1;
pub const HAVE_STATEMENT_EXPRESSIONS: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDIO_EXT_H: u32 = 1;
pub const HAVE_STDIO_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STPCPY: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_STRSIGNAL: u32 = 1;
pub const HAVE_STRTOIMAX: u32 = 1;
pub const HAVE_STRUCT_ATTRIBUTE_ALIGNED: u32 = 1;
pub const HAVE_STRUCT_DIRENT_D_TYPE: u32 = 1;
pub const HAVE_STRUCT_IFREQ_IFR_ADDR: u32 = 1;
pub const HAVE_STRUCT_IFREQ_IFR_BROADADDR: u32 = 1;
pub const HAVE_STRUCT_IFREQ_IFR_FLAGS: u32 = 1;
pub const HAVE_STRUCT_IFREQ_IFR_HWADDR: u32 = 1;
pub const HAVE_STRUCT_IFREQ_IFR_NETMASK: u32 = 1;
pub const HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC: u32 = 1;
pub const HAVE_STRUCT_TM_TM_ZONE: u32 = 1;
pub const HAVE_STRUCT_UNIPAIR_UNICODE: u32 = 1;
pub const HAVE_SYMLINK: u32 = 1;
pub const HAVE_SYNC: u32 = 1;
pub const HAVE_SYS_ACL_H: u32 = 1;
pub const HAVE_SYS_CDEFS_H: u32 = 1;
pub const HAVE_SYS_MOUNT_H: u32 = 1;
pub const HAVE_SYS_PARAM_H: u32 = 1;
pub const HAVE_SYS_RANDOM_H: u32 = 1;
pub const HAVE_SYS_RESOURCE_H: u32 = 1;
pub const HAVE_SYS_SELECT_H: u32 = 1;
pub const HAVE_SYS_SOCKET_H: u32 = 1;
pub const HAVE_SYS_SOUNDCARD_H: u32 = 1;
pub const HAVE_SYS_STATFS_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_SYS_SYSINFO_H: u32 = 1;
pub const HAVE_SYS_TIME_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_SYS_UN_H: u32 = 1;
pub const HAVE_SYS_UTSNAME_H: u32 = 1;
pub const HAVE_SYS_VFS_H: u32 = 1;
pub const HAVE_SYS_WAIT_H: u32 = 1;
pub const HAVE_TERM_H: u32 = 1;
pub const HAVE_TIMEGM: u32 = 1;
pub const HAVE_TIMERFD: u32 = 1;
pub const HAVE_TIMER_SETTIME: u32 = 1;
pub const HAVE_TM_GMTOFF: u32 = 1;
pub const HAVE_TM_ZONE: u32 = 1;
pub const HAVE_TRUNC: u32 = 1;
pub const HAVE_TYPEOF: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const HAVE_UNSIGNED_LONG_LONG_INT: u32 = 1;
pub const HAVE_UTIMENSAT: u32 = 1;
pub const HAVE_UTMP_H: u32 = 1;
pub const HAVE_VFORK: u32 = 1;
pub const HAVE_WCHAR_H: u32 = 1;
pub const HAVE_WCHAR_T: u32 = 1;
pub const HAVE_WINDOW_SYSTEM: u32 = 1;
pub const HAVE_WORKING_FORK: u32 = 1;
pub const HAVE_WORKING_UTIMES: u32 = 1;
pub const HAVE_WORKING_VFORK: u32 = 1;
pub const HAVE_XIM: u32 = 1;
pub const HAVE_ZLIB: u32 = 1;
pub const HAVE__SETJMP: u32 = 1;
pub const HAVE___BUILTIN_EXPECT: u32 = 1;
pub const HAVE___BUILTIN_FRAME_ADDRESS: u32 = 1;
pub const HAVE___BUILTIN_UNWIND_INIT: u32 = 1;
pub const HAVE___EXECUTABLE_START: u32 = 1;
pub const HAVE___INLINE: u32 = 1;
pub const INTERRUPT_INPUT: u32 = 1;
pub const LINUX_SYSINFO_UNIT: u32 = 1;
pub const LSTAT_FOLLOWS_SLASHED_SYMLINK: u32 = 1;
pub const MAIL_USE_FLOCK: u32 = 1;
pub const MALLOC_0_IS_NONNULL: u32 = 1;
pub const __USE_MINGW_ANSI_STDIO: u32 = 1;
pub const MODULES_SUFFIX: &'static [u8; 4usize] = b".so\0";
pub const NARROWPROTO: u32 = 1;
pub const NATIVE_ELISP_SUFFIX: &'static [u8; 5usize] = b".eln\0";
pub const NULL_DEVICE: &'static [u8; 10usize] = b"/dev/null\0";
pub const PACKAGE_BUGREPORT: &'static [u8; 22usize] = b"bug-gnu-emacs@gnu.org\0";
pub const PACKAGE_NAME: &'static [u8; 10usize] = b"GNU Emacs\0";
pub const PACKAGE_STRING: &'static [u8; 18usize] = b"GNU Emacs 28.0.50\0";
pub const PACKAGE_TARNAME: &'static [u8; 6usize] = b"emacs\0";
pub const PACKAGE_URL: &'static [u8; 36usize] = b"https://www.gnu.org/software/emacs/\0";
pub const PACKAGE_VERSION: &'static [u8; 8usize] = b"28.0.50\0";
pub const POLL_FOR_INPUT: u32 = 1;
pub const SEPCHAR: u8 = 58u8;
pub const SIGNALS_VIA_CHARACTERS: u32 = 1;
pub const STAT_STATFS2_FRSIZE: u32 = 1;
pub const STAT_STATVFS: u32 = 1;
pub const STDC_HEADERS: u32 = 1;
pub const SYSTEM_MALLOC: u32 = 1;
pub const SYSTEM_TYPE: &'static [u8; 10usize] = b"gnu/linux\0";
pub const TERMINFO: u32 = 1;
pub const TERMINFO_DEFINES_BC: u32 = 1;
pub const TERM_HEADER: &'static [u8; 9usize] = b"wrterm.h\0";
pub const THREADS_ENABLED: u32 = 1;
pub const TIME_T_IS_SIGNED: u32 = 1;
pub const TYPEOF_STRUCT_STAT_ST_ATIM_IS_STRUCT_TIMESPEC: u32 = 1;
pub const UNIX98_PTYS: u32 = 1;
pub const USABLE_FIONREAD: u32 = 1;
pub const USABLE_SIGIO: u32 = 1;
pub const USE_ACL: u32 = 1;
pub const USE_FILE_NOTIFY: u32 = 1;
pub const _ALL_SOURCE: u32 = 1;
pub const _DARWIN_C_SOURCE: u32 = 1;
pub const __EXTENSIONS__: u32 = 1;
pub const _GNU_SOURCE: u32 = 1;
pub const _HPUX_ALT_XOPEN_SOCKET_API: u32 = 1;
pub const _NETBSD_SOURCE: u32 = 1;
pub const _OPENBSD_SOURCE: u32 = 1;
pub const _POSIX_PTHREAD_SEMANTICS: u32 = 1;
pub const __STDC_WANT_IEC_60559_ATTRIBS_EXT__: u32 = 1;
pub const __STDC_WANT_IEC_60559_BFP_EXT__: u32 = 1;
pub const __STDC_WANT_IEC_60559_DFP_EXT__: u32 = 1;
pub const __STDC_WANT_IEC_60559_FUNCS_EXT__: u32 = 1;
pub const __STDC_WANT_IEC_60559_TYPES_EXT__: u32 = 1;
pub const __STDC_WANT_LIB_EXT2__: u32 = 1;
pub const __STDC_WANT_MATH_SPEC_FUNCS__: u32 = 1;
pub const _TANDEM_SOURCE: u32 = 1;
pub const USE_UNLOCKED_IO: u32 = 1;
pub const USE_WEBRENDER: u32 = 1;
pub const USE_XIM: u32 = 1;
pub const _REGEX_INCLUDE_LIMITS_H: u32 = 1;
pub const _REGEX_LARGE_OFFSETS: u32 = 1;
pub const _USE_STD_STAT: u32 = 1;
pub const subprocesses: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const ADDRESS_SANITIZER: u32 = 0;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 33;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const CHAR_WIDTH: u32 = 8;
pub const SCHAR_WIDTH: u32 = 8;
pub const UCHAR_WIDTH: u32 = 8;
pub const SHRT_WIDTH: u32 = 16;
pub const USHRT_WIDTH: u32 = 16;
pub const INT_WIDTH: u32 = 32;
pub const UINT_WIDTH: u32 = 32;
pub const LONG_WIDTH: u32 = 64;
pub const ULONG_WIDTH: u32 = 64;
pub const LLONG_WIDTH: u32 = 64;
pub const ULLONG_WIDTH: u32 = 64;
pub const BOOL_MAX: u32 = 1;
pub const BOOL_WIDTH: u32 = 1;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_FD_SETSIZE: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_QLIMIT: u32 = 1;
pub const _POSIX_HIWAT: u32 = 512;
pub const _POSIX_UIO_MAXIOV: u32 = 16;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const IOV_MAX: u32 = 1024;
pub const NL_ARGMAX: u32 = 4096;
pub const NL_LANGMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const WORD_BIT: u32 = 32;
pub const LONG_BIT: u32 = 64;
pub const _SETJMP_H: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const __alignas_is_defined: u32 = 1;
pub const __alignof_is_defined: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const _LONG_LONG_FORMAT_PREFIX: &'static [u8; 3usize] = b"ll\0";
pub const _PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const _PRIu64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const _SCN64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const _SCNu64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const _GL_HAVE___TYPEOF__: u32 = 1;
pub const _GL_HAS_BUILTIN_MUL_OVERFLOW: u32 = 0;
pub const _GL_HAS_BUILTIN_OVERFLOW_P: u32 = 0;
pub const _GL__GENERIC_BOGUS: u32 = 1;
pub const _GL_HAVE__STATIC_ASSERT: u32 = 1;
pub const _GL_HAS_BUILTIN_TRAP: u32 = 1;
pub const GCTYPEBITS: u32 = 3;
pub const pI: &'static [u8; 2usize] = b"l\0";
pub const BITS_WORD_MAX: i32 = -1;
pub const pD: &'static [u8; 2usize] = b"l\0";
pub const INTTYPEBITS: u32 = 2;
pub const GCALIGNMENT: u32 = 8;
pub const DEFINE_KEY_OPS_AS_MACROS: u32 = 1;
pub const DEFINE_NON_NIL_Q_SYMBOL_MACROS: u32 = 1;
pub const iQnil: u32 = 0;
pub const iQt: u32 = 1;
pub const iQunbound: u32 = 2;
pub const iQerror: u32 = 3;
pub const iQlambda: u32 = 4;
pub const iQAutomatic_GC: u32 = 5;
pub const iQCadstyle: u32 = 6;
pub const iQCadvertised_binding: u32 = 7;
pub const iQCalign_to: u32 = 8;
pub const iQCallow_net: u32 = 9;
pub const iQCallow_read: u32 = 10;
pub const iQCallow_run: u32 = 11;
pub const iQCallow_write: u32 = 12;
pub const iQCantialias: u32 = 13;
pub const iQCarray: u32 = 14;
pub const iQCarray_type: u32 = 15;
pub const iQCascent: u32 = 16;
pub const iQCascii_compatible_p: u32 = 17;
pub const iQCavgwidth: u32 = 18;
pub const iQCbackground: u32 = 19;
pub const iQCbase_uri: u32 = 20;
pub const iQCbold: u32 = 21;
pub const iQCboolean: u32 = 22;
pub const iQCbox: u32 = 23;
pub const iQCbuffer: u32 = 24;
pub const iQCbutton: u32 = 25;
pub const iQCbyte: u32 = 26;
pub const iQCbytesize: u32 = 27;
pub const iQCcategory: u32 = 28;
pub const iQCcipher_aead_capable: u32 = 29;
pub const iQCcipher_blocksize: u32 = 30;
pub const iQCcipher_id: u32 = 31;
pub const iQCcipher_ivsize: u32 = 32;
pub const iQCcipher_keysize: u32 = 33;
pub const iQCcipher_tagsize: u32 = 34;
pub const iQCcoding: u32 = 35;
pub const iQCcolor: u32 = 36;
pub const iQCcolor_adjustment: u32 = 37;
pub const iQCcolor_symbols: u32 = 38;
pub const iQCcombining_capability: u32 = 39;
pub const iQCcommand: u32 = 40;
pub const iQCcomplete_negotiation: u32 = 41;
pub const iQCconnection_type: u32 = 42;
pub const iQCconversion: u32 = 43;
pub const iQCcrlfiles: u32 = 44;
pub const iQCcrop: u32 = 45;
pub const iQCdata: u32 = 46;
pub const iQCdebug_on_exit: u32 = 47;
pub const iQCdecode_translation_table: u32 = 48;
pub const iQCdefault_char: u32 = 49;
pub const iQCdevice: u32 = 50;
pub const iQCdict_entry: u32 = 51;
pub const iQCdigest_algorithm_id: u32 = 52;
pub const iQCdigest_algorithm_length: u32 = 53;
pub const iQCdistant_foreground: u32 = 54;
pub const iQCdocumentation: u32 = 55;
pub const iQCdouble: u32 = 56;
pub const iQCdpi: u32 = 57;
pub const iQCenable: u32 = 58;
pub const iQCencode_translation_table: u32 = 59;
pub const iQCeval: u32 = 60;
pub const iQCextend: u32 = 61;
pub const iQCfalse: u32 = 62;
pub const iQCfalse_object: u32 = 63;
pub const iQCfamily: u32 = 64;
pub const iQCfile: u32 = 65;
pub const iQCfile_handler: u32 = 66;
pub const iQCfilter: u32 = 67;
pub const iQCfiltered: u32 = 68;
pub const iQCflowcontrol: u32 = 69;
pub const iQCfont: u32 = 70;
pub const iQCfont_entity: u32 = 71;
pub const iQCfontset: u32 = 72;
pub const iQCforeground: u32 = 73;
pub const iQCfoundry: u32 = 74;
pub const iQCheight: u32 = 75;
pub const iQChelp: u32 = 76;
pub const iQCheuristic_mask: u32 = 77;
pub const iQChost: u32 = 78;
pub const iQChostname: u32 = 79;
pub const iQCignore_defface: u32 = 80;
pub const iQCimage: u32 = 81;
pub const iQCinchannel: u32 = 82;
pub const iQCindex: u32 = 83;
pub const iQCinherit: u32 = 84;
pub const iQCinspect: u32 = 85;
pub const iQCinspect_brk: u32 = 86;
pub const iQCint16: u32 = 87;
pub const iQCint32: u32 = 88;
pub const iQCint64: u32 = 89;
pub const iQCinverse_video: u32 = 90;
pub const iQCitalic: u32 = 91;
pub const iQCjs_error_handler: u32 = 92;
pub const iQCjs_tick_rate: u32 = 93;
pub const iQCjson_config: u32 = 94;
pub const iQCkey_sequence: u32 = 95;
pub const iQCkeylist: u32 = 96;
pub const iQCkeys: u32 = 97;
pub const iQClabel: u32 = 98;
pub const iQClang: u32 = 99;
pub const iQCline_width: u32 = 100;
pub const iQCloader: u32 = 101;
pub const iQClocal: u32 = 102;
pub const iQClog: u32 = 103;
pub const iQCloglevel: u32 = 104;
pub const iQCloops_per_tick: u32 = 105;
pub const iQCmac_algorithm_id: u32 = 106;
pub const iQCmac_algorithm_keysize: u32 = 107;
pub const iQCmac_algorithm_length: u32 = 108;
pub const iQCmac_algorithm_noncesize: u32 = 109;
pub const iQCmap: u32 = 110;
pub const iQCmargin: u32 = 111;
pub const iQCmask: u32 = 112;
pub const iQCmatrix: u32 = 113;
pub const iQCmax_height: u32 = 114;
pub const iQCmax_width: u32 = 115;
pub const iQCmethod: u32 = 116;
pub const iQCmin_prime_bits: u32 = 117;
pub const iQCmnemonic: u32 = 118;
pub const iQCmonitor: u32 = 119;
pub const iQCname: u32 = 120;
pub const iQCno_check: u32 = 121;
pub const iQCno_remote: u32 = 122;
pub const iQCnoquery: u32 = 123;
pub const iQCnowait: u32 = 124;
pub const iQCnull: u32 = 125;
pub const iQCnull_object: u32 = 126;
pub const iQCobject_path: u32 = 127;
pub const iQCobject_type: u32 = 128;
pub const iQCotf: u32 = 129;
pub const iQCoutchannel: u32 = 130;
pub const iQCoverline: u32 = 131;
pub const iQCparity: u32 = 132;
pub const iQCplist: u32 = 133;
pub const iQCpointer: u32 = 134;
pub const iQCport: u32 = 135;
pub const iQCpost_read_conversion: u32 = 136;
pub const iQCpre_write_conversion: u32 = 137;
pub const iQCpriority: u32 = 138;
pub const iQCprocess: u32 = 139;
pub const iQCpropertize: u32 = 140;
pub const iQCpt_height: u32 = 141;
pub const iQCpt_width: u32 = 142;
pub const iQCpurecopy: u32 = 143;
pub const iQCradio: u32 = 144;
pub const iQCregistry: u32 = 145;
pub const iQCrehash_size: u32 = 146;
pub const iQCrehash_threshold: u32 = 147;
pub const iQCrelative_height: u32 = 148;
pub const iQCrelative_width: u32 = 149;
pub const iQCrelief: u32 = 150;
pub const iQCremote: u32 = 151;
pub const iQCreverse_video: u32 = 152;
pub const iQCrotation: u32 = 153;
pub const iQCrtl: u32 = 154;
pub const iQCscalable: u32 = 155;
pub const iQCscale: u32 = 156;
pub const iQCscript: u32 = 157;
pub const iQCsentinel: u32 = 158;
pub const iQCserial: u32 = 159;
pub const iQCserver: u32 = 160;
pub const iQCservice: u32 = 161;
pub const iQCsession: u32 = 162;
pub const iQCsession_private: u32 = 163;
pub const iQCsignal: u32 = 164;
pub const iQCsignature: u32 = 165;
pub const iQCsize: u32 = 166;
pub const iQCslant: u32 = 167;
pub const iQCspacing: u32 = 168;
pub const iQCspeed: u32 = 169;
pub const iQCstderr: u32 = 170;
pub const iQCstipple: u32 = 171;
pub const iQCstop: u32 = 172;
pub const iQCstopbits: u32 = 173;
pub const iQCstrike_through: u32 = 174;
pub const iQCstring: u32 = 175;
pub const iQCstruct: u32 = 176;
pub const iQCstyle: u32 = 177;
pub const iQCsummary: u32 = 178;
pub const iQCsystem: u32 = 179;
pub const iQCsystem_private: u32 = 180;
pub const iQCtest: u32 = 181;
pub const iQCtimeout: u32 = 182;
pub const iQCtls_parameters: u32 = 183;
pub const iQCtoggle: u32 = 184;
pub const iQCtransform_smoothing: u32 = 185;
pub const iQCtrustfiles: u32 = 186;
pub const iQCts_config: u32 = 187;
pub const iQCtype: u32 = 188;
pub const iQCtypescript: u32 = 189;
pub const iQCuint16: u32 = 190;
pub const iQCuint32: u32 = 191;
pub const iQCuint64: u32 = 192;
pub const iQCunderline: u32 = 193;
pub const iQCunix_fd: u32 = 194;
pub const iQCuse_color: u32 = 195;
pub const iQCuse_external_socket: u32 = 196;
pub const iQCuser_spec: u32 = 197;
pub const iQCvariant: u32 = 198;
pub const iQCverify_error: u32 = 199;
pub const iQCverify_flags: u32 = 200;
pub const iQCvert_only: u32 = 201;
pub const iQCvisible: u32 = 202;
pub const iQCvolume: u32 = 203;
pub const iQCweakness: u32 = 204;
pub const iQCweight: u32 = 205;
pub const iQCwidth: u32 = 206;
pub const iQCwindow: u32 = 207;
pub const iQEmacsFrameResize: u32 = 208;
pub const iQL2R: u32 = 209;
pub const iQPRIMARY: u32 = 210;
pub const iQR2L: u32 = 211;
pub const iQabove: u32 = 212;
pub const iQabove_handle: u32 = 213;
pub const iQabove_suspended: u32 = 214;
pub const iQaccess: u32 = 215;
pub const iQaccess_file: u32 = 216;
pub const iQactivate_input_method: u32 = 217;
pub const iQactivate_menubar_hook: u32 = 218;
pub const iQadd1: u32 = 219;
pub const iQadd_name_to_file: u32 = 220;
pub const iQadjust_frame_size_1: u32 = 221;
pub const iQadjust_frame_size_2: u32 = 222;
pub const iQadjust_frame_size_3: u32 = 223;
pub const iQafter_change_functions: u32 = 224;
pub const iQafter_delete_frame_functions: u32 = 225;
pub const iQafter_handle: u32 = 226;
pub const iQafter_insert_file_set_coding: u32 = 227;
pub const iQafter_string: u32 = 228;
pub const iQalist: u32 = 229;
pub const iQall_events: u32 = 230;
pub const iQalpha: u32 = 231;
pub const iQand_optional: u32 = 232;
pub const iQand_rest: u32 = 233;
pub const iQappend: u32 = 234;
pub const iQapply: u32 = 235;
pub const iQargs: u32 = 236;
pub const iQargs_out_of_range: u32 = 237;
pub const iQarith_error: u32 = 238;
pub const iQarray: u32 = 239;
pub const iQarrayp: u32 = 240;
pub const iQarrow: u32 = 241;
pub const iQascii: u32 = 242;
pub const iQascii_0: u32 = 243;
pub const iQascii_character: u32 = 244;
pub const iQassume: u32 = 245;
pub const iQattrib: u32 = 246;
pub const iQauto_composed: u32 = 247;
pub const iQauto_fill_chars: u32 = 248;
pub const iQauto_hscroll_mode: u32 = 249;
pub const iQauto_lower: u32 = 250;
pub const iQauto_raise: u32 = 251;
pub const iQauto_save_coding: u32 = 252;
pub const iQautoload: u32 = 253;
pub const iQbackground_color: u32 = 254;
pub const iQbackground_mode: u32 = 255;
pub const iQbackquote: u32 = 256;
pub const iQbar: u32 = 257;
pub const iQbefore_change_functions: u32 = 258;
pub const iQbefore_handle: u32 = 259;
pub const iQbefore_string: u32 = 260;
pub const iQbeginning_of_buffer: u32 = 261;
pub const iQbelow: u32 = 262;
pub const iQbelow_handle: u32 = 263;
pub const iQbig: u32 = 264;
pub const iQbig5: u32 = 265;
pub const iQbitmap_spec_p: u32 = 266;
pub const iQbold: u32 = 267;
pub const iQbool_vector: u32 = 268;
pub const iQbool_vector_p: u32 = 269;
pub const iQborder: u32 = 270;
pub const iQborder_color: u32 = 271;
pub const iQborder_width: u32 = 272;
pub const iQboth: u32 = 273;
pub const iQboth_horiz: u32 = 274;
pub const iQbottom: u32 = 275;
pub const iQbottom_divider: u32 = 276;
pub const iQbottom_divider_width: u32 = 277;
pub const iQbottom_edge: u32 = 278;
pub const iQbottom_left_corner: u32 = 279;
pub const iQbottom_right_corner: u32 = 280;
pub const iQboundary: u32 = 281;
pub const iQbounds: u32 = 282;
pub const iQbox: u32 = 283;
pub const iQbuffer: u32 = 284;
pub const iQbuffer_access_fontify_functions: u32 = 285;
pub const iQbuffer_file_coding_system: u32 = 286;
pub const iQbuffer_list: u32 = 287;
pub const iQbuffer_list_update_hook: u32 = 288;
pub const iQbuffer_name_history: u32 = 289;
pub const iQbuffer_or_string_p: u32 = 290;
pub const iQbuffer_position: u32 = 291;
pub const iQbuffer_predicate: u32 = 292;
pub const iQbuffer_read_only: u32 = 293;
pub const iQbufferp: u32 = 294;
pub const iQbuffers: u32 = 295;
pub const iQburied_buffer_list: u32 = 296;
pub const iQbyte_code_function_p: u32 = 297;
pub const iQbyte_code_meter: u32 = 298;
pub const iQbyte_run_unescaped_character_literals_warning: u32 = 299;
pub const iQc: u32 = 300;
pub const iQcall: u32 = 301;
pub const iQcall_process: u32 = 302;
pub const iQcall_process_region: u32 = 303;
pub const iQcallref: u32 = 304;
pub const iQcar: u32 = 305;
pub const iQcar_less_than_car: u32 = 306;
pub const iQcase_fold_search: u32 = 307;
pub const iQcase_table: u32 = 308;
pub const iQcase_table_p: u32 = 309;
pub const iQcatcher: u32 = 310;
pub const iQcategory: u32 = 311;
pub const iQcategory_table: u32 = 312;
pub const iQcategory_table_p: u32 = 313;
pub const iQcategoryp: u32 = 314;
pub const iQcategorysetp: u32 = 315;
pub const iQccl: u32 = 316;
pub const iQccl_program_idx: u32 = 317;
pub const iQcclp: u32 = 318;
pub const iQcdr: u32 = 319;
pub const iQceiling: u32 = 320;
pub const iQcenter: u32 = 321;
pub const iQchange_frame_size: u32 = 322;
pub const iQchange_major_mode_hook: u32 = 323;
pub const iQchar_code_property_table: u32 = 324;
pub const iQchar_from_name: u32 = 325;
pub const iQchar_or_string_p: u32 = 326;
pub const iQchar_script_table: u32 = 327;
pub const iQchar_table: u32 = 328;
pub const iQchar_table_extra_slots: u32 = 329;
pub const iQchar_table_p: u32 = 330;
pub const iQcharacterp: u32 = 331;
pub const iQcharset: u32 = 332;
pub const iQcharsetp: u32 = 333;
pub const iQchild_frame_border: u32 = 334;
pub const iQchild_frame_border_width: u32 = 335;
pub const iQchoice: u32 = 336;
pub const iQcircle: u32 = 337;
pub const iQcircular_list: u32 = 338;
pub const iQclone_of: u32 = 339;
pub const iQclose: u32 = 340;
pub const iQclose_nowrite: u32 = 341;
pub const iQclose_tab: u32 = 342;
pub const iQclose_write: u32 = 343;
pub const iQclosed: u32 = 344;
pub const iQclosure: u32 = 345;
pub const iQcmajflt: u32 = 346;
pub const iQcminflt: u32 = 347;
pub const iQcode_conversion_map: u32 = 348;
pub const iQcode_conversion_map_id: u32 = 349;
pub const iQcodeset: u32 = 350;
pub const iQcoding_system_define_form: u32 = 351;
pub const iQcoding_system_error: u32 = 352;
pub const iQcoding_system_history: u32 = 353;
pub const iQcoding_system_p: u32 = 354;
pub const iQcolumns: u32 = 355;
pub const iQcomm: u32 = 356;
pub const iQcomma: u32 = 357;
pub const iQcomma_at: u32 = 358;
pub const iQcommand_debug_status: u32 = 359;
pub const iQcommand_execute: u32 = 360;
pub const iQcommand_modes: u32 = 361;
pub const iQcommandp: u32 = 362;
pub const iQcomment: u32 = 363;
pub const iQcomment_end_can_be_escaped: u32 = 364;
pub const iQcomp: u32 = 365;
pub const iQcomp_debug: u32 = 366;
pub const iQcomp_libgccjit_reproducer: u32 = 367;
pub const iQcomp_maybe_gc_or_quit: u32 = 368;
pub const iQcomp_mvar: u32 = 369;
pub const iQcomp_native_driver_options: u32 = 370;
pub const iQcomp_speed: u32 = 371;
pub const iQcomp_subr_trampoline_install: u32 = 372;
pub const iQcomp_warning_on_missing_source: u32 = 373;
pub const iQcompiled_function: u32 = 374;
pub const iQcompletion_ignore_case: u32 = 375;
pub const iQcomposition: u32 = 376;
pub const iQcond_jump: u32 = 377;
pub const iQcond_jump_narg_leq: u32 = 378;
pub const iQcondition_case: u32 = 379;
pub const iQcondition_variable: u32 = 380;
pub const iQcondition_variable_p: u32 = 381;
pub const iQconfig_changed_event: u32 = 382;
pub const iQconnect: u32 = 383;
pub const iQcons: u32 = 384;
pub const iQconses: u32 = 385;
pub const iQconsp: u32 = 386;
pub const iQcontinuation: u32 = 387;
pub const iQcopy_directory: u32 = 388;
pub const iQcopy_file: u32 = 389;
pub const iQcount: u32 = 390;
pub const iQcreate: u32 = 391;
pub const iQcrop: u32 = 392;
pub const iQcstime: u32 = 393;
pub const iQctime: u32 = 394;
pub const iQcurrent_input_method: u32 = 395;
pub const iQcurrent_line: u32 = 396;
pub const iQcurrent_load_list: u32 = 397;
pub const iQcurrent_minibuffer_command: u32 = 398;
pub const iQcursor: u32 = 399;
pub const iQcursor_color: u32 = 400;
pub const iQcursor_in_echo_area: u32 = 401;
pub const iQcursor_type: u32 = 402;
pub const iQcurve: u32 = 403;
pub const iQcustom_variable_history: u32 = 404;
pub const iQcustom_variable_p: u32 = 405;
pub const iQcutime: u32 = 406;
pub const iQcycle_sort_function: u32 = 407;
pub const iQcyclic_function_indirection: u32 = 408;
pub const iQcyclic_variable_indirection: u32 = 409;
pub const iQd: u32 = 410;
pub const iQd_default: u32 = 411;
pub const iQd_ephemeral: u32 = 412;
pub const iQd_impure: u32 = 413;
pub const iQdata: u32 = 414;
pub const iQdatagram: u32 = 415;
pub const iQdays: u32 = 416;
pub const iQdbus_error: u32 = 417;
pub const iQdbus_event: u32 = 418;
pub const iQdbus_message_internal: u32 = 419;
pub const iQdeactivate_mark: u32 = 420;
pub const iQdebug: u32 = 421;
pub const iQdecomposed_characters: u32 = 422;
pub const iQdefalias_fset_function: u32 = 423;
pub const iQdefault: u32 = 424;
pub const iQdefault_directory: u32 = 425;
pub const iQdeferred_action_function: u32 = 426;
pub const iQdefun: u32 = 427;
pub const iQdefvaralias: u32 = 428;
pub const iQdelay: u32 = 429;
pub const iQdelayed_warnings_hook: u32 = 430;
pub const iQdelete: u32 = 431;
pub const iQdelete_before: u32 = 432;
pub const iQdelete_by_moving_to_trash: u32 = 433;
pub const iQdelete_directory: u32 = 434;
pub const iQdelete_file: u32 = 435;
pub const iQdelete_frame: u32 = 436;
pub const iQdelete_frame_functions: u32 = 437;
pub const iQdelete_self: u32 = 438;
pub const iQdelete_terminal_functions: u32 = 439;
pub const iQdelete_window: u32 = 440;
pub const iQdescribe_map_tree: u32 = 441;
pub const iQdir_ok: u32 = 442;
pub const iQdirect_call: u32 = 443;
pub const iQdirect_callref: u32 = 444;
pub const iQdirectory_file_name: u32 = 445;
pub const iQdirectory_files: u32 = 446;
pub const iQdirectory_files_and_attributes: u32 = 447;
pub const iQdisable_eval: u32 = 448;
pub const iQdisabled: u32 = 449;
pub const iQdisplay: u32 = 450;
pub const iQdisplay_buffer: u32 = 451;
pub const iQdisplay_fill_column_indicator: u32 = 452;
pub const iQdisplay_fill_column_indicator_character: u32 = 453;
pub const iQdisplay_fill_column_indicator_column: u32 = 454;
pub const iQdisplay_line_numbers: u32 = 455;
pub const iQdisplay_line_numbers_disable: u32 = 456;
pub const iQdisplay_line_numbers_offset: u32 = 457;
pub const iQdisplay_line_numbers_widen: u32 = 458;
pub const iQdisplay_line_numbers_width: u32 = 459;
pub const iQdisplay_table: u32 = 460;
pub const iQdisplay_type: u32 = 461;
pub const iQdo_after_load_evaluation: u32 = 462;
pub const iQdomain_error: u32 = 463;
pub const iQdont_follow: u32 = 464;
pub const iQdos: u32 = 465;
pub const iQdown: u32 = 466;
pub const iQdrag_internal_border: u32 = 467;
pub const iQdrag_n_drop: u32 = 468;
pub const iQdragging: u32 = 469;
pub const iQdropping: u32 = 470;
pub const iQdump_emacs_portable__sort_predicate: u32 = 471;
pub const iQdump_emacs_portable__sort_predicate_copied: u32 = 472;
pub const iQdump_file_name: u32 = 473;
pub const iQdumped_with_pdumper: u32 = 474;
pub const iQecho_area_clear_hook: u32 = 475;
pub const iQecho_keystrokes: u32 = 476;
pub const iQedge_detection: u32 = 477;
pub const iQegid: u32 = 478;
pub const iQeight_bit: u32 = 479;
pub const iQemacs: u32 = 480;
pub const iQemacs_mule: u32 = 481;
pub const iQemboss: u32 = 482;
pub const iQempty_box: u32 = 483;
pub const iQempty_line: u32 = 484;
pub const iQenable_recursive_minibuffers: u32 = 485;
pub const iQencode_time: u32 = 486;
pub const iQend_of_buffer: u32 = 487;
pub const iQend_of_file: u32 = 488;
pub const iQend_scroll: u32 = 489;
pub const iQend_session: u32 = 490;
pub const iQentry: u32 = 491;
pub const iQeq: u32 = 492;
pub const iQeql: u32 = 493;
pub const iQequal: u32 = 494;
pub const iQerror_conditions: u32 = 495;
pub const iQerror_message: u32 = 496;
pub const iQescape_glyph: u32 = 497;
pub const iQetime: u32 = 498;
pub const iQeuid: u32 = 499;
pub const iQeval: u32 = 500;
pub const iQeval_buffer_list: u32 = 501;
pub const iQeval_expression: u32 = 502;
pub const iQevaporate: u32 = 503;
pub const iQeven: u32 = 504;
pub const iQevent_kind: u32 = 505;
pub const iQevent_symbol_element_mask: u32 = 506;
pub const iQevent_symbol_elements: u32 = 507;
pub const iQexcl: u32 = 508;
pub const iQexit: u32 = 509;
pub const iQexpand_abbrev: u32 = 510;
pub const iQexpand_file_name: u32 = 511;
pub const iQexplicit: u32 = 512;
pub const iQexplicit_name: u32 = 513;
pub const iQextension_data: u32 = 514;
pub const iQexternal_border_size: u32 = 515;
pub const iQexternal_debugging_output: u32 = 516;
pub const iQextra_bold: u32 = 517;
pub const iQextra_light: u32 = 518;
pub const iQface: u32 = 519;
pub const iQface_alias: u32 = 520;
pub const iQface_no_inherit: u32 = 521;
pub const iQface_remapping_alist: u32 = 522;
pub const iQface_set_after_frame_default: u32 = 523;
pub const iQfailed: u32 = 524;
pub const iQfboundp: u32 = 525;
pub const iQfeatures: u32 = 526;
pub const iQfetch_handler: u32 = 527;
pub const iQfield: u32 = 528;
pub const iQfile_accessible_directory_p: u32 = 529;
pub const iQfile_acl: u32 = 530;
pub const iQfile_already_exists: u32 = 531;
pub const iQfile_attributes: u32 = 532;
pub const iQfile_attributes_lessp: u32 = 533;
pub const iQfile_date_error: u32 = 534;
pub const iQfile_directory_p: u32 = 535;
pub const iQfile_error: u32 = 536;
pub const iQfile_executable_p: u32 = 537;
pub const iQfile_exists_p: u32 = 538;
pub const iQfile_missing: u32 = 539;
pub const iQfile_modes: u32 = 540;
pub const iQfile_name_all_completions: u32 = 541;
pub const iQfile_name_as_directory: u32 = 542;
pub const iQfile_name_case_insensitive_p: u32 = 543;
pub const iQfile_name_completion: u32 = 544;
pub const iQfile_name_directory: u32 = 545;
pub const iQfile_name_handler_alist: u32 = 546;
pub const iQfile_name_history: u32 = 547;
pub const iQfile_name_nondirectory: u32 = 548;
pub const iQfile_newer_than_file_p: u32 = 549;
pub const iQfile_notify: u32 = 550;
pub const iQfile_notify_error: u32 = 551;
pub const iQfile_readable_p: u32 = 552;
pub const iQfile_regular_p: u32 = 553;
pub const iQfile_selinux_context: u32 = 554;
pub const iQfile_symlink_p: u32 = 555;
pub const iQfile_system_info: u32 = 556;
pub const iQfile_writable_p: u32 = 557;
pub const iQfilenamep: u32 = 558;
pub const iQfill_column_indicator: u32 = 559;
pub const iQfinalizer: u32 = 560;
pub const iQfirst_change_hook: u32 = 561;
pub const iQfixnum: u32 = 562;
pub const iQfixnump: u32 = 563;
pub const iQflat_button: u32 = 564;
pub const iQfloat: u32 = 565;
pub const iQfloatp: u32 = 566;
pub const iQfloats: u32 = 567;
pub const iQfloor: u32 = 568;
pub const iQfocus_in: u32 = 569;
pub const iQfocus_out: u32 = 570;
pub const iQfont: u32 = 571;
pub const iQfont_backend: u32 = 572;
pub const iQfont_driver_superseded_by: u32 = 573;
pub const iQfont_entity: u32 = 574;
pub const iQfont_lock_face: u32 = 575;
pub const iQfont_object: u32 = 576;
pub const iQfont_spec: u32 = 577;
pub const iQfontification_functions: u32 = 578;
pub const iQfontified: u32 = 579;
pub const iQfontset: u32 = 580;
pub const iQfontset_info: u32 = 581;
pub const iQforeground_color: u32 = 582;
pub const iQformat_annotate_function: u32 = 583;
pub const iQformat_decode: u32 = 584;
pub const iQfraction: u32 = 585;
pub const iQframe: u32 = 586;
pub const iQframe_edges: u32 = 587;
pub const iQframe_inhibit_resize: u32 = 588;
pub const iQframe_live_p: u32 = 589;
pub const iQframe_monitor_attributes: u32 = 590;
pub const iQframe_set_background_mode: u32 = 591;
pub const iQframe_windows_min_size: u32 = 592;
pub const iQframep: u32 = 593;
pub const iQframes: u32 = 594;
pub const iQfree_frame_menubar_1: u32 = 595;
pub const iQfree_frame_menubar_2: u32 = 596;
pub const iQfree_frame_tab_bar: u32 = 597;
pub const iQfree_frame_tool_bar: u32 = 598;
pub const iQfringe: u32 = 599;
pub const iQfront_sticky: u32 = 600;
pub const iQfullboth: u32 = 601;
pub const iQfullheight: u32 = 602;
pub const iQfullscreen: u32 = 603;
pub const iQfullwidth: u32 = 604;
pub const iQfuncall: u32 = 605;
pub const iQfuncall_interactively: u32 = 606;
pub const iQfunction: u32 = 607;
pub const iQfunction_documentation: u32 = 608;
pub const iQfunction_key: u32 = 609;
pub const iQfundamental_mode: u32 = 610;
pub const iQgc_cons_percentage: u32 = 611;
pub const iQgc_cons_threshold: u32 = 612;
pub const iQgccjit: u32 = 613;
pub const iQgdiplus: u32 = 614;
pub const iQgdk_pixbuf: u32 = 615;
pub const iQgeometry: u32 = 616;
pub const iQget_buffer_window_list: u32 = 617;
pub const iQget_emacs_mule_file_char: u32 = 618;
pub const iQget_file_buffer: u32 = 619;
pub const iQget_file_char: u32 = 620;
pub const iQget_mru_window: u32 = 621;
pub const iQgif: u32 = 622;
pub const iQgio: u32 = 623;
pub const iQglib: u32 = 624;
pub const iQglyphless_char: u32 = 625;
pub const iQglyphless_char_display: u32 = 626;
pub const iQgnutls_anon: u32 = 627;
pub const iQgnutls_code: u32 = 628;
pub const iQgnutls_e_again: u32 = 629;
pub const iQgnutls_e_interrupted: u32 = 630;
pub const iQgnutls_e_invalid_session: u32 = 631;
pub const iQgnutls_e_not_ready_for_handshake: u32 = 632;
pub const iQgnutls_type_cipher: u32 = 633;
pub const iQgnutls_type_digest_algorithm: u32 = 634;
pub const iQgnutls_type_mac_algorithm: u32 = 635;
pub const iQgnutls_x509pki: u32 = 636;
pub const iQgobject: u32 = 637;
pub const iQgrave: u32 = 638;
pub const iQgroup: u32 = 639;
pub const iQgrow_only: u32 = 640;
pub const iQgui_set_selection: u32 = 641;
pub const iQhand: u32 = 642;
pub const iQhandle: u32 = 643;
pub const iQhandle_select_window: u32 = 644;
pub const iQhandle_shift_selection: u32 = 645;
pub const iQhandle_switch_frame: u32 = 646;
pub const iQhash_table: u32 = 647;
pub const iQhash_table_p: u32 = 648;
pub const iQhash_table_test: u32 = 649;
pub const iQhbar: u32 = 650;
pub const iQheader_line: u32 = 651;
pub const iQheader_line_format: u32 = 652;
pub const iQheap: u32 = 653;
pub const iQheight: u32 = 654;
pub const iQheight_only: u32 = 655;
pub const iQhelp_echo: u32 = 656;
pub const iQhelp_echo_inhibit_substitution: u32 = 657;
pub const iQhelp_form_show: u32 = 658;
pub const iQhelp_key_binding: u32 = 659;
pub const iQhelper_save_restriction: u32 = 660;
pub const iQhelper_unbind_n: u32 = 661;
pub const iQhelper_unwind_protect: u32 = 662;
pub const iQheuristic: u32 = 663;
pub const iQhex_code: u32 = 664;
pub const iQhollow: u32 = 665;
pub const iQhollow_small: u32 = 666;
pub const iQhorizontal_handle: u32 = 667;
pub const iQhorizontal_scroll_bar: u32 = 668;
pub const iQhorizontal_scroll_bars: u32 = 669;
pub const iQhw: u32 = 670;
pub const iQicon: u32 = 671;
pub const iQicon_left: u32 = 672;
pub const iQicon_name: u32 = 673;
pub const iQicon_top: u32 = 674;
pub const iQicon_type: u32 = 675;
pub const iQiconify_frame: u32 = 676;
pub const iQiconify_top_level: u32 = 677;
pub const iQidentity: u32 = 678;
pub const iQif: u32 = 679;
pub const iQignored: u32 = 680;
pub const iQimage: u32 = 681;
pub const iQimagemagick: u32 = 682;
pub const iQinc_args: u32 = 683;
pub const iQinhibit_changing_match_data: u32 = 684;
pub const iQinhibit_debugger: u32 = 685;
pub const iQinhibit_double_buffering: u32 = 686;
pub const iQinhibit_eval_during_redisplay: u32 = 687;
pub const iQinhibit_file_name_operation: u32 = 688;
pub const iQinhibit_free_realized_faces: u32 = 689;
pub const iQinhibit_menubar_update: u32 = 690;
pub const iQinhibit_modification_hooks: u32 = 691;
pub const iQinhibit_point_motion_hooks: u32 = 692;
pub const iQinhibit_quit: u32 = 693;
pub const iQinhibit_read_only: u32 = 694;
pub const iQinhibit_redisplay: u32 = 695;
pub const iQinhibited_interaction: u32 = 696;
pub const iQinner_edges: u32 = 697;
pub const iQinput_method_exit_on_first_char: u32 = 698;
pub const iQinput_method_use_echo_area: u32 = 699;
pub const iQinsert_behind_hooks: u32 = 700;
pub const iQinsert_file_contents: u32 = 701;
pub const iQinsert_in_front_hooks: u32 = 702;
pub const iQinsufficient_source: u32 = 703;
pub const iQintangible: u32 = 704;
pub const iQinteger: u32 = 705;
pub const iQinteger_or_marker_p: u32 = 706;
pub const iQintegerp: u32 = 707;
pub const iQinteractive: u32 = 708;
pub const iQinteractive_form: u32 = 709;
pub const iQinternal__syntax_propertize: u32 = 710;
pub const iQinternal_auto_fill: u32 = 711;
pub const iQinternal_border: u32 = 712;
pub const iQinternal_border_width: u32 = 713;
pub const iQinternal_default_interrupt_process: u32 = 714;
pub const iQinternal_default_process_filter: u32 = 715;
pub const iQinternal_default_process_sentinel: u32 = 716;
pub const iQinternal_echo_keystrokes_prefix: u32 = 717;
pub const iQinternal_interpreter_environment: u32 = 718;
pub const iQinternal_when_entered_debugger: u32 = 719;
pub const iQinterrupt_process_functions: u32 = 720;
pub const iQinterrupted: u32 = 721;
pub const iQintervals: u32 = 722;
pub const iQinvalid_arity: u32 = 723;
pub const iQinvalid_function: u32 = 724;
pub const iQinvalid_read_syntax: u32 = 725;
pub const iQinvalid_regexp: u32 = 726;
pub const iQinvalid_source: u32 = 727;
pub const iQinvisible: u32 = 728;
pub const iQipv4: u32 = 729;
pub const iQipv6: u32 = 730;
pub const iQisdir: u32 = 731;
pub const iQiso10646_1: u32 = 732;
pub const iQiso8859_1: u32 = 733;
pub const iQiso_2022: u32 = 734;
pub const iQiso_8859_1: u32 = 735;
pub const iQitalic: u32 = 736;
pub const iQiv_auto: u32 = 737;
pub const iQja: u32 = 738;
pub const iQjpeg: u32 = 739;
pub const iQjs__clear: u32 = 740;
pub const iQjs__reenter: u32 = 741;
pub const iQjs_error: u32 = 742;
pub const iQjs_lisp_error: u32 = 743;
pub const iQjs_tick_event_loop: u32 = 744;
pub const iQjson_end_of_file: u32 = 745;
pub const iQjson_error: u32 = 746;
pub const iQjson_object_too_deep: u32 = 747;
pub const iQjson_out_of_memory: u32 = 748;
pub const iQjson_parse_error: u32 = 749;
pub const iQjson_parse_string: u32 = 750;
pub const iQjson_serialize: u32 = 751;
pub const iQjson_trailing_content: u32 = 752;
pub const iQjson_value_p: u32 = 753;
pub const iQjump: u32 = 754;
pub const iQkbd_macro_termination_hook: u32 = 755;
pub const iQkeep_ratio: u32 = 756;
pub const iQkey: u32 = 757;
pub const iQkey_and_value: u32 = 758;
pub const iQkey_or_value: u32 = 759;
pub const iQkeymap: u32 = 760;
pub const iQkeymap_canonicalize: u32 = 761;
pub const iQkeymapp: u32 = 762;
pub const iQkill_buffer_hook: u32 = 763;
pub const iQkill_buffer_query_functions: u32 = 764;
pub const iQkill_emacs: u32 = 765;
pub const iQkill_emacs_hook: u32 = 766;
pub const iQkill_forward_chars: u32 = 767;
pub const iQko: u32 = 768;
pub const iQlambda_fixup: u32 = 769;
pub const iQlanguage_change: u32 = 770;
pub const iQlaplace: u32 = 771;
pub const iQlast_arrow_position: u32 = 772;
pub const iQlast_arrow_string: u32 = 773;
pub const iQlast_nonmenu_event: u32 = 774;
pub const iQlate: u32 = 775;
pub const iQlatin: u32 = 776;
pub const iQleft: u32 = 777;
pub const iQleft_edge: u32 = 778;
pub const iQleft_fringe: u32 = 779;
pub const iQleft_margin: u32 = 780;
pub const iQleft_only: u32 = 781;
pub const iQleft_to_right: u32 = 782;
pub const iQleftmost: u32 = 783;
pub const iQlet: u32 = 784;
pub const iQletx: u32 = 785;
pub const iQlexical_binding: u32 = 786;
pub const iQlibgif_version: u32 = 787;
pub const iQlibjpeg_version: u32 = 788;
pub const iQlibpng_version: u32 = 789;
pub const iQlight: u32 = 790;
pub const iQline: u32 = 791;
pub const iQline_height: u32 = 792;
pub const iQline_number: u32 = 793;
pub const iQline_number_current_line: u32 = 794;
pub const iQline_number_major_tick: u32 = 795;
pub const iQline_number_minor_tick: u32 = 796;
pub const iQline_prefix: u32 = 797;
pub const iQline_spacing: u32 = 798;
pub const iQlist: u32 = 799;
pub const iQlist_or_vector_p: u32 = 800;
pub const iQlisten: u32 = 801;
pub const iQlistp: u32 = 802;
pub const iQlittle: u32 = 803;
pub const iQload: u32 = 804;
pub const iQload_file_name: u32 = 805;
pub const iQload_force_doc_strings: u32 = 806;
pub const iQload_in_progress: u32 = 807;
pub const iQload_time: u32 = 808;
pub const iQload_true_file_name: u32 = 809;
pub const iQlocal: u32 = 810;
pub const iQlocal_map: u32 = 811;
pub const iQlong: u32 = 812;
pub const iQlread_unescaped_character_literals: u32 = 813;
pub const iQm: u32 = 814;
pub const iQmac: u32 = 815;
pub const iQmacro: u32 = 816;
pub const iQmajflt: u32 = 817;
pub const iQmake_cursor_line_fully_visible: u32 = 818;
pub const iQmake_directory: u32 = 819;
pub const iQmake_directory_internal: u32 = 820;
pub const iQmake_frame_visible: u32 = 821;
pub const iQmake_invisible: u32 = 822;
pub const iQmake_process: u32 = 823;
pub const iQmake_symbolic_link: u32 = 824;
pub const iQmakunbound: u32 = 825;
pub const iQmany: u32 = 826;
pub const iQmargin: u32 = 827;
pub const iQmark_for_redisplay: u32 = 828;
pub const iQmark_inactive: u32 = 829;
pub const iQmarker: u32 = 830;
pub const iQmarkerp: u32 = 831;
pub const iQmaximized: u32 = 832;
pub const iQmd5: u32 = 833;
pub const iQmenu: u32 = 834;
pub const iQmenu_bar: u32 = 835;
pub const iQmenu_bar_external: u32 = 836;
pub const iQmenu_bar_lines: u32 = 837;
pub const iQmenu_bar_size: u32 = 838;
pub const iQmenu_bar_update_hook: u32 = 839;
pub const iQmenu_enable: u32 = 840;
pub const iQmenu_item: u32 = 841;
pub const iQmetadata: u32 = 842;
pub const iQmin_height: u32 = 843;
pub const iQmin_width: u32 = 844;
pub const iQminflt: u32 = 845;
pub const iQminibuffer: u32 = 846;
pub const iQminibuffer_completion_table: u32 = 847;
pub const iQminibuffer_default: u32 = 848;
pub const iQminibuffer_exit: u32 = 849;
pub const iQminibuffer_exit_hook: u32 = 850;
pub const iQminibuffer_follows_selected_frame: u32 = 851;
pub const iQminibuffer_history: u32 = 852;
pub const iQminibuffer_prompt: u32 = 853;
pub const iQminibuffer_setup_hook: u32 = 854;
pub const iQminus: u32 = 855;
pub const iQmissing_module_init_function: u32 = 856;
pub const iQmm_size: u32 = 857;
pub const iQmode_class: u32 = 858;
pub const iQmode_line: u32 = 859;
pub const iQmode_line_default_help_echo: u32 = 860;
pub const iQmode_line_format: u32 = 861;
pub const iQmode_line_inactive: u32 = 862;
pub const iQmodeline: u32 = 863;
pub const iQmodification_hooks: u32 = 864;
pub const iQmodifier_cache: u32 = 865;
pub const iQmodify: u32 = 866;
pub const iQmodule_function: u32 = 867;
pub const iQmodule_function_p: u32 = 868;
pub const iQmodule_init_failed: u32 = 869;
pub const iQmodule_load_failed: u32 = 870;
pub const iQmodule_not_gpl_compatible: u32 = 871;
pub const iQmodule_open_failed: u32 = 872;
pub const iQmonths: u32 = 873;
pub const iQmouse: u32 = 874;
pub const iQmouse_click: u32 = 875;
pub const iQmouse_color: u32 = 876;
pub const iQmouse_face: u32 = 877;
pub const iQmouse_fixup_help_message: u32 = 878;
pub const iQmouse_leave_buffer_hook: u32 = 879;
pub const iQmouse_movement: u32 = 880;
pub const iQmouse_wheel_frame: u32 = 881;
pub const iQmove: u32 = 882;
pub const iQmove_file_to_trash: u32 = 883;
pub const iQmove_frame: u32 = 884;
pub const iQmove_self: u32 = 885;
pub const iQmoved_from: u32 = 886;
pub const iQmoved_to: u32 = 887;
pub const iQmutex: u32 = 888;
pub const iQmutexp: u32 = 889;
pub const iQname: u32 = 890;
pub const iQnative_comp_unit: u32 = 891;
pub const iQnative_compiler_error: u32 = 892;
pub const iQnative_edges: u32 = 893;
pub const iQnative_ice: u32 = 894;
pub const iQnative_image: u32 = 895;
pub const iQnative_lisp_file_inconsistent: u32 = 896;
pub const iQnative_lisp_load_failed: u32 = 897;
pub const iQnative_lisp_wrong_reloc: u32 = 898;
pub const iQnatnump: u32 = 899;
pub const iQnegate: u32 = 900;
pub const iQnetwork: u32 = 901;
pub const iQnice: u32 = 902;
pub const iQno_accept_focus: u32 = 903;
pub const iQno_catch: u32 = 904;
pub const iQno_conversion: u32 = 905;
pub const iQno_focus_on_map: u32 = 906;
pub const iQno_other_frame: u32 = 907;
pub const iQno_record: u32 = 908;
pub const iQno_special_glyphs: u32 = 909;
pub const iQnobreak_hyphen: u32 = 910;
pub const iQnobreak_space: u32 = 911;
pub const iQnoelisp: u32 = 912;
pub const iQnon_ascii: u32 = 913;
pub const iQnone: u32 = 914;
pub const iQnormal: u32 = 915;
pub const iQns: u32 = 916;
pub const iQns_appearance: u32 = 917;
pub const iQns_parse_geometry: u32 = 918;
pub const iQns_transparent_titlebar: u32 = 919;
pub const iQnsm_verify_connection: u32 = 920;
pub const iQnull: u32 = 921;
pub const iQnumber_or_marker_p: u32 = 922;
pub const iQnumberp: u32 = 923;
pub const iQobject: u32 = 924;
pub const iQoblique: u32 = 925;
pub const iQodd: u32 = 926;
pub const iQonly: u32 = 927;
pub const iQonlydir: u32 = 928;
pub const iQopen: u32 = 929;
pub const iQopen_network_stream: u32 = 930;
pub const iQopentype: u32 = 931;
pub const iQoperations: u32 = 932;
pub const iQouter_border_width: u32 = 933;
pub const iQouter_edges: u32 = 934;
pub const iQouter_position: u32 = 935;
pub const iQouter_size: u32 = 936;
pub const iQouter_window_id: u32 = 937;
pub const iQoverflow_error: u32 = 938;
pub const iQoverlay: u32 = 939;
pub const iQoverlay_arrow: u32 = 940;
pub const iQoverlay_arrow_bitmap: u32 = 941;
pub const iQoverlay_arrow_string: u32 = 942;
pub const iQoverlayp: u32 = 943;
pub const iQoverride_redirect: u32 = 944;
pub const iQoverriding_local_map: u32 = 945;
pub const iQoverriding_plist_environment: u32 = 946;
pub const iQoverriding_terminal_local_map: u32 = 947;
pub const iQoverwrite_mode: u32 = 948;
pub const iQoverwrite_mode_binary: u32 = 949;
pub const iQp: u32 = 950;
pub const iQpaper: u32 = 951;
pub const iQparent_frame: u32 = 952;
pub const iQparent_id: u32 = 953;
pub const iQpbm: u32 = 954;
pub const iQpc: u32 = 955;
pub const iQpcpu: u32 = 956;
pub const iQpermanent_local: u32 = 957;
pub const iQpermanent_local_hook: u32 = 958;
pub const iQpgrp: u32 = 959;
pub const iQphi: u32 = 960;
pub const iQpipe: u32 = 961;
pub const iQpipe_process_p: u32 = 962;
pub const iQplay_sound_functions: u32 = 963;
pub const iQplist: u32 = 964;
pub const iQplistp: u32 = 965;
pub const iQplus: u32 = 966;
pub const iQpmem: u32 = 967;
pub const iQpng: u32 = 968;
pub const iQpoint_entered: u32 = 969;
pub const iQpoint_left: u32 = 970;
pub const iQpointer: u32 = 971;
pub const iQpolling_period: u32 = 972;
pub const iQpoly: u32 = 973;
pub const iQpop_handler: u32 = 974;
pub const iQposition: u32 = 975;
pub const iQpost_command_hook: u32 = 976;
pub const iQpost_gc_hook: u32 = 977;
pub const iQpost_self_insert_hook: u32 = 978;
pub const iQpostscript: u32 = 979;
pub const iQppid: u32 = 980;
pub const iQpre_command_hook: u32 = 981;
pub const iQpressed_button: u32 = 982;
pub const iQpri: u32 = 983;
pub const iQprint_escape_multibyte: u32 = 984;
pub const iQprint_escape_nonascii: u32 = 985;
pub const iQpriority: u32 = 986;
pub const iQprocess: u32 = 987;
pub const iQprocessp: u32 = 988;
pub const iQprofiler_backtrace_equal: u32 = 989;
pub const iQprogn: u32 = 990;
pub const iQpropertize: u32 = 991;
pub const iQprotected_field: u32 = 992;
pub const iQprovide: u32 = 993;
pub const iQpty: u32 = 994;
pub const iQpure: u32 = 995;
pub const iQpurecopy: u32 = 996;
pub const iQpush_handler: u32 = 997;
pub const iQq_overflow: u32 = 998;
pub const iQquit: u32 = 999;
pub const iQquote: u32 = 1000;
pub const iQraise: u32 = 1001;
pub const iQrange: u32 = 1002;
pub const iQrange_error: u32 = 1003;
pub const iQratio: u32 = 1004;
pub const iQraw_text: u32 = 1005;
pub const iQread: u32 = 1006;
pub const iQread_char: u32 = 1007;
pub const iQread_number: u32 = 1008;
pub const iQread_only: u32 = 1009;
pub const iQreal: u32 = 1010;
pub const iQrear_nonsticky: u32 = 1011;
pub const iQrecompute_lucid_menubar: u32 = 1012;
pub const iQrecord: u32 = 1013;
pub const iQrecord_unwind_current_buffer: u32 = 1014;
pub const iQrecord_unwind_protect_excursion: u32 = 1015;
pub const iQrecord_window_buffer: u32 = 1016;
pub const iQrecordp: u32 = 1017;
pub const iQrect: u32 = 1018;
pub const iQredisplay_dont_pause: u32 = 1019;
pub const iQredisplay_end_trigger_functions: u32 = 1020;
pub const iQredisplay_internal_xC_functionx: u32 = 1021;
pub const iQrehash_size: u32 = 1022;
pub const iQrehash_threshold: u32 = 1023;
pub const iQrelative: u32 = 1024;
pub const iQreleased_button: u32 = 1025;
pub const iQremap: u32 = 1026;
pub const iQremote_file_error: u32 = 1027;
pub const iQrename_file: u32 = 1028;
pub const iQreplace_buffer_in_windows: u32 = 1029;
pub const iQrequire: u32 = 1030;
pub const iQreturn: u32 = 1031;
pub const iQright: u32 = 1032;
pub const iQright_divider: u32 = 1033;
pub const iQright_divider_width: u32 = 1034;
pub const iQright_edge: u32 = 1035;
pub const iQright_fringe: u32 = 1036;
pub const iQright_margin: u32 = 1037;
pub const iQright_to_left: u32 = 1038;
pub const iQrightmost: u32 = 1039;
pub const iQrisky_local_variable: u32 = 1040;
pub const iQrotate: u32 = 1041;
pub const iQrotate90: u32 = 1042;
pub const iQrss: u32 = 1043;
pub const iQrun: u32 = 1044;
pub const iQrun_hook_query_error_with_timeout: u32 = 1045;
pub const iQrun_hook_with_args: u32 = 1046;
pub const iQrun_with_timer: u32 = 1047;
pub const iQsafe: u32 = 1048;
pub const iQsave_excursion: u32 = 1049;
pub const iQsave_session: u32 = 1050;
pub const iQscale: u32 = 1051;
pub const iQscan_error: u32 = 1052;
pub const iQscratch: u32 = 1053;
pub const iQscreen_gamma: u32 = 1054;
pub const iQscroll_bar: u32 = 1055;
pub const iQscroll_bar_background: u32 = 1056;
pub const iQscroll_bar_foreground: u32 = 1057;
pub const iQscroll_bar_height: u32 = 1058;
pub const iQscroll_bar_movement: u32 = 1059;
pub const iQscroll_bar_width: u32 = 1060;
pub const iQscroll_command: u32 = 1061;
pub const iQscroll_down: u32 = 1062;
pub const iQscroll_up: u32 = 1063;
pub const iQsearch_failed: u32 = 1064;
pub const iQselect_window: u32 = 1065;
pub const iQselection_request: u32 = 1066;
pub const iQsemi_bold: u32 = 1067;
pub const iQsemi_light: u32 = 1068;
pub const iQseqpacket: u32 = 1069;
pub const iQsequencep: u32 = 1070;
pub const iQserial: u32 = 1071;
pub const iQsess: u32 = 1072;
pub const iQset: u32 = 1073;
pub const iQset_args_to_local: u32 = 1074;
pub const iQset_default: u32 = 1075;
pub const iQset_file_acl: u32 = 1076;
pub const iQset_file_modes: u32 = 1077;
pub const iQset_file_selinux_context: u32 = 1078;
pub const iQset_file_times: u32 = 1079;
pub const iQset_frame_size: u32 = 1080;
pub const iQset_internal: u32 = 1081;
pub const iQset_par_to_local: u32 = 1082;
pub const iQset_rest_args_to_local: u32 = 1083;
pub const iQset_visited_file_modtime: u32 = 1084;
pub const iQset_window_configuration: u32 = 1085;
pub const iQsetcar: u32 = 1086;
pub const iQsetcdr: u32 = 1087;
pub const iQsetimm: u32 = 1088;
pub const iQsetq: u32 = 1089;
pub const iQsetting_constant: u32 = 1090;
pub const iQsha1: u32 = 1091;
pub const iQsha224: u32 = 1092;
pub const iQsha256: u32 = 1093;
pub const iQsha384: u32 = 1094;
pub const iQsha512: u32 = 1095;
pub const iQshift_jis: u32 = 1096;
pub const iQshlwapi: u32 = 1097;
pub const iQside_effect_free: u32 = 1098;
pub const iQsignal: u32 = 1099;
pub const iQsingularity_error: u32 = 1100;
pub const iQsize: u32 = 1101;
pub const iQskip_taskbar: u32 = 1102;
pub const iQslice: u32 = 1103;
pub const iQsound: u32 = 1104;
pub const iQsource: u32 = 1105;
pub const iQspace: u32 = 1106;
pub const iQspace_width: u32 = 1107;
pub const iQspecial_lowercase: u32 = 1108;
pub const iQspecial_titlecase: u32 = 1109;
pub const iQspecial_uppercase: u32 = 1110;
pub const iQstandard_input: u32 = 1111;
pub const iQstandard_output: u32 = 1112;
pub const iQstart: u32 = 1113;
pub const iQstart_process: u32 = 1114;
pub const iQstate: u32 = 1115;
pub const iQstderr: u32 = 1116;
pub const iQstdin: u32 = 1117;
pub const iQstdout: u32 = 1118;
pub const iQsticky: u32 = 1119;
pub const iQstime: u32 = 1120;
pub const iQstop: u32 = 1121;
pub const iQstraight: u32 = 1122;
pub const iQstring: u32 = 1123;
pub const iQstring_bytes: u32 = 1124;
pub const iQstring_lessp: u32 = 1125;
pub const iQstring_without_embedded_nulls_p: u32 = 1126;
pub const iQstringp: u32 = 1127;
pub const iQstrings: u32 = 1128;
pub const iQsub1: u32 = 1129;
pub const iQsubfeatures: u32 = 1130;
pub const iQsubr: u32 = 1131;
pub const iQsubrp: u32 = 1132;
pub const iQsubstitute_command_keys: u32 = 1133;
pub const iQsubstitute_env_in_file_name: u32 = 1134;
pub const iQsubstitute_in_file_name: u32 = 1135;
pub const iQsvg: u32 = 1136;
pub const iQsw: u32 = 1137;
pub const iQswitch_frame: u32 = 1138;
pub const iQsymbol: u32 = 1139;
pub const iQsymbolp: u32 = 1140;
pub const iQsymbols: u32 = 1141;
pub const iQsyntax_ppss: u32 = 1142;
pub const iQsyntax_ppss_flush_cache: u32 = 1143;
pub const iQsyntax_table: u32 = 1144;
pub const iQsyntax_table_p: u32 = 1145;
pub const iQtab_bar: u32 = 1146;
pub const iQtab_bar_lines: u32 = 1147;
pub const iQtab_bar_size: u32 = 1148;
pub const iQtab_line: u32 = 1149;
pub const iQtab_line_format: u32 = 1150;
pub const iQtarget_idx: u32 = 1151;
pub const iQtb_size_cb: u32 = 1152;
pub const iQtemp_buffer_setup_hook: u32 = 1153;
pub const iQtemp_buffer_show_hook: u32 = 1154;
pub const iQterminal: u32 = 1155;
pub const iQterminal_frame: u32 = 1156;
pub const iQterminal_live_p: u32 = 1157;
pub const iQtest: u32 = 1158;
pub const iQtext: u32 = 1159;
pub const iQtext_image_horiz: u32 = 1160;
pub const iQtext_pixels: u32 = 1161;
pub const iQtext_read_only: u32 = 1162;
pub const iQthcount: u32 = 1163;
pub const iQthin_space: u32 = 1164;
pub const iQthread: u32 = 1165;
pub const iQthread_event: u32 = 1166;
pub const iQthreadp: u32 = 1167;
pub const iQtiff: u32 = 1168;
pub const iQtime: u32 = 1169;
pub const iQtimer_event_handler: u32 = 1170;
pub const iQtitle: u32 = 1171;
pub const iQtitle_bar_size: u32 = 1172;
pub const iQtitlecase: u32 = 1173;
pub const iQtool_bar: u32 = 1174;
pub const iQtool_bar_external: u32 = 1175;
pub const iQtool_bar_lines: u32 = 1176;
pub const iQtool_bar_position: u32 = 1177;
pub const iQtool_bar_size: u32 = 1178;
pub const iQtooltip: u32 = 1179;
pub const iQtop: u32 = 1180;
pub const iQtop_bottom: u32 = 1181;
pub const iQtop_edge: u32 = 1182;
pub const iQtop_left_corner: u32 = 1183;
pub const iQtop_level: u32 = 1184;
pub const iQtop_only: u32 = 1185;
pub const iQtop_right_corner: u32 = 1186;
pub const iQtpgid: u32 = 1187;
pub const iQtrailing_whitespace: u32 = 1188;
pub const iQtranslation_table: u32 = 1189;
pub const iQtranslation_table_id: u32 = 1190;
pub const iQtrapping_constant: u32 = 1191;
pub const iQtruncation: u32 = 1192;
pub const iQttname: u32 = 1193;
pub const iQtty: u32 = 1194;
pub const iQtty_color_alist: u32 = 1195;
pub const iQtty_color_by_index: u32 = 1196;
pub const iQtty_color_desc: u32 = 1197;
pub const iQtty_color_mode: u32 = 1198;
pub const iQtty_color_standard_values: u32 = 1199;
pub const iQtty_menu_exit: u32 = 1200;
pub const iQtty_menu_ignore: u32 = 1201;
pub const iQtty_menu_mouse_movement: u32 = 1202;
pub const iQtty_menu_navigation_map: u32 = 1203;
pub const iQtty_menu_next_item: u32 = 1204;
pub const iQtty_menu_next_menu: u32 = 1205;
pub const iQtty_menu_prev_item: u32 = 1206;
pub const iQtty_menu_prev_menu: u32 = 1207;
pub const iQtty_menu_select: u32 = 1208;
pub const iQtty_mode_reset_strings: u32 = 1209;
pub const iQtty_mode_set_strings: u32 = 1210;
pub const iQtty_type: u32 = 1211;
pub const iQultra_bold: u32 = 1212;
pub const iQundecided: u32 = 1213;
pub const iQundecorated: u32 = 1214;
pub const iQundefined: u32 = 1215;
pub const iQunderflow_error: u32 = 1216;
pub const iQunderline_minimum_offset: u32 = 1217;
pub const iQundo_auto__add_boundary: u32 = 1218;
pub const iQundo_auto__last_boundary_cause: u32 = 1219;
pub const iQundo_auto__this_command_amalgamating: u32 = 1220;
pub const iQundo_auto__undoable_change: u32 = 1221;
pub const iQundo_auto__undoably_changed_buffers: u32 = 1222;
pub const iQundo_auto_amalgamate: u32 = 1223;
pub const iQunevalled: u32 = 1224;
pub const iQunhandled_file_name_directory: u32 = 1225;
pub const iQunicode: u32 = 1226;
pub const iQunicode_bmp: u32 = 1227;
pub const iQunicode_string_p: u32 = 1228;
pub const iQunix: u32 = 1229;
pub const iQunlet: u32 = 1230;
pub const iQunmount: u32 = 1231;
pub const iQunreachable: u32 = 1232;
pub const iQunspecified: u32 = 1233;
pub const iQunsplittable: u32 = 1234;
pub const iQup: u32 = 1235;
pub const iQupdate_frame_menubar: u32 = 1236;
pub const iQupdate_frame_tab_bar: u32 = 1237;
pub const iQupdate_frame_tool_bar: u32 = 1238;
pub const iQus_ascii: u32 = 1239;
pub const iQuser: u32 = 1240;
pub const iQuser_error: u32 = 1241;
pub const iQuser_position: u32 = 1242;
pub const iQuser_ptr: u32 = 1243;
pub const iQuser_ptrp: u32 = 1244;
pub const iQuser_search_failed: u32 = 1245;
pub const iQuser_size: u32 = 1246;
pub const iQutf_16: u32 = 1247;
pub const iQutf_16le: u32 = 1248;
pub const iQutf_8: u32 = 1249;
pub const iQutf_8_emacs: u32 = 1250;
pub const iQutf_8_string_p: u32 = 1251;
pub const iQutf_8_unix: u32 = 1252;
pub const iQutime: u32 = 1253;
pub const iQvalue: u32 = 1254;
pub const iQvariable_documentation: u32 = 1255;
pub const iQvector: u32 = 1256;
pub const iQvector_or_char_table_p: u32 = 1257;
pub const iQvector_slots: u32 = 1258;
pub const iQvectorp: u32 = 1259;
pub const iQvectors: u32 = 1260;
pub const iQverify_visited_file_modtime: u32 = 1261;
pub const iQvertical_border: u32 = 1262;
pub const iQvertical_line: u32 = 1263;
pub const iQvertical_scroll_bar: u32 = 1264;
pub const iQvertical_scroll_bars: u32 = 1265;
pub const iQvisibility: u32 = 1266;
pub const iQvisible: u32 = 1267;
pub const iQvisual: u32 = 1268;
pub const iQvoid_function: u32 = 1269;
pub const iQvoid_variable: u32 = 1270;
pub const iQvsize: u32 = 1271;
pub const iQw32: u32 = 1272;
pub const iQwait_for_wm: u32 = 1273;
pub const iQwall: u32 = 1274;
pub const iQwatchers: u32 = 1275;
pub const iQwave: u32 = 1276;
pub const iQweakness: u32 = 1277;
pub const iQwhen: u32 = 1278;
pub const iQwholenump: u32 = 1279;
pub const iQwidget_type: u32 = 1280;
pub const iQwidth: u32 = 1281;
pub const iQwidth_only: u32 = 1282;
pub const iQwindow: u32 = 1283;
pub const iQwindow__pixel_to_total: u32 = 1284;
pub const iQwindow__resize_mini_frame: u32 = 1285;
pub const iQwindow__resize_root_window: u32 = 1286;
pub const iQwindow__resize_root_window_vertically: u32 = 1287;
pub const iQwindow__sanitize_window_sizes: u32 = 1288;
pub const iQwindow_buffer_change_functions: u32 = 1289;
pub const iQwindow_configuration: u32 = 1290;
pub const iQwindow_configuration_change_hook: u32 = 1291;
pub const iQwindow_configuration_p: u32 = 1292;
pub const iQwindow_deletable_p: u32 = 1293;
pub const iQwindow_divider: u32 = 1294;
pub const iQwindow_divider_first_pixel: u32 = 1295;
pub const iQwindow_divider_last_pixel: u32 = 1296;
pub const iQwindow_id: u32 = 1297;
pub const iQwindow_live_p: u32 = 1298;
pub const iQwindow_point_insertion_type: u32 = 1299;
pub const iQwindow_scroll_functions: u32 = 1300;
pub const iQwindow_selection_change_functions: u32 = 1301;
pub const iQwindow_size: u32 = 1302;
pub const iQwindow_size_change_functions: u32 = 1303;
pub const iQwindow_state_change_functions: u32 = 1304;
pub const iQwindow_state_change_hook: u32 = 1305;
pub const iQwindow_valid_p: u32 = 1306;
pub const iQwindowp: u32 = 1307;
pub const iQworkarea: u32 = 1308;
pub const iQwr: u32 = 1309;
pub const iQwrap_prefix: u32 = 1310;
pub const iQwrite_region: u32 = 1311;
pub const iQwrite_region_annotate_functions: u32 = 1312;
pub const iQwrong_length_argument: u32 = 1313;
pub const iQwrong_number_of_arguments: u32 = 1314;
pub const iQwrong_register_subr_call: u32 = 1315;
pub const iQwrong_type_argument: u32 = 1316;
pub const iQx: u32 = 1317;
pub const iQx_check_fullscreen: u32 = 1318;
pub const iQx_create_frame_1: u32 = 1319;
pub const iQx_create_frame_2: u32 = 1320;
pub const iQx_frame_parameter: u32 = 1321;
pub const iQx_handle_net_wm_state: u32 = 1322;
pub const iQx_net_wm_state: u32 = 1323;
pub const iQx_resource_name: u32 = 1324;
pub const iQx_set_frame_parameters: u32 = 1325;
pub const iQx_set_fullscreen: u32 = 1326;
pub const iQx_set_menu_bar_lines: u32 = 1327;
pub const iQx_set_window_size_1: u32 = 1328;
pub const iQx_set_window_size_2: u32 = 1329;
pub const iQx_set_window_size_3: u32 = 1330;
pub const iQxbm: u32 = 1331;
pub const iQxg_change_toolbar_position: u32 = 1332;
pub const iQxg_frame_resized: u32 = 1333;
pub const iQxg_frame_set_char_size: u32 = 1334;
pub const iQxg_frame_set_char_size_1: u32 = 1335;
pub const iQxg_frame_set_char_size_2: u32 = 1336;
pub const iQxg_frame_set_char_size_3: u32 = 1337;
pub const iQxg_frame_set_char_size_4: u32 = 1338;
pub const iQxpm: u32 = 1339;
pub const iQxwidget: u32 = 1340;
pub const iQxwidget_event: u32 = 1341;
pub const iQxwidget_view: u32 = 1342;
pub const iQyes_or_no_p_history: u32 = 1343;
pub const iQz_group: u32 = 1344;
pub const iQzero_width: u32 = 1345;
pub const ARRAY_MARK_FLAG: i64 = -9223372036854775808;
pub const EMACS_REGEX_H: u32 = 1;
pub const SYSSELECT_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_ISO: u32 = 4;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const _BITS_TIMEX_H: u32 = 1;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 32769;
pub const ADJ_OFFSET_SS_READ: u32 = 40961;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_CLKB: u32 = 16384;
pub const MOD_CLKA: u32 = 32769;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const GNULIB_defined_struct_time_t_must_be_integral: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const PTHREAD_ATTR_NO_SIGMASK_NP: i32 = -1;
pub const FLOAT_TO_STRING_BUFSIZE: u32 = 350;
pub const CHILD_SETUP_ERROR_DESC: &'static [u8; 12usize] = b"Doing vfork\0";
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const USE_STACK_LISP_OBJECTS: u32 = 1;
pub const uLSQM: &'static [u8; 4usize] = b"\xE2\x80\x98\0";
pub const uRSQM: &'static [u8; 4usize] = b"\xE2\x80\x99\0";
pub const CCL_STAT_SUCCESS: u32 = 0;
pub const CCL_STAT_SUSPEND_BY_SRC: u32 = 1;
pub const CCL_STAT_SUSPEND_BY_DST: u32 = 2;
pub const CCL_STAT_INVALID_CMD: u32 = 3;
pub const CCL_STAT_QUIT: u32 = 4;
pub const ISO_MAX_DIMENSION: u32 = 3;
pub const ISO_MAX_CHARS: u32 = 2;
pub const ISO_MAX_FINAL: u32 = 128;
pub const EMACS_MULE_LEADING_CODE_PRIVATE_11: u32 = 154;
pub const EMACS_MULE_LEADING_CODE_PRIVATE_12: u32 = 155;
pub const EMACS_MULE_LEADING_CODE_PRIVATE_21: u32 = 156;
pub const EMACS_MULE_LEADING_CODE_PRIVATE_22: u32 = 157;
pub const CODING_MODE_LAST_BLOCK: u32 = 1;
pub const CODING_MODE_SELECTIVE_DISPLAY: u32 = 2;
pub const CODING_MODE_DIRECTION: u32 = 4;
pub const CODING_MODE_FIXED_DESTINATION: u32 = 8;
pub const CODING_MODE_SAFE_ENCODING: u32 = 16;
pub const FONT_ENCODING_NOT_DECIDED: u32 = 255;
pub const PT_PER_INCH: f64 = 72.27;
pub const FONT_PIXEL_SIZE_QUANTUM: u32 = 1;
pub const FONT_INVALID_CODE: u32 = 4294967295;
pub const GCForeground: u32 = 1;
pub const GCBackground: u32 = 2;
pub const GCFont: u32 = 3;
pub const GCGraphicsExposures: u32 = 0;
pub const ForgetGravity: u32 = 0;
pub const NorthWestGravity: u32 = 1;
pub const NorthGravity: u32 = 2;
pub const NorthEastGravity: u32 = 3;
pub const WestGravity: u32 = 4;
pub const CenterGravity: u32 = 5;
pub const EastGravity: u32 = 6;
pub const SouthWestGravity: u32 = 7;
pub const SouthGravity: u32 = 8;
pub const SouthEastGravity: u32 = 9;
pub const StaticGravity: u32 = 10;
pub const NoValue: u32 = 0;
pub const XValue: u32 = 1;
pub const YValue: u32 = 2;
pub const WidthValue: u32 = 4;
pub const HeightValue: u32 = 8;
pub const AllValues: u32 = 15;
pub const XNegative: u32 = 16;
pub const YNegative: u32 = 32;
pub const USPosition: u32 = 1;
pub const USSize: u32 = 2;
pub const PPosition: u32 = 4;
pub const PSize: u32 = 8;
pub const PMinSize: u32 = 16;
pub const PMaxSize: u32 = 32;
pub const PResizeInc: u32 = 64;
pub const PAspect: u32 = 128;
pub const PBaseSize: u32 = 256;
pub const PWinGravity: u32 = 512;
pub const FRINGE_ID_BITS: u32 = 16;
pub const FRINGE_HEIGHT_BITS: u32 = 8;
pub const FACE_ID_BITS: u32 = 20;
pub const FONT_TYPE_UNKNOWN: u32 = 0;
pub const OVERLAPS_PRED: u32 = 1;
pub const OVERLAPS_SUCC: u32 = 2;
pub const OVERLAPS_BOTH: u32 = 3;
pub const OVERLAPS_ERASED_CURSOR: u32 = 4;
pub const MAX_FACE_ID: u32 = 1048575;
pub const BIDI_MAXDEPTH: u32 = 125;
pub const MAX_FRINGE_BITMAPS: u32 = 65536;
pub const IT_STACK_SIZE: u32 = 5;
pub const OVERLAY_STRING_CHUNK_SIZE: u32 = 16;
pub const DEFAULT_IMAGE_WIDTH: u32 = 30;
pub const DEFAULT_IMAGE_HEIGHT: u32 = 30;
pub const TOP_CORNER: u32 = 0;
pub const LEFT_CORNER: u32 = 1;
pub const BOT_CORNER: u32 = 2;
pub const RIGHT_CORNER: u32 = 3;
pub const DEFAULT_IMAGE_ASCENT: u32 = 50;
pub const CENTERED_IMAGE_ASCENT: i32 = -1;
pub const IMAGE_CACHE_BUCKETS_SIZE: u32 = 1001;
pub const DEFAULT_TAB_BAR_BUTTON_MARGIN: u32 = 4;
pub const DEFAULT_TAB_BAR_BUTTON_RELIEF: u32 = 1;
pub const DEFAULT_TAB_BAR_IMAGE_HEIGHT: u32 = 18;
pub const DEFAULT_TOOL_BAR_LABEL_SIZE: u32 = 14;
pub const DEFAULT_TOOL_BAR_BUTTON_MARGIN: u32 = 4;
pub const DEFAULT_TOOL_BAR_BUTTON_RELIEF: u32 = 1;
pub const DEFAULT_TOOL_BAR_IMAGE_HEIGHT: u32 = 24;
pub const TTY_CAP_INVERSE: u32 = 1;
pub const TTY_CAP_UNDERLINE: u32 = 2;
pub const TTY_CAP_BOLD: u32 = 4;
pub const TTY_CAP_DIM: u32 = 8;
pub const TTY_CAP_ITALIC: u32 = 16;
pub const TTY_CAP_STRIKE_THROUGH: u32 = 32;
pub const TRY_WINDOW_CHECK_MARGINS: u32 = 1;
pub const TRY_WINDOW_IGNORE_FONTS_CHANGE: u32 = 2;
pub const MAX_COMPOSITION_COMPONENTS: u32 = 16;
pub const CHECK_HEAD: u32 = 1;
pub const CHECK_TAIL: u32 = 2;
pub const CHECK_INSIDE: u32 = 4;
pub const CHECK_BORDER: u32 = 3;
pub const CHECK_ALL: u32 = 7;
pub const CODING_ANNOTATION_MASK: u32 = 255;
pub const CODING_ANNOTATE_COMPOSITION_MASK: u32 = 1;
pub const CODING_ANNOTATE_DIRECTION_MASK: u32 = 2;
pub const CODING_ANNOTATE_CHARSET_MASK: u32 = 3;
pub const CODING_FOR_UNIBYTE_MASK: u32 = 256;
pub const CODING_REQUIRE_FLUSHING_MASK: u32 = 512;
pub const CODING_REQUIRE_DECODING_MASK: u32 = 1024;
pub const CODING_REQUIRE_ENCODING_MASK: u32 = 2048;
pub const CODING_REQUIRE_DETECTION_MASK: u32 = 4096;
pub const CODING_RESET_AT_BOL_MASK: u32 = 8192;
pub const DISP_TABLE_EXTRA_SLOTS: u32 = 6;
pub const SPACEGLYPH: u32 = 32;
pub const NULL_GLYPH: u32 = 0;
pub const gnu_xbm_width: u32 = 50;
pub const gnu_xbm_height: u32 = 50;
pub const EMACS_MAJOR_VERSION: u32 = 28;
pub const EMACS_LIMB_MAX: i32 = -1;
pub const PATH_LOADSEARCH: &'static [u8; 36usize] = b"/usr/local/share/emacs/28.0.50/lisp\0";
pub const PATH_REL_LOADSEARCH: &'static [u8; 13usize] = b"28.0.50/lisp\0";
pub const PATH_SITELOADSEARCH: &'static [u8; 74usize] =
    b"/usr/local/share/emacs/28.0.50/site-lisp:/usr/local/share/emacs/site-lisp\0";
pub const PATH_DUMPLOADSEARCH: &'static [u8; 29usize] = b"/home/fredbert/emacs-ng/lisp\0";
pub const PATH_EXEC: &'static [u8; 53usize] =
    b"/usr/local/libexec/emacs/28.0.50/x86_64-pc-linux-gnu\0";
pub const PATH_DATA: &'static [u8; 35usize] = b"/usr/local/share/emacs/28.0.50/etc\0";
pub const PATH_BITMAPS: &'static [u8; 25usize] = b"/usr/include/X11/bitmaps\0";
pub const PATH_DOC: &'static [u8; 35usize] = b"/usr/local/share/emacs/28.0.50/etc\0";
pub const PATH_INFO: &'static [u8; 22usize] = b"/usr/local/share/info\0";
pub const PATH_X_DEFAULTS : & 'static [ u8 ; 300usize ] = b"/usr/share/X11/%L/%T/%N%C%S:/usr/share/X11/%l/%T/%N%C%S:/usr/share/X11/%T/%N%C%S:/usr/share/X11/%L/%T/%N%S:/usr/share/X11/%l/%T/%N%S:/usr/share/X11/%T/%N%S:/usr/lib/X11/%L/%T/%N%C%S:/usr/lib/X11/%l/%T/%N%C%S:/usr/lib/X11/%T/%N%C%S:/usr/lib/X11/%L/%T/%N%S:/usr/lib/X11/%l/%T/%N%S:/usr/lib/X11/%T/%N%S\0" ;
pub const _SYS_TIME_H: u32 = 1;
pub const _PATH_DEFPATH: &'static [u8; 14usize] = b"/usr/bin:/bin\0";
pub const _PATH_STDPATH: &'static [u8; 30usize] = b"/usr/bin:/bin:/usr/sbin:/sbin\0";
pub const _PATH_BSHELL: &'static [u8; 8usize] = b"/bin/sh\0";
pub const _PATH_CONSOLE: &'static [u8; 13usize] = b"/dev/console\0";
pub const _PATH_CSHELL: &'static [u8; 9usize] = b"/bin/csh\0";
pub const _PATH_DEVDB: &'static [u8; 16usize] = b"/var/run/dev.db\0";
pub const _PATH_DEVNULL: &'static [u8; 10usize] = b"/dev/null\0";
pub const _PATH_DRUM: &'static [u8; 10usize] = b"/dev/drum\0";
pub const _PATH_GSHADOW: &'static [u8; 13usize] = b"/etc/gshadow\0";
pub const _PATH_KLOG: &'static [u8; 11usize] = b"/proc/kmsg\0";
pub const _PATH_KMEM: &'static [u8; 10usize] = b"/dev/kmem\0";
pub const _PATH_LASTLOG: &'static [u8; 17usize] = b"/var/log/lastlog\0";
pub const _PATH_MAILDIR: &'static [u8; 10usize] = b"/var/mail\0";
pub const _PATH_MAN: &'static [u8; 15usize] = b"/usr/share/man\0";
pub const _PATH_MEM: &'static [u8; 9usize] = b"/dev/mem\0";
pub const _PATH_MNTTAB: &'static [u8; 11usize] = b"/etc/fstab\0";
pub const _PATH_MOUNTED: &'static [u8; 10usize] = b"/etc/mtab\0";
pub const _PATH_NOLOGIN: &'static [u8; 13usize] = b"/etc/nologin\0";
pub const _PATH_PRESERVE: &'static [u8; 9usize] = b"/var/lib\0";
pub const _PATH_RWHODIR: &'static [u8; 16usize] = b"/var/spool/rwho\0";
pub const _PATH_SENDMAIL: &'static [u8; 19usize] = b"/usr/sbin/sendmail\0";
pub const _PATH_SHADOW: &'static [u8; 12usize] = b"/etc/shadow\0";
pub const _PATH_SHELLS: &'static [u8; 12usize] = b"/etc/shells\0";
pub const _PATH_TTY: &'static [u8; 9usize] = b"/dev/tty\0";
pub const _PATH_UNIX: &'static [u8; 14usize] = b"/boot/vmlinux\0";
pub const _PATH_UTMP: &'static [u8; 14usize] = b"/var/run/utmp\0";
pub const _PATH_VI: &'static [u8; 12usize] = b"/usr/bin/vi\0";
pub const _PATH_WTMP: &'static [u8; 14usize] = b"/var/log/wtmp\0";
pub const _PATH_DEV: &'static [u8; 6usize] = b"/dev/\0";
pub const _PATH_TMP: &'static [u8; 6usize] = b"/tmp/\0";
pub const _PATH_VARDB: &'static [u8; 9usize] = b"/var/db/\0";
pub const _PATH_VARRUN: &'static [u8; 10usize] = b"/var/run/\0";
pub const _PATH_VARTMP: &'static [u8; 10usize] = b"/var/tmp/\0";
pub const GPM_NODE_DIR: &'static [u8; 10usize] = b"/var/run/\0";
pub const GPM_NODE_DIR_MODE: u32 = 509;
pub const GPM_NODE_PID: &'static [u8; 17usize] = b"/var/run/gpm.pid\0";
pub const GPM_NODE_DEV: &'static [u8; 12usize] = b"/dev/gpmctl\0";
pub const GPM_NODE_CTL: &'static [u8; 12usize] = b"/dev/gpmctl\0";
pub const GPM_NODE_FIFO: &'static [u8; 13usize] = b"/dev/gpmdata\0";
pub const GPM_B_DOWN: u32 = 32;
pub const GPM_B_UP: u32 = 16;
pub const GPM_B_FOURTH: u32 = 8;
pub const GPM_B_LEFT: u32 = 4;
pub const GPM_B_MIDDLE: u32 = 2;
pub const GPM_B_RIGHT: u32 = 1;
pub const GPM_B_NONE: u32 = 0;
pub const GPM_REQ_SNAPSHOT: u32 = 0;
pub const GPM_REQ_BUTTONS: u32 = 1;
pub const GPM_REQ_CONFIG: u32 = 2;
pub const GPM_REQ_NOPASTE: u32 = 3;
pub const GPM_MAGIC: u32 = 1198550348;
pub const _SYS_IOCTL_H: u32 = 1;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const TCGETS: u32 = 21505;
pub const TCSETS: u32 = 21506;
pub const TCSETSW: u32 = 21507;
pub const TCSETSF: u32 = 21508;
pub const TCGETA: u32 = 21509;
pub const TCSETA: u32 = 21510;
pub const TCSETAW: u32 = 21511;
pub const TCSETAF: u32 = 21512;
pub const TCSBRK: u32 = 21513;
pub const TCXONC: u32 = 21514;
pub const TCFLSH: u32 = 21515;
pub const TIOCEXCL: u32 = 21516;
pub const TIOCNXCL: u32 = 21517;
pub const TIOCSCTTY: u32 = 21518;
pub const TIOCGPGRP: u32 = 21519;
pub const TIOCSPGRP: u32 = 21520;
pub const TIOCOUTQ: u32 = 21521;
pub const TIOCSTI: u32 = 21522;
pub const TIOCGWINSZ: u32 = 21523;
pub const TIOCSWINSZ: u32 = 21524;
pub const TIOCMGET: u32 = 21525;
pub const TIOCMBIS: u32 = 21526;
pub const TIOCMBIC: u32 = 21527;
pub const TIOCMSET: u32 = 21528;
pub const TIOCGSOFTCAR: u32 = 21529;
pub const TIOCSSOFTCAR: u32 = 21530;
pub const FIONREAD: u32 = 21531;
pub const TIOCINQ: u32 = 21531;
pub const TIOCLINUX: u32 = 21532;
pub const TIOCCONS: u32 = 21533;
pub const TIOCGSERIAL: u32 = 21534;
pub const TIOCSSERIAL: u32 = 21535;
pub const TIOCPKT: u32 = 21536;
pub const FIONBIO: u32 = 21537;
pub const TIOCNOTTY: u32 = 21538;
pub const TIOCSETD: u32 = 21539;
pub const TIOCGETD: u32 = 21540;
pub const TCSBRKP: u32 = 21541;
pub const TIOCSBRK: u32 = 21543;
pub const TIOCCBRK: u32 = 21544;
pub const TIOCGSID: u32 = 21545;
pub const TIOCGRS485: u32 = 21550;
pub const TIOCSRS485: u32 = 21551;
pub const TCGETX: u32 = 21554;
pub const TCSETX: u32 = 21555;
pub const TCSETXF: u32 = 21556;
pub const TCSETXW: u32 = 21557;
pub const TIOCVHANGUP: u32 = 21559;
pub const FIONCLEX: u32 = 21584;
pub const FIOCLEX: u32 = 21585;
pub const FIOASYNC: u32 = 21586;
pub const TIOCSERCONFIG: u32 = 21587;
pub const TIOCSERGWILD: u32 = 21588;
pub const TIOCSERSWILD: u32 = 21589;
pub const TIOCGLCKTRMIOS: u32 = 21590;
pub const TIOCSLCKTRMIOS: u32 = 21591;
pub const TIOCSERGSTRUCT: u32 = 21592;
pub const TIOCSERGETLSR: u32 = 21593;
pub const TIOCSERGETMULTI: u32 = 21594;
pub const TIOCSERSETMULTI: u32 = 21595;
pub const TIOCMIWAIT: u32 = 21596;
pub const TIOCGICOUNT: u32 = 21597;
pub const FIOQSIZE: u32 = 21600;
pub const TIOCPKT_DATA: u32 = 0;
pub const TIOCPKT_FLUSHREAD: u32 = 1;
pub const TIOCPKT_FLUSHWRITE: u32 = 2;
pub const TIOCPKT_STOP: u32 = 4;
pub const TIOCPKT_START: u32 = 8;
pub const TIOCPKT_NOSTOP: u32 = 16;
pub const TIOCPKT_DOSTOP: u32 = 32;
pub const TIOCPKT_IOCTL: u32 = 64;
pub const TIOCSER_TEMT: u32 = 1;
pub const SIOCADDRT: u32 = 35083;
pub const SIOCDELRT: u32 = 35084;
pub const SIOCRTMSG: u32 = 35085;
pub const SIOCGIFNAME: u32 = 35088;
pub const SIOCSIFLINK: u32 = 35089;
pub const SIOCGIFCONF: u32 = 35090;
pub const SIOCGIFFLAGS: u32 = 35091;
pub const SIOCSIFFLAGS: u32 = 35092;
pub const SIOCGIFADDR: u32 = 35093;
pub const SIOCSIFADDR: u32 = 35094;
pub const SIOCGIFDSTADDR: u32 = 35095;
pub const SIOCSIFDSTADDR: u32 = 35096;
pub const SIOCGIFBRDADDR: u32 = 35097;
pub const SIOCSIFBRDADDR: u32 = 35098;
pub const SIOCGIFNETMASK: u32 = 35099;
pub const SIOCSIFNETMASK: u32 = 35100;
pub const SIOCGIFMETRIC: u32 = 35101;
pub const SIOCSIFMETRIC: u32 = 35102;
pub const SIOCGIFMEM: u32 = 35103;
pub const SIOCSIFMEM: u32 = 35104;
pub const SIOCGIFMTU: u32 = 35105;
pub const SIOCSIFMTU: u32 = 35106;
pub const SIOCSIFNAME: u32 = 35107;
pub const SIOCSIFHWADDR: u32 = 35108;
pub const SIOCGIFENCAP: u32 = 35109;
pub const SIOCSIFENCAP: u32 = 35110;
pub const SIOCGIFHWADDR: u32 = 35111;
pub const SIOCGIFSLAVE: u32 = 35113;
pub const SIOCSIFSLAVE: u32 = 35120;
pub const SIOCADDMULTI: u32 = 35121;
pub const SIOCDELMULTI: u32 = 35122;
pub const SIOCGIFINDEX: u32 = 35123;
pub const SIOGIFINDEX: u32 = 35123;
pub const SIOCSIFPFLAGS: u32 = 35124;
pub const SIOCGIFPFLAGS: u32 = 35125;
pub const SIOCDIFADDR: u32 = 35126;
pub const SIOCSIFHWBROADCAST: u32 = 35127;
pub const SIOCGIFCOUNT: u32 = 35128;
pub const SIOCGIFBR: u32 = 35136;
pub const SIOCSIFBR: u32 = 35137;
pub const SIOCGIFTXQLEN: u32 = 35138;
pub const SIOCSIFTXQLEN: u32 = 35139;
pub const SIOCDARP: u32 = 35155;
pub const SIOCGARP: u32 = 35156;
pub const SIOCSARP: u32 = 35157;
pub const SIOCDRARP: u32 = 35168;
pub const SIOCGRARP: u32 = 35169;
pub const SIOCSRARP: u32 = 35170;
pub const SIOCGIFMAP: u32 = 35184;
pub const SIOCSIFMAP: u32 = 35185;
pub const SIOCADDDLCI: u32 = 35200;
pub const SIOCDELDLCI: u32 = 35201;
pub const SIOCDEVPRIVATE: u32 = 35312;
pub const SIOCPROTOPRIVATE: u32 = 35296;
pub const NCC: u32 = 8;
pub const TIOCM_LE: u32 = 1;
pub const TIOCM_DTR: u32 = 2;
pub const TIOCM_RTS: u32 = 4;
pub const TIOCM_ST: u32 = 8;
pub const TIOCM_SR: u32 = 16;
pub const TIOCM_CTS: u32 = 32;
pub const TIOCM_CAR: u32 = 64;
pub const TIOCM_RNG: u32 = 128;
pub const TIOCM_DSR: u32 = 256;
pub const TIOCM_CD: u32 = 64;
pub const TIOCM_RI: u32 = 128;
pub const N_TTY: u32 = 0;
pub const N_SLIP: u32 = 1;
pub const N_MOUSE: u32 = 2;
pub const N_PPP: u32 = 3;
pub const N_STRIP: u32 = 4;
pub const N_AX25: u32 = 5;
pub const N_X25: u32 = 6;
pub const N_6PACK: u32 = 7;
pub const N_MASC: u32 = 8;
pub const N_R3964: u32 = 9;
pub const N_PROFIBUS_FDL: u32 = 10;
pub const N_IRDA: u32 = 11;
pub const N_SMSBLOCK: u32 = 12;
pub const N_HDLC: u32 = 13;
pub const N_SYNC_PPP: u32 = 14;
pub const N_HCI: u32 = 15;
pub const CEOL: u8 = 0u8;
pub const CERASE: u32 = 127;
pub const CSTATUS: u8 = 0u8;
pub const CMIN: u32 = 1;
pub const CQUIT: u32 = 28;
pub const CTIME: u32 = 0;
pub const CBRK: u8 = 0u8;
pub const MIN_SAFE_WINDOW_WIDTH: u32 = 2;
pub const MIN_SAFE_WINDOW_HEIGHT: u32 = 1;
pub const USE_HORIZONTAL_SCROLL_BARS: u32 = 0;
pub const EMACS_CLASS: &'static [u8; 6usize] = b"Emacs\0";
pub const GNUTLS_VERSION: &'static [u8; 6usize] = b"3.7.1\0";
pub const GNUTLS_VERSION_MAJOR: u32 = 3;
pub const GNUTLS_VERSION_MINOR: u32 = 7;
pub const GNUTLS_VERSION_PATCH: u32 = 1;
pub const GNUTLS_VERSION_NUMBER: u32 = 198401;
pub const GNUTLS_MAX_ALGORITHM_NUM: u32 = 64;
pub const GNUTLS_MAX_SESSION_ID_SIZE: u32 = 32;
pub const GNUTLS_SERVER: u32 = 1;
pub const GNUTLS_CLIENT: u32 = 2;
pub const GNUTLS_DATAGRAM: u32 = 4;
pub const GNUTLS_NONBLOCK: u32 = 8;
pub const GNUTLS_NO_EXTENSIONS: u32 = 16;
pub const GNUTLS_NO_REPLAY_PROTECTION: u32 = 32;
pub const GNUTLS_NO_SIGNAL: u32 = 64;
pub const GNUTLS_ALLOW_ID_CHANGE: u32 = 128;
pub const GNUTLS_ENABLE_FALSE_START: u32 = 256;
pub const GNUTLS_FORCE_CLIENT_CERT: u32 = 512;
pub const GNUTLS_NO_TICKETS: u32 = 1024;
pub const GNUTLS_ENABLE_CERT_TYPE_NEG: u32 = 0;
pub const GNUTLS_KU_PEER: u32 = 1;
pub const GNUTLS_SIGN_FLAG_SECURE_FOR_CERTS: u32 = 1;
pub const GNUTLS_HEARTBEAT_WAIT: u32 = 1;
pub const GNUTLS_RECORD_WAIT: u32 = 1;
pub const GNUTLS_HB_PEER_ALLOWED_TO_SEND: u32 = 1;
pub const GNUTLS_HB_PEER_NOT_ALLOWED_TO_SEND: u32 = 2;
pub const GNUTLS_HB_LOCAL_ALLOWED_TO_SEND: u32 = 4;
pub const GNUTLS_PRIORITY_INIT_DEF_APPEND: u32 = 1;
pub const GNUTLS_PRIORITY_LIST_INIT_KEYWORDS: u32 = 1;
pub const GNUTLS_PRIORITY_LIST_SPECIAL: u32 = 2;
pub const GNUTLS_MAX_SESSION_ID: u32 = 32;
pub const GNUTLS_HOOK_POST: u32 = 1;
pub const GNUTLS_HOOK_PRE: u32 = 0;
pub const GNUTLS_HOOK_BOTH: i32 = -1;
pub const GNUTLS_OCSP_SR_IS_AVAIL: u32 = 1;
pub const _SYS_UIO_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const UIO_MAXIOV: u32 = 1024;
pub const _BITS_UIO_EXT_H: u32 = 1;
pub const RWF_HIPRI: u32 = 1;
pub const RWF_DSYNC: u32 = 2;
pub const RWF_SYNC: u32 = 4;
pub const RWF_NOWAIT: u32 = 8;
pub const RWF_APPEND: u32 = 16;
pub const GNUTLS_IDNA_FORCE_2008: u32 = 2;
pub const GNUTLS_KEY_DIGITAL_SIGNATURE: u32 = 128;
pub const GNUTLS_KEY_NON_REPUDIATION: u32 = 64;
pub const GNUTLS_KEY_KEY_ENCIPHERMENT: u32 = 32;
pub const GNUTLS_KEY_DATA_ENCIPHERMENT: u32 = 16;
pub const GNUTLS_KEY_KEY_AGREEMENT: u32 = 8;
pub const GNUTLS_KEY_KEY_CERT_SIGN: u32 = 4;
pub const GNUTLS_KEY_CRL_SIGN: u32 = 2;
pub const GNUTLS_KEY_ENCIPHER_ONLY: u32 = 1;
pub const GNUTLS_KEY_DECIPHER_ONLY: u32 = 32768;
pub const GNUTLS_SCOMMIT_FLAG_ALLOW_BROKEN: u32 = 1;
pub const GNUTLS_UTF8_IGNORE_ERRS: u32 = 1;
pub const GNUTLS_EXT_RAW_FLAG_TLS_CLIENT_HELLO: u32 = 1;
pub const GNUTLS_EXT_RAW_FLAG_DTLS_CLIENT_HELLO: u32 = 2;
pub const GNUTLS_FIPS140_SET_MODE_THREAD: u32 = 1;
pub const GNUTLS_E_SUCCESS: u32 = 0;
pub const GNUTLS_E_UNKNOWN_COMPRESSION_ALGORITHM: i32 = -3;
pub const GNUTLS_E_UNKNOWN_CIPHER_TYPE: i32 = -6;
pub const GNUTLS_E_LARGE_PACKET: i32 = -7;
pub const GNUTLS_E_UNSUPPORTED_VERSION_PACKET: i32 = -8;
pub const GNUTLS_E_UNEXPECTED_PACKET_LENGTH: i32 = -9;
pub const GNUTLS_E_INVALID_SESSION: i32 = -10;
pub const GNUTLS_E_FATAL_ALERT_RECEIVED: i32 = -12;
pub const GNUTLS_E_UNEXPECTED_PACKET: i32 = -15;
pub const GNUTLS_E_WARNING_ALERT_RECEIVED: i32 = -16;
pub const GNUTLS_E_ERROR_IN_FINISHED_PACKET: i32 = -18;
pub const GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET: i32 = -19;
pub const GNUTLS_E_UNKNOWN_CIPHER_SUITE: i32 = -21;
pub const GNUTLS_E_UNWANTED_ALGORITHM: i32 = -22;
pub const GNUTLS_E_MPI_SCAN_FAILED: i32 = -23;
pub const GNUTLS_E_DECRYPTION_FAILED: i32 = -24;
pub const GNUTLS_E_MEMORY_ERROR: i32 = -25;
pub const GNUTLS_E_DECOMPRESSION_FAILED: i32 = -26;
pub const GNUTLS_E_COMPRESSION_FAILED: i32 = -27;
pub const GNUTLS_E_AGAIN: i32 = -28;
pub const GNUTLS_E_EXPIRED: i32 = -29;
pub const GNUTLS_E_DB_ERROR: i32 = -30;
pub const GNUTLS_E_KEYFILE_ERROR: i32 = -31;
pub const GNUTLS_E_INSUFFICIENT_CREDENTIALS: i32 = -32;
pub const GNUTLS_E_INSUFICIENT_CREDENTIALS: i32 = -32;
pub const GNUTLS_E_INSUFFICIENT_CRED: i32 = -32;
pub const GNUTLS_E_INSUFICIENT_CRED: i32 = -32;
pub const GNUTLS_E_HASH_FAILED: i32 = -33;
pub const GNUTLS_E_BASE64_DECODING_ERROR: i32 = -34;
pub const GNUTLS_E_MPI_PRINT_FAILED: i32 = -35;
pub const GNUTLS_E_REHANDSHAKE: i32 = -37;
pub const GNUTLS_E_GOT_APPLICATION_DATA: i32 = -38;
pub const GNUTLS_E_RECORD_LIMIT_REACHED: i32 = -39;
pub const GNUTLS_E_ENCRYPTION_FAILED: i32 = -40;
pub const GNUTLS_E_PK_ENCRYPTION_FAILED: i32 = -44;
pub const GNUTLS_E_PK_DECRYPTION_FAILED: i32 = -45;
pub const GNUTLS_E_PK_SIGN_FAILED: i32 = -46;
pub const GNUTLS_E_X509_UNSUPPORTED_CRITICAL_EXTENSION: i32 = -47;
pub const GNUTLS_E_KEY_USAGE_VIOLATION: i32 = -48;
pub const GNUTLS_E_NO_CERTIFICATE_FOUND: i32 = -49;
pub const GNUTLS_E_INVALID_REQUEST: i32 = -50;
pub const GNUTLS_E_SHORT_MEMORY_BUFFER: i32 = -51;
pub const GNUTLS_E_INTERRUPTED: i32 = -52;
pub const GNUTLS_E_PUSH_ERROR: i32 = -53;
pub const GNUTLS_E_PULL_ERROR: i32 = -54;
pub const GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER: i32 = -55;
pub const GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE: i32 = -56;
pub const GNUTLS_E_PKCS1_WRONG_PAD: i32 = -57;
pub const GNUTLS_E_RECEIVED_ILLEGAL_EXTENSION: i32 = -58;
pub const GNUTLS_E_INTERNAL_ERROR: i32 = -59;
pub const GNUTLS_E_DH_PRIME_UNACCEPTABLE: i32 = -63;
pub const GNUTLS_E_FILE_ERROR: i32 = -64;
pub const GNUTLS_E_TOO_MANY_EMPTY_PACKETS: i32 = -78;
pub const GNUTLS_E_UNKNOWN_PK_ALGORITHM: i32 = -80;
pub const GNUTLS_E_TOO_MANY_HANDSHAKE_PACKETS: i32 = -81;
pub const GNUTLS_E_RECEIVED_DISALLOWED_NAME: i32 = -82;
pub const GNUTLS_E_CERTIFICATE_REQUIRED: i32 = -112;
pub const GNUTLS_E_NO_TEMPORARY_RSA_PARAMS: i32 = -84;
pub const GNUTLS_E_NO_COMPRESSION_ALGORITHMS: i32 = -86;
pub const GNUTLS_E_NO_CIPHER_SUITES: i32 = -87;
pub const GNUTLS_E_OPENPGP_GETKEY_FAILED: i32 = -88;
pub const GNUTLS_E_PK_SIG_VERIFY_FAILED: i32 = -89;
pub const GNUTLS_E_ILLEGAL_SRP_USERNAME: i32 = -90;
pub const GNUTLS_E_KEYFILE_PARSING_ERROR: i32 = -91;
pub const GNUTLS_E_NO_TEMPORARY_DH_PARAMS: i32 = -93;
pub const GNUTLS_E_ASN1_ELEMENT_NOT_FOUND: i32 = -67;
pub const GNUTLS_E_ASN1_IDENTIFIER_NOT_FOUND: i32 = -68;
pub const GNUTLS_E_ASN1_DER_ERROR: i32 = -69;
pub const GNUTLS_E_ASN1_VALUE_NOT_FOUND: i32 = -70;
pub const GNUTLS_E_ASN1_GENERIC_ERROR: i32 = -71;
pub const GNUTLS_E_ASN1_VALUE_NOT_VALID: i32 = -72;
pub const GNUTLS_E_ASN1_TAG_ERROR: i32 = -73;
pub const GNUTLS_E_ASN1_TAG_IMPLICIT: i32 = -74;
pub const GNUTLS_E_ASN1_TYPE_ANY_ERROR: i32 = -75;
pub const GNUTLS_E_ASN1_SYNTAX_ERROR: i32 = -76;
pub const GNUTLS_E_ASN1_DER_OVERFLOW: i32 = -77;
pub const GNUTLS_E_OPENPGP_UID_REVOKED: i32 = -79;
pub const GNUTLS_E_CERTIFICATE_ERROR: i32 = -43;
pub const GNUTLS_E_X509_CERTIFICATE_ERROR: i32 = -43;
pub const GNUTLS_E_CERTIFICATE_KEY_MISMATCH: i32 = -60;
pub const GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE: i32 = -61;
pub const GNUTLS_E_X509_UNKNOWN_SAN: i32 = -62;
pub const GNUTLS_E_OPENPGP_FINGERPRINT_UNSUPPORTED: i32 = -94;
pub const GNUTLS_E_X509_UNSUPPORTED_ATTRIBUTE: i32 = -95;
pub const GNUTLS_E_UNKNOWN_HASH_ALGORITHM: i32 = -96;
pub const GNUTLS_E_UNKNOWN_PKCS_CONTENT_TYPE: i32 = -97;
pub const GNUTLS_E_UNKNOWN_PKCS_BAG_TYPE: i32 = -98;
pub const GNUTLS_E_INVALID_PASSWORD: i32 = -99;
pub const GNUTLS_E_MAC_VERIFY_FAILED: i32 = -100;
pub const GNUTLS_E_CONSTRAINT_ERROR: i32 = -101;
pub const GNUTLS_E_WARNING_IA_IPHF_RECEIVED: i32 = -102;
pub const GNUTLS_E_WARNING_IA_FPHF_RECEIVED: i32 = -103;
pub const GNUTLS_E_IA_VERIFY_FAILED: i32 = -104;
pub const GNUTLS_E_UNKNOWN_ALGORITHM: i32 = -105;
pub const GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM: i32 = -106;
pub const GNUTLS_E_SAFE_RENEGOTIATION_FAILED: i32 = -107;
pub const GNUTLS_E_UNSAFE_RENEGOTIATION_DENIED: i32 = -108;
pub const GNUTLS_E_UNKNOWN_SRP_USERNAME: i32 = -109;
pub const GNUTLS_E_PREMATURE_TERMINATION: i32 = -110;
pub const GNUTLS_E_MALFORMED_CIDR: i32 = -111;
pub const GNUTLS_E_BASE64_ENCODING_ERROR: i32 = -201;
pub const GNUTLS_E_INCOMPATIBLE_GCRYPT_LIBRARY: i32 = -202;
pub const GNUTLS_E_INCOMPATIBLE_CRYPTO_LIBRARY: i32 = -202;
pub const GNUTLS_E_INCOMPATIBLE_LIBTASN1_LIBRARY: i32 = -203;
pub const GNUTLS_E_OPENPGP_KEYRING_ERROR: i32 = -204;
pub const GNUTLS_E_X509_UNSUPPORTED_OID: i32 = -205;
pub const GNUTLS_E_RANDOM_FAILED: i32 = -206;
pub const GNUTLS_E_BASE64_UNEXPECTED_HEADER_ERROR: i32 = -207;
pub const GNUTLS_E_OPENPGP_SUBKEY_ERROR: i32 = -208;
pub const GNUTLS_E_ALREADY_REGISTERED: i32 = -209;
pub const GNUTLS_E_HANDSHAKE_TOO_LARGE: i32 = -210;
pub const GNUTLS_E_CRYPTODEV_IOCTL_ERROR: i32 = -211;
pub const GNUTLS_E_CRYPTODEV_DEVICE_ERROR: i32 = -212;
pub const GNUTLS_E_CHANNEL_BINDING_NOT_AVAILABLE: i32 = -213;
pub const GNUTLS_E_BAD_COOKIE: i32 = -214;
pub const GNUTLS_E_OPENPGP_PREFERRED_KEY_ERROR: i32 = -215;
pub const GNUTLS_E_INCOMPAT_DSA_KEY_WITH_TLS_PROTOCOL: i32 = -216;
pub const GNUTLS_E_INSUFFICIENT_SECURITY: i32 = -217;
pub const GNUTLS_E_HEARTBEAT_PONG_RECEIVED: i32 = -292;
pub const GNUTLS_E_HEARTBEAT_PING_RECEIVED: i32 = -293;
pub const GNUTLS_E_UNRECOGNIZED_NAME: i32 = -294;
pub const GNUTLS_E_PKCS11_ERROR: i32 = -300;
pub const GNUTLS_E_PKCS11_LOAD_ERROR: i32 = -301;
pub const GNUTLS_E_PARSING_ERROR: i32 = -302;
pub const GNUTLS_E_PKCS11_PIN_ERROR: i32 = -303;
pub const GNUTLS_E_PKCS11_SLOT_ERROR: i32 = -305;
pub const GNUTLS_E_LOCKING_ERROR: i32 = -306;
pub const GNUTLS_E_PKCS11_ATTRIBUTE_ERROR: i32 = -307;
pub const GNUTLS_E_PKCS11_DEVICE_ERROR: i32 = -308;
pub const GNUTLS_E_PKCS11_DATA_ERROR: i32 = -309;
pub const GNUTLS_E_PKCS11_UNSUPPORTED_FEATURE_ERROR: i32 = -310;
pub const GNUTLS_E_PKCS11_KEY_ERROR: i32 = -311;
pub const GNUTLS_E_PKCS11_PIN_EXPIRED: i32 = -312;
pub const GNUTLS_E_PKCS11_PIN_LOCKED: i32 = -313;
pub const GNUTLS_E_PKCS11_SESSION_ERROR: i32 = -314;
pub const GNUTLS_E_PKCS11_SIGNATURE_ERROR: i32 = -315;
pub const GNUTLS_E_PKCS11_TOKEN_ERROR: i32 = -316;
pub const GNUTLS_E_PKCS11_USER_ERROR: i32 = -317;
pub const GNUTLS_E_CRYPTO_INIT_FAILED: i32 = -318;
pub const GNUTLS_E_TIMEDOUT: i32 = -319;
pub const GNUTLS_E_USER_ERROR: i32 = -320;
pub const GNUTLS_E_ECC_NO_SUPPORTED_CURVES: i32 = -321;
pub const GNUTLS_E_ECC_UNSUPPORTED_CURVE: i32 = -322;
pub const GNUTLS_E_PKCS11_REQUESTED_OBJECT_NOT_AVAILBLE: i32 = -323;
pub const GNUTLS_E_CERTIFICATE_LIST_UNSORTED: i32 = -324;
pub const GNUTLS_E_ILLEGAL_PARAMETER: i32 = -325;
pub const GNUTLS_E_NO_PRIORITIES_WERE_SET: i32 = -326;
pub const GNUTLS_E_X509_UNSUPPORTED_EXTENSION: i32 = -327;
pub const GNUTLS_E_SESSION_EOF: i32 = -328;
pub const GNUTLS_E_TPM_ERROR: i32 = -329;
pub const GNUTLS_E_TPM_KEY_PASSWORD_ERROR: i32 = -330;
pub const GNUTLS_E_TPM_SRK_PASSWORD_ERROR: i32 = -331;
pub const GNUTLS_E_TPM_SESSION_ERROR: i32 = -332;
pub const GNUTLS_E_TPM_KEY_NOT_FOUND: i32 = -333;
pub const GNUTLS_E_TPM_UNINITIALIZED: i32 = -334;
pub const GNUTLS_E_TPM_NO_LIB: i32 = -335;
pub const GNUTLS_E_NO_CERTIFICATE_STATUS: i32 = -340;
pub const GNUTLS_E_OCSP_RESPONSE_ERROR: i32 = -341;
pub const GNUTLS_E_RANDOM_DEVICE_ERROR: i32 = -342;
pub const GNUTLS_E_AUTH_ERROR: i32 = -343;
pub const GNUTLS_E_NO_APPLICATION_PROTOCOL: i32 = -344;
pub const GNUTLS_E_SOCKETS_INIT_ERROR: i32 = -345;
pub const GNUTLS_E_KEY_IMPORT_FAILED: i32 = -346;
pub const GNUTLS_E_INAPPROPRIATE_FALLBACK: i32 = -347;
pub const GNUTLS_E_CERTIFICATE_VERIFICATION_ERROR: i32 = -348;
pub const GNUTLS_E_PRIVKEY_VERIFICATION_ERROR: i32 = -349;
pub const GNUTLS_E_UNEXPECTED_EXTENSIONS_LENGTH: i32 = -350;
pub const GNUTLS_E_ASN1_EMBEDDED_NULL_IN_STRING: i32 = -351;
pub const GNUTLS_E_SELF_TEST_ERROR: i32 = -400;
pub const GNUTLS_E_NO_SELF_TEST: i32 = -401;
pub const GNUTLS_E_LIB_IN_ERROR_STATE: i32 = -402;
pub const GNUTLS_E_PK_GENERATION_ERROR: i32 = -403;
pub const GNUTLS_E_IDNA_ERROR: i32 = -404;
pub const GNUTLS_E_NEED_FALLBACK: i32 = -405;
pub const GNUTLS_E_SESSION_USER_ID_CHANGED: i32 = -406;
pub const GNUTLS_E_HANDSHAKE_DURING_FALSE_START: i32 = -407;
pub const GNUTLS_E_UNAVAILABLE_DURING_HANDSHAKE: i32 = -408;
pub const GNUTLS_E_PK_INVALID_PUBKEY: i32 = -409;
pub const GNUTLS_E_PK_INVALID_PRIVKEY: i32 = -410;
pub const GNUTLS_E_NOT_YET_ACTIVATED: i32 = -411;
pub const GNUTLS_E_INVALID_UTF8_STRING: i32 = -412;
pub const GNUTLS_E_NO_EMBEDDED_DATA: i32 = -413;
pub const GNUTLS_E_INVALID_UTF8_EMAIL: i32 = -414;
pub const GNUTLS_E_INVALID_PASSWORD_STRING: i32 = -415;
pub const GNUTLS_E_CERTIFICATE_TIME_ERROR: i32 = -416;
pub const GNUTLS_E_RECORD_OVERFLOW: i32 = -417;
pub const GNUTLS_E_ASN1_TIME_ERROR: i32 = -418;
pub const GNUTLS_E_INCOMPATIBLE_SIG_WITH_KEY: i32 = -419;
pub const GNUTLS_E_PK_INVALID_PUBKEY_PARAMS: i32 = -420;
pub const GNUTLS_E_PK_NO_VALIDATION_PARAMS: i32 = -421;
pub const GNUTLS_E_OCSP_MISMATCH_WITH_CERTS: i32 = -422;
pub const GNUTLS_E_NO_COMMON_KEY_SHARE: i32 = -423;
pub const GNUTLS_E_REAUTH_REQUEST: i32 = -424;
pub const GNUTLS_E_TOO_MANY_MATCHES: i32 = -425;
pub const GNUTLS_E_CRL_VERIFICATION_ERROR: i32 = -426;
pub const GNUTLS_E_MISSING_EXTENSION: i32 = -427;
pub const GNUTLS_E_DB_ENTRY_EXISTS: i32 = -428;
pub const GNUTLS_E_EARLY_DATA_REJECTED: i32 = -429;
pub const GNUTLS_E_X509_DUPLICATE_EXTENSION: i32 = -430;
pub const GNUTLS_E_UNIMPLEMENTED_FEATURE: i32 = -1250;
pub const GNUTLS_E_INT_RET_0: i32 = -1251;
pub const GNUTLS_E_INT_CHECK_AGAIN: i32 = -1252;
pub const GNUTLS_E_APPLICATION_ERROR_MAX: i32 = -65000;
pub const GNUTLS_E_APPLICATION_ERROR_MIN: i32 = -65500;
pub const GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT: u32 = 0;
pub const LIBGNUTLS_VERSION: &'static [u8; 6usize] = b"3.7.1\0";
pub const LIBGNUTLS_VERSION_MAJOR: u32 = 3;
pub const LIBGNUTLS_VERSION_MINOR: u32 = 7;
pub const LIBGNUTLS_VERSION_PATCH: u32 = 1;
pub const LIBGNUTLS_VERSION_NUMBER: u32 = 198401;
pub const LIBGNUTLS_EXTRA_VERSION: &'static [u8; 6usize] = b"3.7.1\0";
pub const GNUTLS_SUPPLEMENTAL_USER_MAPPING_DATA: u32 = 0;
pub const GNUTLS_OID_X520_COUNTRY_NAME: &'static [u8; 8usize] = b"2.5.4.6\0";
pub const GNUTLS_OID_X520_ORGANIZATION_NAME: &'static [u8; 9usize] = b"2.5.4.10\0";
pub const GNUTLS_OID_X520_ORGANIZATIONAL_UNIT_NAME: &'static [u8; 9usize] = b"2.5.4.11\0";
pub const GNUTLS_OID_X520_COMMON_NAME: &'static [u8; 8usize] = b"2.5.4.3\0";
pub const GNUTLS_OID_X520_LOCALITY_NAME: &'static [u8; 8usize] = b"2.5.4.7\0";
pub const GNUTLS_OID_X520_STATE_OR_PROVINCE_NAME: &'static [u8; 8usize] = b"2.5.4.8\0";
pub const GNUTLS_OID_X520_INITIALS: &'static [u8; 9usize] = b"2.5.4.43\0";
pub const GNUTLS_OID_X520_GENERATION_QUALIFIER: &'static [u8; 9usize] = b"2.5.4.44\0";
pub const GNUTLS_OID_X520_SURNAME: &'static [u8; 8usize] = b"2.5.4.4\0";
pub const GNUTLS_OID_X520_GIVEN_NAME: &'static [u8; 9usize] = b"2.5.4.42\0";
pub const GNUTLS_OID_X520_TITLE: &'static [u8; 9usize] = b"2.5.4.12\0";
pub const GNUTLS_OID_X520_DN_QUALIFIER: &'static [u8; 9usize] = b"2.5.4.46\0";
pub const GNUTLS_OID_X520_PSEUDONYM: &'static [u8; 9usize] = b"2.5.4.65\0";
pub const GNUTLS_OID_X520_POSTALCODE: &'static [u8; 9usize] = b"2.5.4.17\0";
pub const GNUTLS_OID_X520_NAME: &'static [u8; 9usize] = b"2.5.4.41\0";
pub const GNUTLS_OID_LDAP_DC: &'static [u8; 27usize] = b"0.9.2342.19200300.100.1.25\0";
pub const GNUTLS_OID_LDAP_UID: &'static [u8; 26usize] = b"0.9.2342.19200300.100.1.1\0";
pub const GNUTLS_OID_PKCS9_EMAIL: &'static [u8; 21usize] = b"1.2.840.113549.1.9.1\0";
pub const GNUTLS_OID_PKIX_DATE_OF_BIRTH: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.9.1\0";
pub const GNUTLS_OID_PKIX_PLACE_OF_BIRTH: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.9.2\0";
pub const GNUTLS_OID_PKIX_GENDER: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.9.3\0";
pub const GNUTLS_OID_PKIX_COUNTRY_OF_CITIZENSHIP: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.9.4\0";
pub const GNUTLS_OID_PKIX_COUNTRY_OF_RESIDENCE: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.9.5\0";
pub const GNUTLS_KP_TLS_WWW_SERVER: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.3.1\0";
pub const GNUTLS_KP_TLS_WWW_CLIENT: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.3.2\0";
pub const GNUTLS_KP_CODE_SIGNING: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.3.3\0";
pub const GNUTLS_KP_MS_SMART_CARD_LOGON: &'static [u8; 23usize] = b"1.3.6.1.4.1.311.20.2.2\0";
pub const GNUTLS_KP_EMAIL_PROTECTION: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.3.4\0";
pub const GNUTLS_KP_TIME_STAMPING: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.3.8\0";
pub const GNUTLS_KP_OCSP_SIGNING: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.3.9\0";
pub const GNUTLS_KP_IPSEC_IKE: &'static [u8; 19usize] = b"1.3.6.1.5.5.7.3.17\0";
pub const GNUTLS_KP_ANY: &'static [u8; 12usize] = b"2.5.29.37.0\0";
pub const GNUTLS_KP_FLAG_DISALLOW_ANY: u32 = 1;
pub const GNUTLS_OID_AIA: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.1.1\0";
pub const GNUTLS_OID_AD_OCSP: &'static [u8; 19usize] = b"1.3.6.1.5.5.7.48.1\0";
pub const GNUTLS_OID_AD_CAISSUERS: &'static [u8; 19usize] = b"1.3.6.1.5.5.7.48.2\0";
pub const GNUTLS_FSAN_SET: u32 = 0;
pub const GNUTLS_FSAN_APPEND: u32 = 1;
pub const GNUTLS_FSAN_ENCODE_OCTET_STRING: u32 = 2;
pub const GNUTLS_FSAN_ENCODE_UTF8_STRING: u32 = 4;
pub const GNUTLS_X509EXT_OID_SUBJECT_KEY_ID: &'static [u8; 10usize] = b"2.5.29.14\0";
pub const GNUTLS_X509EXT_OID_KEY_USAGE: &'static [u8; 10usize] = b"2.5.29.15\0";
pub const GNUTLS_X509EXT_OID_PRIVATE_KEY_USAGE_PERIOD: &'static [u8; 10usize] = b"2.5.29.16\0";
pub const GNUTLS_X509EXT_OID_SAN: &'static [u8; 10usize] = b"2.5.29.17\0";
pub const GNUTLS_X509EXT_OID_IAN: &'static [u8; 10usize] = b"2.5.29.18\0";
pub const GNUTLS_X509EXT_OID_BASIC_CONSTRAINTS: &'static [u8; 10usize] = b"2.5.29.19\0";
pub const GNUTLS_X509EXT_OID_NAME_CONSTRAINTS: &'static [u8; 10usize] = b"2.5.29.30\0";
pub const GNUTLS_X509EXT_OID_CRL_DIST_POINTS: &'static [u8; 10usize] = b"2.5.29.31\0";
pub const GNUTLS_X509EXT_OID_CRT_POLICY: &'static [u8; 10usize] = b"2.5.29.32\0";
pub const GNUTLS_X509EXT_OID_AUTHORITY_KEY_ID: &'static [u8; 10usize] = b"2.5.29.35\0";
pub const GNUTLS_X509EXT_OID_EXTENDED_KEY_USAGE: &'static [u8; 10usize] = b"2.5.29.37\0";
pub const GNUTLS_X509EXT_OID_INHIBIT_ANYPOLICY: &'static [u8; 10usize] = b"2.5.29.52\0";
pub const GNUTLS_X509EXT_OID_AUTHORITY_INFO_ACCESS: &'static [u8; 18usize] = b"1.3.6.1.5.5.7.1.1\0";
pub const GNUTLS_X509EXT_OID_PROXY_CRT_INFO: &'static [u8; 19usize] = b"1.3.6.1.5.5.7.1.14\0";
pub const GNUTLS_X509EXT_OID_TLSFEATURES: &'static [u8; 19usize] = b"1.3.6.1.5.5.7.1.24\0";
pub const GNUTLS_X509_OID_POLICY_ANY: &'static [u8; 10usize] = b"2.5.29.54\0";
pub const GNUTLS_EXT_FLAG_APPEND: u32 = 1;
pub const GNUTLS_NAME_CONSTRAINTS_FLAG_APPEND: u32 = 1;
pub const GNUTLS_MAX_QUALIFIERS: u32 = 8;
pub const GNUTLS_X509_DN_OID_RETURN_OID: u32 = 1;
pub const GNUTLS_X509_DN_FLAG_COMPAT: u32 = 1;
pub const GNUTLS_VFLAGS_PROFILE_MASK: u32 = 4278190080;
pub const GNUTLS_TL_VERIFY_CRL: u32 = 1;
pub const GNUTLS_TL_USE_IN_TLS: u32 = 2;
pub const GNUTLS_TL_NO_DUPLICATES: u32 = 4;
pub const GNUTLS_TL_NO_DUPLICATE_KEY: u32 = 8;
pub const GNUTLS_TL_GET_COPY: u32 = 16;
pub const GNUTLS_TL_FAIL_ON_INVALID_CRL: u32 = 32;
pub const GNUTLS_PKCS7_EDATA_GET_RAW: u32 = 16777216;
pub const GNUTLS_PKCS7_ATTR_ENCODE_OCTET_STRING: u32 = 1;
pub const GNUTLS_EMACS_HANDSHAKES_LIMIT: u32 = 6000;
pub const GNUTLS_EMACS_ERROR_NOT_LOADED: i32 = -65499;
pub const GNUTLS_EMACS_ERROR_INVALID_TYPE: i32 = -65500;
pub const ITEM_PROPERTY_ITEM: u32 = 0;
pub const ITEM_PROPERTY_NAME: u32 = 1;
pub const ITEM_PROPERTY_DEF: u32 = 2;
pub const ITEM_PROPERTY_MAP: u32 = 3;
pub const ITEM_PROPERTY_TYPE: u32 = 4;
pub const ITEM_PROPERTY_KEYEQ: u32 = 5;
pub const ITEM_PROPERTY_SELECTED: u32 = 6;
pub const ITEM_PROPERTY_HELP: u32 = 7;
pub const ITEM_PROPERTY_ENABLE: u32 = 8;
pub const MENU_ITEMS_PANE_NAME: u32 = 1;
pub const MENU_ITEMS_PANE_PREFIX: u32 = 2;
pub const MENU_ITEMS_PANE_LENGTH: u32 = 3;
pub const _FCNTL_H: u32 = 1;
pub const __O_LARGEFILE: u32 = 0;
pub const F_GETLK64: u32 = 5;
pub const F_SETLK64: u32 = 6;
pub const F_SETLKW64: u32 = 7;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_NDELAY: u32 = 2048;
pub const O_SYNC: u32 = 1052672;
pub const O_FSYNC: u32 = 1052672;
pub const O_ASYNC: u32 = 8192;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_DIRECT: u32 = 16384;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_DSYNC: u32 = 4096;
pub const __O_TMPFILE: u32 = 4259840;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_OFD_GETLK: u32 = 36;
pub const F_OFD_SETLK: u32 = 37;
pub const F_OFD_SETLKW: u32 = 38;
pub const O_LARGEFILE: u32 = 0;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DIRECT: u32 = 16384;
pub const O_NOATIME: u32 = 262144;
pub const O_PATH: u32 = 2097152;
pub const O_TMPFILE: u32 = 4259840;
pub const O_DSYNC: u32 = 4096;
pub const O_RSYNC: u32 = 1052672;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const __F_SETOWN: u32 = 8;
pub const __F_GETOWN: u32 = 9;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_SETSIG: u32 = 10;
pub const F_GETSIG: u32 = 11;
pub const F_SETOWN_EX: u32 = 15;
pub const F_GETOWN_EX: u32 = 16;
pub const F_SETLEASE: u32 = 1024;
pub const F_GETLEASE: u32 = 1025;
pub const F_NOTIFY: u32 = 1026;
pub const F_SETPIPE_SZ: u32 = 1031;
pub const F_GETPIPE_SZ: u32 = 1032;
pub const F_ADD_SEALS: u32 = 1033;
pub const F_GET_SEALS: u32 = 1034;
pub const F_GET_RW_HINT: u32 = 1035;
pub const F_SET_RW_HINT: u32 = 1036;
pub const F_GET_FILE_RW_HINT: u32 = 1037;
pub const F_SET_FILE_RW_HINT: u32 = 1038;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const LOCK_MAND: u32 = 32;
pub const LOCK_READ: u32 = 64;
pub const LOCK_WRITE: u32 = 128;
pub const LOCK_RW: u32 = 192;
pub const DN_ACCESS: u32 = 1;
pub const DN_MODIFY: u32 = 2;
pub const DN_CREATE: u32 = 4;
pub const DN_DELETE: u32 = 8;
pub const DN_RENAME: u32 = 16;
pub const DN_ATTRIB: u32 = 32;
pub const DN_MULTISHOT: u32 = 2147483648;
pub const F_SEAL_SEAL: u32 = 1;
pub const F_SEAL_SHRINK: u32 = 2;
pub const F_SEAL_GROW: u32 = 4;
pub const F_SEAL_WRITE: u32 = 8;
pub const F_SEAL_FUTURE_WRITE: u32 = 16;
pub const RWH_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWF_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWH_WRITE_LIFE_NONE: u32 = 1;
pub const RWH_WRITE_LIFE_SHORT: u32 = 2;
pub const RWH_WRITE_LIFE_MEDIUM: u32 = 3;
pub const RWH_WRITE_LIFE_LONG: u32 = 4;
pub const RWH_WRITE_LIFE_EXTREME: u32 = 5;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const SYNC_FILE_RANGE_WAIT_BEFORE: u32 = 1;
pub const SYNC_FILE_RANGE_WRITE: u32 = 2;
pub const SYNC_FILE_RANGE_WAIT_AFTER: u32 = 4;
pub const SYNC_FILE_RANGE_WRITE_AND_WAIT: u32 = 7;
pub const SPLICE_F_MOVE: u32 = 1;
pub const SPLICE_F_NONBLOCK: u32 = 2;
pub const SPLICE_F_MORE: u32 = 4;
pub const SPLICE_F_GIFT: u32 = 8;
pub const FALLOC_FL_KEEP_SIZE: u32 = 1;
pub const FALLOC_FL_PUNCH_HOLE: u32 = 2;
pub const FALLOC_FL_NO_HIDE_STALE: u32 = 4;
pub const FALLOC_FL_COLLAPSE_RANGE: u32 = 8;
pub const FALLOC_FL_ZERO_RANGE: u32 = 16;
pub const FALLOC_FL_INSERT_RANGE: u32 = 32;
pub const FALLOC_FL_UNSHARE_RANGE: u32 = 64;
pub const MAX_HANDLE_SZ: u32 = 128;
pub const _BITS_STAT_H: u32 = 1;
pub const _BITS_STRUCT_STAT_H: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_NO_AUTOMOUNT: u32 = 2048;
pub const AT_EMPTY_PATH: u32 = 4096;
pub const AT_STATX_SYNC_TYPE: u32 = 24576;
pub const AT_STATX_SYNC_AS_STAT: u32 = 0;
pub const AT_STATX_FORCE_SYNC: u32 = 8192;
pub const AT_STATX_DONT_SYNC: u32 = 16384;
pub const AT_RECURSIVE: u32 = 32768;
pub const AT_EACCESS: u32 = 512;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const GNULIB_defined_rpl_fcntl: u32 = 1;
pub const GNULIB_defined_F_DUPFD_CLOEXEC: u32 = 0;
pub const GNULIB_defined_O_CLOEXEC: u32 = 0;
pub const O_EXEC: u32 = 0;
pub const O_IGNORE_CTTY: u32 = 0;
pub const O_NOLINK: u32 = 0;
pub const O_NOLINKS: u32 = 0;
pub const O_NOTRANS: u32 = 0;
pub const O_SEARCH: u32 = 0;
pub const O_TTY_INIT: u32 = 0;
pub const O_BINARY: u32 = 0;
pub const O_TEXT: u32 = 0;
pub const UNLOCKED_IO_H: u32 = 1;
pub const FOPEN_BINARY: &'static [u8; 1usize] = b"\0";
pub const FOPEN_TEXT: &'static [u8; 1usize] = b"\0";
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &'static [u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const SYSTEM_PURESIZE_EXTRA: u32 = 0;
pub const SITELOAD_PURESIZE_EXTRA: u32 = 0;
pub const BASE_PURESIZE: u32 = 2000000;
pub const PURESIZE_RATIO: u32 = 1;
pub const PURESIZE_CHECKING_RATIO: u32 = 1;
pub const PURESIZE: u32 = 2000000;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_ARCH_H: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 65;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const _TERMIOS_H: u32 = 1;
pub const NCCS: u32 = 32;
pub const _HAVE_STRUCT_TERMIOS_C_ISPEED: u32 = 1;
pub const _HAVE_STRUCT_TERMIOS_C_OSPEED: u32 = 1;
pub const VINTR: u32 = 0;
pub const VQUIT: u32 = 1;
pub const VERASE: u32 = 2;
pub const VKILL: u32 = 3;
pub const VEOF: u32 = 4;
pub const VTIME: u32 = 5;
pub const VMIN: u32 = 6;
pub const VSWTC: u32 = 7;
pub const VSTART: u32 = 8;
pub const VSTOP: u32 = 9;
pub const VSUSP: u32 = 10;
pub const VEOL: u32 = 11;
pub const VREPRINT: u32 = 12;
pub const VDISCARD: u32 = 13;
pub const VWERASE: u32 = 14;
pub const VLNEXT: u32 = 15;
pub const VEOL2: u32 = 16;
pub const IGNBRK: u32 = 1;
pub const BRKINT: u32 = 2;
pub const IGNPAR: u32 = 4;
pub const PARMRK: u32 = 8;
pub const INPCK: u32 = 16;
pub const ISTRIP: u32 = 32;
pub const INLCR: u32 = 64;
pub const IGNCR: u32 = 128;
pub const ICRNL: u32 = 256;
pub const IUCLC: u32 = 512;
pub const IXON: u32 = 1024;
pub const IXANY: u32 = 2048;
pub const IXOFF: u32 = 4096;
pub const IMAXBEL: u32 = 8192;
pub const IUTF8: u32 = 16384;
pub const OPOST: u32 = 1;
pub const OLCUC: u32 = 2;
pub const ONLCR: u32 = 4;
pub const OCRNL: u32 = 8;
pub const ONOCR: u32 = 16;
pub const ONLRET: u32 = 32;
pub const OFILL: u32 = 64;
pub const OFDEL: u32 = 128;
pub const NLDLY: u32 = 256;
pub const NL0: u32 = 0;
pub const NL1: u32 = 256;
pub const CRDLY: u32 = 1536;
pub const CR0: u32 = 0;
pub const CR1: u32 = 512;
pub const CR2: u32 = 1024;
pub const CR3: u32 = 1536;
pub const TABDLY: u32 = 6144;
pub const TAB0: u32 = 0;
pub const TAB1: u32 = 2048;
pub const TAB2: u32 = 4096;
pub const TAB3: u32 = 6144;
pub const BSDLY: u32 = 8192;
pub const BS0: u32 = 0;
pub const BS1: u32 = 8192;
pub const FFDLY: u32 = 32768;
pub const FF0: u32 = 0;
pub const FF1: u32 = 32768;
pub const VTDLY: u32 = 16384;
pub const VT0: u32 = 0;
pub const VT1: u32 = 16384;
pub const XTABS: u32 = 6144;
pub const B0: u32 = 0;
pub const B50: u32 = 1;
pub const B75: u32 = 2;
pub const B110: u32 = 3;
pub const B134: u32 = 4;
pub const B150: u32 = 5;
pub const B200: u32 = 6;
pub const B300: u32 = 7;
pub const B600: u32 = 8;
pub const B1200: u32 = 9;
pub const B1800: u32 = 10;
pub const B2400: u32 = 11;
pub const B4800: u32 = 12;
pub const B9600: u32 = 13;
pub const B19200: u32 = 14;
pub const B38400: u32 = 15;
pub const EXTA: u32 = 14;
pub const EXTB: u32 = 15;
pub const CBAUD: u32 = 4111;
pub const CBAUDEX: u32 = 4096;
pub const CIBAUD: u32 = 269418496;
pub const CMSPAR: u32 = 1073741824;
pub const CRTSCTS: u32 = 2147483648;
pub const B57600: u32 = 4097;
pub const B115200: u32 = 4098;
pub const B230400: u32 = 4099;
pub const B460800: u32 = 4100;
pub const B500000: u32 = 4101;
pub const B576000: u32 = 4102;
pub const B921600: u32 = 4103;
pub const B1000000: u32 = 4104;
pub const B1152000: u32 = 4105;
pub const B1500000: u32 = 4106;
pub const B2000000: u32 = 4107;
pub const B2500000: u32 = 4108;
pub const B3000000: u32 = 4109;
pub const B3500000: u32 = 4110;
pub const B4000000: u32 = 4111;
pub const __MAX_BAUD: u32 = 4111;
pub const CSIZE: u32 = 48;
pub const CS5: u32 = 0;
pub const CS6: u32 = 16;
pub const CS7: u32 = 32;
pub const CS8: u32 = 48;
pub const CSTOPB: u32 = 64;
pub const CREAD: u32 = 128;
pub const PARENB: u32 = 256;
pub const PARODD: u32 = 512;
pub const HUPCL: u32 = 1024;
pub const CLOCAL: u32 = 2048;
pub const ISIG: u32 = 1;
pub const ICANON: u32 = 2;
pub const XCASE: u32 = 4;
pub const ECHO: u32 = 8;
pub const ECHOE: u32 = 16;
pub const ECHOK: u32 = 32;
pub const ECHONL: u32 = 64;
pub const NOFLSH: u32 = 128;
pub const TOSTOP: u32 = 256;
pub const ECHOCTL: u32 = 512;
pub const ECHOPRT: u32 = 1024;
pub const ECHOKE: u32 = 2048;
pub const FLUSHO: u32 = 4096;
pub const PENDIN: u32 = 16384;
pub const IEXTEN: u32 = 32768;
pub const EXTPROC: u32 = 65536;
pub const TCOOFF: u32 = 0;
pub const TCOON: u32 = 1;
pub const TCIOFF: u32 = 2;
pub const TCION: u32 = 3;
pub const TCIFLUSH: u32 = 0;
pub const TCOFLUSH: u32 = 1;
pub const TCIOFLUSH: u32 = 2;
pub const TCSANOW: u32 = 0;
pub const TCSADRAIN: u32 = 1;
pub const TCSAFLUSH: u32 = 2;
pub const CDISABLE: u8 = 0u8;
pub const _SYS_WAIT_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const WCOREFLAG: u32 = 128;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub type bool_bf = bool;
extern "C" {
    pub fn emacs_getenv_TZ() -> *mut ::libc::c_char;
}
extern "C" {
    pub fn emacs_setenv_TZ(arg1: *const ::libc::c_char) -> ::libc::c_int;
}
pub type __jmp_buf = [::libc::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::libc::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__jmpbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__mask_was_saved as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__saved_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn setjmp(__env: *mut __jmp_buf_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn _setjmp(__env: *mut __jmp_buf_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn longjmp(__env: *mut __jmp_buf_tag, __val: ::libc::c_int);
}
extern "C" {
    pub fn _longjmp(__env: *mut __jmp_buf_tag, __val: ::libc::c_int);
}
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn siglongjmp(__env: *mut __jmp_buf_tag, __val: ::libc::c_int);
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::libc::c_void,
        __src: *const ::libc::c_void,
        __n: usize,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::libc::c_void,
        __src: *const ::libc::c_void,
        __n: usize,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::libc::c_void,
        __src: *const ::libc::c_void,
        __c: ::libc::c_int,
        __n: usize,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::libc::c_void, __c: ::libc::c_int, __n: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::libc::c_void,
        __s2: *const ::libc::c_void,
        __n: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::libc::c_void,
        __c: ::libc::c_int,
        __n: usize,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn rawmemchr(__s: *const ::libc::c_void, __c: ::libc::c_int) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memrchr(
        __s: *const ::libc::c_void,
        __c: ::libc::c_int,
        __n: usize,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::libc::c_char, __src: *const ::libc::c_char)
        -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::libc::c_char, __src: *const ::libc::c_char)
        -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __n: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: usize,
    ) -> ::libc::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::libc::c_ushort,
    pub __ctype_tolower: *const ::libc::c_int,
    pub __ctype_toupper: *const ::libc::c_int,
    pub __names: [*const ::libc::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __l: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::libc::c_char, __n: usize) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strchrnul(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::libc::c_char, __reject: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::libc::c_char, __accept: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::libc::c_char,
        __accept: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::libc::c_char,
        __needle: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::libc::c_char, __delim: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::libc::c_char,
        __delim: *const ::libc::c_char,
        __save_ptr: *mut *mut ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::libc::c_char,
        __delim: *const ::libc::c_char,
        __save_ptr: *mut *mut ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::libc::c_char,
        __needle: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::libc::c_void,
        __haystacklen: usize,
        __needle: *const ::libc::c_void,
        __needlelen: usize,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::libc::c_void,
        __src: *const ::libc::c_void,
        __n: usize,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::libc::c_void,
        __src: *const ::libc::c_void,
        __n: usize,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::libc::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::libc::c_int,
        __buf: *mut ::libc::c_char,
        __buflen: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strerrordesc_np(__err: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn strerrorname_np(__err: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn strerror_l(__errnum: ::libc::c_int, __l: locale_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::libc::c_void,
        __s2: *const ::libc::c_void,
        __n: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const ::libc::c_void, __dest: *mut ::libc::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::libc::c_void, __n: usize);
}
extern "C" {
    pub fn index(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ffs(__i: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::libc::c_longlong) -> ::libc::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __n: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __loc: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::libc::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::libc::c_char,
        __delim: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn sigabbrev_np(__sig: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn sigdescr_np(__sig: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::libc::c_char, __src: *const ::libc::c_char)
        -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strverscmp(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strfry(__string: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn memfrob(__s: *mut ::libc::c_void, __n: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn basename(__filename: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}_gl_cxxalias_dummy"]
    pub static mut _gl_cxxalias_dummy: ::libc::c_int;
}
pub type __u_char = ::libc::c_uchar;
pub type __u_short = ::libc::c_ushort;
pub type __u_int = ::libc::c_uint;
pub type __u_long = ::libc::c_ulong;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_long;
pub type __uint64_t = ::libc::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::libc::c_long;
pub type __u_quad_t = ::libc::c_ulong;
pub type __intmax_t = ::libc::c_long;
pub type __uintmax_t = ::libc::c_ulong;
pub type __dev_t = ::libc::c_ulong;
pub type __uid_t = ::libc::c_uint;
pub type __gid_t = ::libc::c_uint;
pub type __ino_t = ::libc::c_ulong;
pub type __ino64_t = ::libc::c_ulong;
pub type __mode_t = ::libc::c_uint;
pub type __nlink_t = ::libc::c_ulong;
pub type __off_t = ::libc::c_long;
pub type __off64_t = ::libc::c_long;
pub type __pid_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::libc::c_long;
pub type __rlim_t = ::libc::c_ulong;
pub type __rlim64_t = ::libc::c_ulong;
pub type __id_t = ::libc::c_uint;
pub type __time_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_uint;
pub type __suseconds_t = ::libc::c_long;
pub type __suseconds64_t = ::libc::c_long;
pub type __daddr_t = ::libc::c_int;
pub type __key_t = ::libc::c_int;
pub type __clockid_t = ::libc::c_int;
pub type __timer_t = *mut ::libc::c_void;
pub type __blksize_t = ::libc::c_long;
pub type __blkcnt_t = ::libc::c_long;
pub type __blkcnt64_t = ::libc::c_long;
pub type __fsblkcnt_t = ::libc::c_ulong;
pub type __fsblkcnt64_t = ::libc::c_ulong;
pub type __fsfilcnt_t = ::libc::c_ulong;
pub type __fsfilcnt64_t = ::libc::c_ulong;
pub type __fsword_t = ::libc::c_long;
pub type __ssize_t = ::libc::c_long;
pub type __syscall_slong_t = ::libc::c_long;
pub type __syscall_ulong_t = ::libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::libc::c_char;
pub type __intptr_t = ::libc::c_long;
pub type __socklen_t = ::libc::c_uint;
pub type __sig_atomic_t = ::libc::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_schar;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::libc::c_long,
    pub rem: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::libc::c_char,
        __endptr: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::libc::c_char,
        __endptr: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::libc::c_int,
    ) -> uintmax_t;
}
pub type EMACS_INT = ::libc::c_long;
pub type EMACS_UINT = ::libc::c_ulong;
pub const EMACS_INT_WIDTH: _bindgen_ty_1 = 64;
pub const EMACS_UINT_WIDTH: _bindgen_ty_1 = 64;
pub type _bindgen_ty_1 = u32;
pub const BOOL_VECTOR_BITS_PER_CHAR: _bindgen_ty_2 = 8;
pub type _bindgen_ty_2 = u32;
pub type bits_word = usize;
pub const BITS_PER_BITS_WORD: _bindgen_ty_3 = 64;
pub type _bindgen_ty_3 = u32;
pub mod Lisp_Bits {
    #[doc = " Select the tagging scheme."]
    pub type Type = u32;
    pub const VALBITS: Type = 61;
    pub const FIXNUM_BITS: Type = 62;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Lisp_X {
    _unused: [u8; 0],
}
pub type Lisp_Word = *mut Lisp_X;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Lisp_Type {
    Lisp_Symbol = 0,
    Lisp_Type_Unused0 = 1,
    Lisp_Int0 = 2,
    Lisp_Int1 = 6,
    Lisp_String = 4,
    Lisp_Vectorlike = 5,
    Lisp_Cons = 3,
    Lisp_Float = 7,
}
pub mod Lisp_Fwd_Type {
    pub type Type = u32;
    pub const Lisp_Fwd_Int: Type = 0;
    pub const Lisp_Fwd_Bool: Type = 1;
    pub const Lisp_Fwd_Obj: Type = 2;
    pub const Lisp_Fwd_Buffer_Obj: Type = 3;
    pub const Lisp_Fwd_Kboard_Obj: Type = 4;
}
pub mod CHECK_LISP_OBJECT_TYPE {
    pub type Type = u32;
    pub const CHECK_LISP_OBJECT_TYPE: Type = 0;
}
extern "C" {
    pub fn set_sub_char_table_contents(arg1: Lisp_Object, arg2: isize, arg3: Lisp_Object);
}
extern "C" {
    pub fn check_int_nonnegative(arg1: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    pub fn check_integer_range(arg1: Lisp_Object, arg2: intmax_t, arg3: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn bignum_to_double(arg1: Lisp_Object) -> f64;
}
extern "C" {
    pub fn make_bigint(arg1: intmax_t) -> Lisp_Object;
}
extern "C" {
    pub fn make_biguint(arg1: uintmax_t) -> Lisp_Object;
}
extern "C" {
    pub fn check_uinteger_max(arg1: Lisp_Object, arg2: uintmax_t) -> uintmax_t;
}
extern "C" {
    pub fn char_table_ref(arg1: Lisp_Object, arg2: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn char_table_set(arg1: Lisp_Object, arg2: ::libc::c_int, arg3: Lisp_Object);
}
extern "C" {
    pub fn args_out_of_range_3(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn default_value(symbol: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}initialized"]
    pub static mut initialized: bool;
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gflags {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_gflags() {
    assert_eq!(
        ::std::mem::size_of::<gflags>(),
        1usize,
        concat!("Size of: ", stringify!(gflags))
    );
    assert_eq!(
        ::std::mem::align_of::<gflags>(),
        1usize,
        concat!("Alignment of ", stringify!(gflags))
    );
}
impl gflags {
    #[inline]
    pub fn will_dump_(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_will_dump_(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn will_bootstrap_(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_will_bootstrap_(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn will_dump_with_pdumper_(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_will_dump_with_pdumper_(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dumped_with_pdumper_(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dumped_with_pdumper_(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        will_dump_: bool,
        will_bootstrap_: bool,
        will_dump_with_pdumper_: bool,
        dumped_with_pdumper_: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let will_dump_: u8 = unsafe { ::std::mem::transmute(will_dump_) };
            will_dump_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let will_bootstrap_: u8 = unsafe { ::std::mem::transmute(will_bootstrap_) };
            will_bootstrap_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let will_dump_with_pdumper_: u8 =
                unsafe { ::std::mem::transmute(will_dump_with_pdumper_) };
            will_dump_with_pdumper_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dumped_with_pdumper_: u8 = unsafe { ::std::mem::transmute(dumped_with_pdumper_) };
            dumped_with_pdumper_ as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}gflags"]
    pub static mut gflags: gflags;
}
extern "C" {
    pub fn will_dump_p() -> bool;
}
extern "C" {
    pub fn will_bootstrap_p() -> bool;
}
extern "C" {
    pub fn will_dump_with_pdumper_p() -> bool;
}
extern "C" {
    pub fn dumped_with_pdumper_p() -> bool;
}
extern "C" {
    pub fn will_dump_with_unexec_p() -> bool;
}
extern "C" {
    pub fn dumped_with_unexec_p() -> bool;
}
extern "C" {
    pub fn definitely_will_not_unexec_p() -> bool;
}
extern "C" {
    pub fn extract_float(arg1: Lisp_Object) -> f64;
}
extern "C" {
    pub fn XLI(o: Lisp_Object) -> EMACS_INT;
}
extern "C" {
    pub fn XIL(i: EMACS_INT) -> Lisp_Object;
}
extern "C" {
    pub fn XLP(o: Lisp_Object) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn XTYPE(a: Lisp_Object) -> Lisp_Type;
}
extern "C" {
    pub fn TAGGEDP(a: Lisp_Object, tag: Lisp_Type) -> bool;
}
extern "C" {
    pub fn CHECK_TYPE(ok: ::libc::c_int, predicate: Lisp_Object, x: Lisp_Object);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lispfwd {
    pub fwdptr: *const ::libc::c_void,
}
#[test]
fn bindgen_test_layout_lispfwd() {
    assert_eq!(
        ::std::mem::size_of::<lispfwd>(),
        8usize,
        concat!("Size of: ", stringify!(lispfwd))
    );
    assert_eq!(
        ::std::mem::align_of::<lispfwd>(),
        8usize,
        concat!("Alignment of ", stringify!(lispfwd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lispfwd>())).fwdptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lispfwd),
            "::",
            stringify!(fwdptr)
        )
    );
}
impl Default for lispfwd {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod symbol_interned {
    pub type Type = u32;
    pub const SYMBOL_UNINTERNED: Type = 0;
    pub const SYMBOL_INTERNED: Type = 1;
    pub const SYMBOL_INTERNED_IN_INITIAL_OBARRAY: Type = 2;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum symbol_redirect {
    SYMBOL_PLAINVAL = 4,
    SYMBOL_VARALIAS = 1,
    SYMBOL_LOCALIZED = 2,
    SYMBOL_FORWARDED = 3,
}
pub mod symbol_trapped_write {
    pub type Type = u32;
    pub const SYMBOL_UNTRAPPED_WRITE: Type = 0;
    pub const SYMBOL_NOWRITE: Type = 1;
    pub const SYMBOL_TRAPPED_WRITE: Type = 2;
}
#[repr(C)]
pub struct Lisp_Symbol {
    pub u: Lisp_Symbol__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
pub struct Lisp_Symbol__bindgen_ty_1 {
    pub s: __BindgenUnionField<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1>,
    pub gcaligned: __BindgenUnionField<::libc::c_char>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
pub struct Lisp_Symbol__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub name: Lisp_Object,
    pub val: Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub function: Lisp_Object,
    pub plist: Lisp_Object,
    pub next: *mut Lisp_Symbol,
}
#[repr(C)]
#[repr(align(8))]
pub union Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub value: Lisp_Object,
    pub alias: *mut Lisp_Symbol,
    pub blv: *mut Lisp_Buffer_Local_Value,
    pub fwd: lispfwd,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).value
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).alias
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).blv
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(blv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).fwd
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fwd)
        )
    );
}
impl Default for Lisp_Symbol__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_Lisp_Symbol__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1>())).name as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1>())).val as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1>())).function as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1>())).plist as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(plist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Symbol__bindgen_ty_1__bindgen_ty_1>())).next as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Symbol__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
}
impl Default for Lisp_Symbol__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl Lisp_Symbol__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn gcmarkbit(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gcmarkbit(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirect(&self) -> symbol_redirect {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_redirect(&mut self, val: symbol_redirect) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn trapped_write(&self) -> symbol_trapped_write::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_trapped_write(&mut self, val: symbol_trapped_write::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn interned(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_interned(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn declared_special(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_declared_special(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pinned(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pinned(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        gcmarkbit: bool_bf,
        redirect: symbol_redirect,
        trapped_write: symbol_trapped_write::Type,
        interned: ::libc::c_uint,
        declared_special: bool_bf,
        pinned: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gcmarkbit: u8 = unsafe { ::std::mem::transmute(gcmarkbit) };
            gcmarkbit as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let redirect: u32 = unsafe { ::std::mem::transmute(redirect) };
            redirect as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let trapped_write: u32 = unsafe { ::std::mem::transmute(trapped_write) };
            trapped_write as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let interned: u32 = unsafe { ::std::mem::transmute(interned) };
            interned as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let declared_special: u8 = unsafe { ::std::mem::transmute(declared_special) };
            declared_special as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let pinned: u8 = unsafe { ::std::mem::transmute(pinned) };
            pinned as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_Lisp_Symbol__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Symbol__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(Lisp_Symbol__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Symbol__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Symbol__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Symbol__bindgen_ty_1>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Symbol__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Symbol__bindgen_ty_1>())).gcaligned as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Symbol__bindgen_ty_1),
            "::",
            stringify!(gcaligned)
        )
    );
}
impl Default for Lisp_Symbol__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_Lisp_Symbol() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Symbol>(),
        48usize,
        concat!("Size of: ", stringify!(Lisp_Symbol))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Symbol>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Symbol))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Symbol>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Symbol),
            "::",
            stringify!(u)
        )
    );
}
impl Default for Lisp_Symbol {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type untagged_ptr = *mut ::libc::c_char;
pub type Lisp_Word_tag = usize;
extern "C" {
    #[link_name = "\u{1}globals"]
    pub static mut globals: emacs_globals;
}
extern "C" {
    #[link_name = "\u{1}lispsym"]
    pub static mut lispsym: [Lisp_Symbol; 1346usize];
}
extern "C" {
    pub fn Fabort_minibuffers() -> Lisp_Object;
}
extern "C" {
    pub fn Fabort_recursive_edit() -> Lisp_Object;
}
extern "C" {
    pub fn Fabs(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Faccept_process_output(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Faccess_file(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Faccessible_keymaps(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Facos(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Factive_minibuffer_window() -> Lisp_Object;
}
extern "C" {
    pub fn Fadd1(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fadd_face_text_property(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fadd_name_to_file(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fadd_text_properties(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fadd_variable_watcher(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fall_completions(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fall_threads() -> Lisp_Object;
}
extern "C" {
    pub fn Fand(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fappend(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fapply(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Faref(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Farrayp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Faset(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fash(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fasin(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fassoc(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fassoc_string(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fassq(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fasync_close_stream(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fasync_handler(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fasync_send_message(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fatan(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fatom(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fautoload(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fautoload_do_load(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fbacktrace__locals(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbacktrace_debug(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbacktrace_eval(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbacktrace_frame_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fbacktrace_frames_from_thread(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbackward_char(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbackward_prefix_chars() -> Lisp_Object;
}
extern "C" {
    pub fn Fbarf_if_buffer_read_only(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbase64_decode_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fbase64_decode_string(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbase64_encode_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fbase64_encode_string(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbase64url_encode_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fbase64url_encode_string(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbeginning_of_line(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbidi_find_overridden_directionality(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fbidi_resolved_levels(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbitmap_spec_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbobp() -> Lisp_Object;
}
extern "C" {
    pub fn Fbolp() -> Lisp_Object;
}
extern "C" {
    pub fn Fbool_vector(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbool_vector_count_consecutive(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fbool_vector_count_population(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbool_vector_exclusive_or(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fbool_vector_intersection(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fbool_vector_not(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbool_vector_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbool_vector_set_difference(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fbool_vector_subsetp(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbool_vector_union(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fbottom_divider_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fboundp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_base_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_chars_modified_tick(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_enable_undo(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_file_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_has_markers_at(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_hash(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_line_statistics(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_list(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_live_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_local_value(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_local_variables(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_modified_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_modified_tick(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_size(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_string() -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_substring(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_substring_no_properties(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbuffer_swap_text(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbufferp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbury_buffer_internal(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbyte_code(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbyte_code_function_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbyte_to_position(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbyte_to_string(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fbyteorder() -> Lisp_Object;
}
extern "C" {
    pub fn Fcall_interactively(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcall_last_kbd_macro(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcall_process(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcall_process_region(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcancel_kbd_macro_events() -> Lisp_Object;
}
extern "C" {
    pub fn Fcapitalize(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcapitalize_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcapitalize_word(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcar(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcar_less_than_car(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcar_safe(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcase_table_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcatch(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcategory_docstring(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcategory_set_mnemonics(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcategory_table() -> Lisp_Object;
}
extern "C" {
    pub fn Fcategory_table_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fccl_execute(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fccl_execute_on_string(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fccl_program_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcdr(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcdr_safe(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fceiling(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_after(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_before(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_category_set(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_charset(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_equal(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_or_string_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_resolve_modifiers(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_syntax(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_table_extra_slot(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_table_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_table_parent(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_table_range(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_table_subtype(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_to_string(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fchar_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcharacterp(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcharset_after(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcharset_id_internal(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcharset_plist(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcharset_priority_list(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcharsetp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcheck_coding_system(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcheck_coding_systems_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fclear_buffer_auto_save_failure() -> Lisp_Object;
}
extern "C" {
    pub fn Fclear_charset_maps() -> Lisp_Object;
}
extern "C" {
    pub fn Fclear_composition_cache() -> Lisp_Object;
}
extern "C" {
    pub fn Fclear_face_cache(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fclear_font_cache() -> Lisp_Object;
}
extern "C" {
    pub fn Fclear_image_cache(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fclear_string(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fclear_this_command_keys(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fclose_font(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fclrhash(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcoding_system_aliases(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcoding_system_base(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcoding_system_eol_type(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcoding_system_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcoding_system_plist(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcoding_system_priority_list(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcoding_system_put(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcolor_distance(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcolor_gray_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcolor_supported_p(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcolor_values_from_color_spec(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcombine_after_change_execute() -> Lisp_Object;
}
extern "C" {
    pub fn Fcommand_error_default_function(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcommand_modes(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcommand_remapping(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcommandp(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcomp__compile_ctxt_to_file(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcomp__init_ctxt() -> Lisp_Object;
}
extern "C" {
    pub fn Fcomp__install_trampoline(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcomp__late_register_subr(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcomp__register_lambda(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcomp__register_subr(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcomp__release_ctxt() -> Lisp_Object;
}
extern "C" {
    pub fn Fcomp__subr_signature(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcomp_el_to_eln_filename(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcomp_el_to_eln_rel_filename(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcomp_libgccjit_version() -> Lisp_Object;
}
extern "C" {
    pub fn Fcomp_native_driver_options_effective_p() -> Lisp_Object;
}
extern "C" {
    pub fn Fcompare_buffer_substrings(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcompare_strings(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcompare_window_configurations(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcompleting_read(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
        arg8: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcompose_region_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcompose_string_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcomposition_get_gstring(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcompute_motion(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fconcat(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcond(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcondition_case(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcondition_mutex(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcondition_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcondition_notify(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcondition_variable_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcondition_wait(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcons(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fconsp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fconstrain_to_field(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcontinue_process(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcontrolling_tty_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcoordinates_in_window_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcopy_alist(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcopy_category_table(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcopy_file(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fcopy_hash_table(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcopy_keymap(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcopy_marker(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcopy_sequence(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcopy_syntax_table(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcopysign(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcos(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_active_maps(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_bidi_paragraph_direction(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_buffer() -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_case_table() -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_column() -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_global_map() -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_idle_time() -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_indentation() -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_input_mode() -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_local_map() -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_message() -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_minor_mode_maps() -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_thread() -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_time() -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_time_string(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_time_zone(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fcurrent_window_configuration(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdaemon_initialized() -> Lisp_Object;
}
extern "C" {
    pub fn Fdaemonp() -> Lisp_Object;
}
extern "C" {
    pub fn Fdbus__init_bus(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdbus_get_unique_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdbus_message_internal(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdebug_timer_check() -> Lisp_Object;
}
extern "C" {
    pub fn Fdeclare_equiv_charset(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fdecode_big5_char(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdecode_char(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdecode_coding_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fdecode_coding_string(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fdecode_sjis_char(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdecode_time(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefalias(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefault_boundp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefault_file_modes() -> Lisp_Object;
}
extern "C" {
    pub fn Fdefault_toplevel_value(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefault_value(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefconst(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefine_category(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Fdefine_charset_alias(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefine_charset_internal(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefine_coding_system_alias(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefine_coding_system_internal(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefine_fringe_bitmap(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefine_hash_table_test(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefine_key(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefvar(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdefvaralias(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_all_overlays(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_and_extract_region(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_char(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_directory_internal(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_field(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_file(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_frame(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_other_windows_internal(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_overlay(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_process(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_region(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_terminal(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelete_window_internal(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdelq(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdeno(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdescribe_buffer_bindings(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fdescribe_vector(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdestroy_fringe_bitmap(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdetect_coding_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fdetect_coding_string(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fding(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdirectory_file_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdirectory_files(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fdirectory_files_and_attributes(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fdirectory_name_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdiscard_input() -> Lisp_Object;
}
extern "C" {
    pub fn Fdisplay__update_for_mouse_movement(arg1: Lisp_Object, arg2: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Fdisplay_supports_face_attributes_p(arg1: Lisp_Object, arg2: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Fdo_auto_save(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdocumentation(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdocumentation_property(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fdowncase(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdowncase_region(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Fdowncase_word(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdraw_string(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdump_colors() -> Lisp_Object;
}
extern "C" {
    pub fn Fdump_emacs(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdump_emacs_portable(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdump_emacs_portable__sort_predicate(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fdump_emacs_portable__sort_predicate_copied(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fdump_face(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdump_frame_glyph_matrix() -> Lisp_Object;
}
extern "C" {
    pub fn Fdump_glyph_matrix(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdump_glyph_row(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdump_redisplay_history() -> Lisp_Object;
}
extern "C" {
    pub fn Fdump_tab_bar_row(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fdump_tool_bar_row(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Felt(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Femacs_pid() -> Lisp_Object;
}
extern "C" {
    pub fn Fencode_big5_char(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fencode_char(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fencode_coding_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fencode_coding_string(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fencode_sjis_char(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fencode_time(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fend_kbd_macro(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fend_of_line(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feobp() -> Lisp_Object;
}
extern "C" {
    pub fn Feolp() -> Lisp_Object;
}
extern "C" {
    pub fn Feq(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feql(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feqlsign(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fequal(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fequal_including_properties(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ferase_buffer() -> Lisp_Object;
}
extern "C" {
    pub fn Ferror_message_string(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feval(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feval_buffer(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Feval_js(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feval_js_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feval_js_buffer_literally(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feval_js_expression(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feval_js_file(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feval_js_literally(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feval_js_region(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feval_js_region_literally(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feval_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Feval_ts_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Feval_ts_region(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fevent_convert_list(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fevent_symbol_parse_modifiers(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fexecute_kbd_macro(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fexit_recursive_edit() -> Lisp_Object;
}
extern "C" {
    pub fn Fexp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fexpand_file_name(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fexpt(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fexternal_debugging_output(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fface_attribute_relative_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fface_attributes_as_vector(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fface_font(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffboundp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffceiling(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffeaturep(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffetch_bytecode(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fffloor(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffield_beginning(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Ffield_end(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffield_string(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffield_string_no_properties(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_accessible_directory_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_acl(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_attributes(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_attributes_lessp(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_directory_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_executable_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_exists_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_locked_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_modes(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_name_absolute_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_name_all_completions(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_name_as_directory(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_name_case_insensitive_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_name_completion(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_name_directory(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_name_nondirectory(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_newer_than_file_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_readable_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_regular_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_selinux_context(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_symlink_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_system_info(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffile_writable_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffillarray(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffind_charset_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Ffind_charset_string(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffind_coding_systems_region_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Ffind_composition_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Ffind_file_name_handler(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffind_font(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffind_operation_coding_system(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffloat(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffloat_time(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffloatp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffloor(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffmakunbound(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffollowing_char() -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_at(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_drive_otf(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_face_attributes(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_family_list(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_get(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_get_glyphs(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_info(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_match_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_otf_alternates(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_put(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_shape_gstring(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_spec(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_variation_glyphs(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffont_xlfd_name(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffontp(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffontset_font(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffontset_info(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffontset_list() -> Lisp_Object;
}
extern "C" {
    pub fn Ffontset_list_all() -> Lisp_Object;
}
extern "C" {
    pub fn Fforce_mode_line_update(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fforce_window_update(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fformat(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fformat_message(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fformat_mode_line(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fformat_network_address(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fformat_time_string(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fforward_char(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fforward_comment(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fforward_line(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fforward_word(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_after_make_frame(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_ancestor_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_char_height(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_char_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_child_frame_border_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_face_alist(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_first_window(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_focus(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_font_cache(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_internal_border_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_list() -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_live_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_native_height(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_native_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_old_selected_window(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_or_buffer_changed_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_parameter(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_parameters(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_parent(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_pointer_visible_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_position(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_root_window(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_selected_window(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_terminal(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_text_cols(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_text_height(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_text_lines(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_text_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_total_cols(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_total_lines(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_visible_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_window_state_change(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fframe_windows_min_size(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fframep(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffrexp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffringe_bitmaps_at_pos(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffringe_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffround(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffset(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fftruncate(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffunc_arity(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffuncall(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffuncall_interactively(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffunction(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffunction_equal(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ffunctionp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgap_position() -> Lisp_Object;
}
extern "C" {
    pub fn Fgap_size() -> Lisp_Object;
}
extern "C" {
    pub fn Fgarbage_collect() -> Lisp_Object;
}
extern "C" {
    pub fn Fgarbage_collect_maybe(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgenerate_new_buffer_name(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgeq(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fget(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_buffer_create(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_buffer_process(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_buffer_window(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_byte(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_char_property(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_char_property_and_overlay(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_file_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_file_char() -> Lisp_Object;
}
extern "C" {
    pub fn Fget_internal_run_time() -> Lisp_Object;
}
extern "C" {
    pub fn Fget_load_suffixes() -> Lisp_Object;
}
extern "C" {
    pub fn Fget_pos_property(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_process(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_text_property(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_unicode_property_internal(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_unused_category(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_unused_iso_final_char(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fget_variable_watchers(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgetenv_internal(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgethash(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgit_init(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_asynchronous_parameters(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_available_p() -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_boot(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_bye(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_ciphers() -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_deinit(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_digests() -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_error_fatalp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_error_string(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_errorp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_format_certificate(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_get_initstage(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_hash_digest(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_hash_mac(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_macs() -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_peer_status(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_peer_status_warning_describe(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_symmetric_decrypt(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fgnutls_symmetric_encrypt(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fgoto_char(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgpm_mouse_start() -> Lisp_Object;
}
extern "C" {
    pub fn Fgpm_mouse_stop() -> Lisp_Object;
}
extern "C" {
    pub fn Fgroup_gid() -> Lisp_Object;
}
extern "C" {
    pub fn Fgroup_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fgroup_real_gid() -> Lisp_Object;
}
extern "C" {
    pub fn Fgtr(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fhandle_switch_frame(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fhash_table_count(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fhash_table_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fhash_table_rehash_size(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fhash_table_rehash_threshold(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fhash_table_size(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fhash_table_test(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fhash_table_weakness(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fhelp__describe_vector(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Ficonify_frame(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fidentity(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fif(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fimage_cache_size() -> Lisp_Object;
}
extern "C" {
    pub fn Fimage_flush(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fimage_mask_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fimage_metadata(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fimage_size(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fimage_transforms_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fimagemagick_types() -> Lisp_Object;
}
extern "C" {
    pub fn Fimagep(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Findent_to(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Findirect_function(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Findirect_variable(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finit_image_library(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finnermost_minibuffer_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finotify_add_watch(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finotify_allocated_p() -> Lisp_Object;
}
extern "C" {
    pub fn Finotify_rm_watch(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finotify_valid_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finotify_watch_list() -> Lisp_Object;
}
extern "C" {
    pub fn Finput_pending_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finsert(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finsert_and_inherit(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finsert_and_inherit_before_markers(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finsert_before_markers(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finsert_buffer_substring(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finsert_byte(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finsert_char(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finsert_file_contents(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finteger_or_marker_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fintegerp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finteractive(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finteractive_form(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fintern(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fintern_soft(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal__define_uninitialized_variable(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_char_font(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_complete_buffer(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_copy_lisp_face(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_decode_string_utf_8(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_default_interrupt_process(arg1: Lisp_Object, arg2: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_default_process_filter(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_default_process_sentinel(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_describe_syntax_value(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_encode_string_utf_8(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_face_x_get_resource(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_get_lisp_face_attribute(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_handle_focus_in(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_lisp_face_attribute_values(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_lisp_face_empty_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_lisp_face_equal_p(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_lisp_face_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_make_lisp_face(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_merge_in_global_face(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_set_alternative_font_family_alist(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_set_alternative_font_registry_alist(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_set_font_selection_order(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_set_lisp_face_attribute(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_set_lisp_face_attribute_from_resource(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_show_cursor(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_show_cursor_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finternal_track_mouse(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finterrupt_process(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finvisible_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Finvocation_directory() -> Lisp_Object;
}
extern "C" {
    pub fn Finvocation_name() -> Lisp_Object;
}
extern "C" {
    pub fn Fisnan(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fiso_charset(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fjs__clear(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fjs__reenter(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fjs__sweep() -> Lisp_Object;
}
extern "C" {
    pub fn Fjs_cleanup() -> Lisp_Object;
}
extern "C" {
    pub fn Fjs_get_tick_rate() -> Lisp_Object;
}
extern "C" {
    pub fn Fjs_initialize(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fjs_set_tick_rate(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fjs_tick_event_loop(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fjson_de(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fjson_insert(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fjson_parse_buffer(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fjson_parse_string(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fjson_se(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fjson_serialize(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fkey_binding(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fkey_description(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fkeyboard_coding_system(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fkeymap__get_keyelt(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fkeymap_parent(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fkeymap_prompt(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fkeymapp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fkeywordp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fkill_all_local_variables() -> Lisp_Object;
}
extern "C" {
    pub fn Fkill_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fkill_emacs(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fkill_local_variable(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fkill_process(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flast_nonminibuf_frame() -> Lisp_Object;
}
extern "C" {
    pub fn Flax_plist_get(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flax_plist_put(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flcms2_available_p() -> Lisp_Object;
}
extern "C" {
    pub fn Flcms_cam02_ucs(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Flcms_cie_de2000(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Flcms_jab_to_jch(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Flcms_jch_to_jab(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Flcms_jch_to_xyz(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Flcms_temp_to_white_point(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flcms_xyz_to_jch(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Fldexp(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flength(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flength_equal(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flength_greater(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flength_less(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fleq(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flet(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn FletX(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flibxml_available_p() -> Lisp_Object;
}
extern "C" {
    pub fn Flibxml_parse_html_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Flibxml_parse_xml_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fline_beginning_position(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fline_end_position(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fline_number_at_pos(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fline_number_display_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fline_pixel_height() -> Lisp_Object;
}
extern "C" {
    pub fn Flist(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flist_fonts(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Flist_system_processes() -> Lisp_Object;
}
extern "C" {
    pub fn Flistp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fload(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fload_average(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flocal_variable_if_set_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flocal_variable_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flocale_info(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flocate_file_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Flock_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flog(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flogand(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flogb(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flogcount(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flogior(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flognot(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flogxor(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flooking_at(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flookup_image(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flookup_image_map(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Flookup_key(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flossage_size(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flower_frame(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flread__substitute_object_in_subtree(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Flsp_async_send_request(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Flsp_handler(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flsp_json_config(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Flss(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmacroexpand(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_bool_vector(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_byte_code(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_category_set(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_category_table() -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_char(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_char_table(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_closure(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_condition_variable(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_directory_internal(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_finalizer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_frame_invisible(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_frame_visible(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_hash_table(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_indirect_buffer(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_keymap(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_list(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_local_variable(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_lsp_connection(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_marker() -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_mutex(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_network_process(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_overlay(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_pipe_process(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_process(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_record(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_serial_process(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_sparse_keymap(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_string(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_symbol(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_symbolic_link(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_temp_file_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_temp_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_terminal_frame(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_thread(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_var_non_special(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_variable_buffer_local(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmake_vector(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmakunbound(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmalloc_info() -> Lisp_Object;
}
extern "C" {
    pub fn Fmap_char_table(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmap_charset_chars(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmap_keymap(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmap_keymap_internal(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmapatoms(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmapbacktrace(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmapcan(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmapcar(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmapconcat(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmaphash(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmark_marker() -> Lisp_Object;
}
extern "C" {
    pub fn Fmarker_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmarker_insertion_type(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmarker_position(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmarkerp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmatch_beginning(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmatch_data(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmatch_data__translate(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmatch_end(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmatching_paren(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmax(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmax_char() -> Lisp_Object;
}
extern "C" {
    pub fn Fmd5(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmember(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmemory_info() -> Lisp_Object;
}
extern "C" {
    pub fn Fmemory_use_counts() -> Lisp_Object;
}
extern "C" {
    pub fn Fmemq(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmemql(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmenu_bar_menu_at_x_y(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmerge_face_attribute(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmessage(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmessage_box(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmessage_or_box(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmin(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fminibuffer_contents() -> Lisp_Object;
}
extern "C" {
    pub fn Fminibuffer_contents_no_properties() -> Lisp_Object;
}
extern "C" {
    pub fn Fminibuffer_depth() -> Lisp_Object;
}
extern "C" {
    pub fn Fminibuffer_innermost_command_loop_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fminibuffer_prompt() -> Lisp_Object;
}
extern "C" {
    pub fn Fminibuffer_prompt_end() -> Lisp_Object;
}
extern "C" {
    pub fn Fminibuffer_selected_window() -> Lisp_Object;
}
extern "C" {
    pub fn Fminibuffer_window(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fminibufferp(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fminor_mode_key_binding(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fminus(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmod(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmodify_category_entry(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmodify_frame_parameters(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmodify_syntax_entry(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmodule_function_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmodule_load(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmouse_pixel_position() -> Lisp_Object;
}
extern "C" {
    pub fn Fmouse_position() -> Lisp_Object;
}
extern "C" {
    pub fn Fmove_overlay(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fmove_point_visually(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmove_to_column(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmove_to_window_line(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmultibyte_char_to_unibyte(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmultibyte_string_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmutex_lock(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmutex_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmutex_unlock(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fmutexp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnarrow_to_region(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnative_comp_available_p() -> Lisp_Object;
}
extern "C" {
    pub fn Fnative_comp_unit_file(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnative_comp_unit_set_file(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnative_elisp_load(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnatnump(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnconc(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fneq(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnetwork_interface_info(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnetwork_interface_list(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnetwork_lookup_address_info(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnew_fontset(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnewline_cache_check(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnext_char_property_change(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnext_frame(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnext_overlay_change(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnext_property_change(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fnext_read_file_uses_dialog_p() -> Lisp_Object;
}
extern "C" {
    pub fn Fnext_single_char_property_change(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fnext_single_property_change(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fnext_window(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fng_module_function_address(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fngettext(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnlistp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnreverse(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnth(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnthcdr(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnull(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnumber_or_marker_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnumber_to_string(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fnumberp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fobject_intervals(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fold_selected_frame() -> Lisp_Object;
}
extern "C" {
    pub fn Fold_selected_window() -> Lisp_Object;
}
extern "C" {
    pub fn Fopen_dribble_file(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fopen_font(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fopen_termscript(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Foptimize_char_table(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn For(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fother_buffer(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fother_window_for_scrolling() -> Lisp_Object;
}
extern "C" {
    pub fn Foverlay_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Foverlay_end(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Foverlay_get(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Foverlay_lists() -> Lisp_Object;
}
extern "C" {
    pub fn Foverlay_properties(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Foverlay_put(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Foverlay_recenter(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Foverlay_start(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Foverlayp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Foverlays_at(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Foverlays_in(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fparse_partial_sexp(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fpdumper_stats() -> Lisp_Object;
}
extern "C" {
    pub fn Fplay_sound_internal(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fplist_get(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fplist_member(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fplist_put(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fplus(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fpoint() -> Lisp_Object;
}
extern "C" {
    pub fn Fpoint_marker() -> Lisp_Object;
}
extern "C" {
    pub fn Fpoint_max() -> Lisp_Object;
}
extern "C" {
    pub fn Fpoint_max_marker() -> Lisp_Object;
}
extern "C" {
    pub fn Fpoint_min() -> Lisp_Object;
}
extern "C" {
    pub fn Fpoint_min_marker() -> Lisp_Object;
}
extern "C" {
    pub fn Fpos_visible_in_window_p(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fposition_bytes(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fposix_looking_at(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fposix_search_backward(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fposix_search_forward(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fposix_string_match(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fposn_at_point(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fposn_at_x_y(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fprefix_numeric_value(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprevious_char() -> Lisp_Object;
}
extern "C" {
    pub fn Fprevious_char_property_change(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprevious_frame(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprevious_overlay_change(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprevious_property_change(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fprevious_single_char_property_change(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fprevious_single_property_change(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fprevious_window(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Fprin1(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprin1_to_string(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprinc(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprint(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprint_preprocess(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_attributes(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_coding_system(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_command(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_connection(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_contact(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_datagram_address(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_exit_status(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_filter(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_filter_multibyte_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_id(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_inherit_coding_system_flag(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_list() -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_mark(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_plist(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_query_on_exit_flag(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_running_child_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_send_eof(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_send_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_send_string(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_sentinel(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_status(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_thread(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_tty_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocess_type(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprocessp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprofiler_cpu_log() -> Lisp_Object;
}
extern "C" {
    pub fn Fprofiler_cpu_running_p() -> Lisp_Object;
}
extern "C" {
    pub fn Fprofiler_cpu_start(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprofiler_cpu_stop() -> Lisp_Object;
}
extern "C" {
    pub fn Fprofiler_memory_log() -> Lisp_Object;
}
extern "C" {
    pub fn Fprofiler_memory_running_p() -> Lisp_Object;
}
extern "C" {
    pub fn Fprofiler_memory_start() -> Lisp_Object;
}
extern "C" {
    pub fn Fprofiler_memory_stop() -> Lisp_Object;
}
extern "C" {
    pub fn Fprog1(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprogn(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fproper_list_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fpropertize(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fprovide(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fpurecopy(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fput(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fput_text_property(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fput_unicode_property_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fputhash(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fquery_font(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fquery_fontset(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fquit_process(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fquo(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fquote(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fraise_frame(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frandom(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frassoc(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frassq(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fre_search_backward(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fre_search_forward(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fread(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_buffer(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_char(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_char_exclusive(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_coding_system(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_command(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_event(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_from_minibuffer(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_from_string(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_function(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_key_sequence(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_key_sequence_vector(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_no_blanks_input(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_non_nil_coding_system(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_string(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fread_variable(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frecent_auto_save_p() -> Lisp_Object;
}
extern "C" {
    pub fn Frecent_keys(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frecenter(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frecord(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frecordp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frecursion_depth() -> Lisp_Object;
}
extern "C" {
    pub fn Frecursive_edit() -> Lisp_Object;
}
extern "C" {
    pub fn Fredirect_debugging_output(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fredirect_frame_focus(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fredisplay(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fredraw_display() -> Lisp_Object;
}
extern "C" {
    pub fn Fredraw_frame(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fregexp_quote(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fregion_beginning() -> Lisp_Object;
}
extern "C" {
    pub fn Fregion_end() -> Lisp_Object;
}
extern "C" {
    pub fn Fregister_ccl_program(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fregister_code_conversion_map(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frem(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fremhash(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fremove_list_of_text_properties(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fremove_text_properties(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fremove_variable_watcher(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frename_buffer(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frename_file(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Freplace_buffer_contents(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Freplace_match(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Frequire(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fresize_mini_window_internal(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frestore_buffer_modified_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fresume_tty(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Freverse(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fright_divider_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fround(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frun_hook_with_args(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frun_hook_with_args_until_failure(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frun_hook_with_args_until_success(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frun_hook_wrapped(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frun_hooks(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frun_window_configuration_change_hook(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Frun_window_scroll_functions(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsafe_length(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsave_current_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsave_excursion(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsave_restriction(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fscan_lists(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fscan_sexps(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fscroll_bar_height(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fscroll_bar_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fscroll_down(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fscroll_left(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fscroll_other_window(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fscroll_other_window_down(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fscroll_right(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fscroll_up(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsearch_backward(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fsearch_forward(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fsecure_hash(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fsecure_hash_algorithms() -> Lisp_Object;
}
extern "C" {
    pub fn Fselect_frame(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fselect_window(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fselected_frame() -> Lisp_Object;
}
extern "C" {
    pub fn Fselected_window() -> Lisp_Object;
}
extern "C" {
    pub fn Fself_insert_command(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsend_string_to_terminal(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsequencep(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fserial_process_configure(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset__this_command_keys(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_binary_mode(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_buffer_auto_saved() -> Lisp_Object;
}
extern "C" {
    pub fn Fset_buffer_major_mode(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_buffer_modified_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_buffer_multibyte(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_buffer_redisplay(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_case_table(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_category_table(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_char_table_extra_slot(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_char_table_parent(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_char_table_range(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_charset_plist(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_charset_priority(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_coding_system_priority(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_default(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_default_file_modes(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_default_toplevel_value(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_file_acl(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_file_modes(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_file_selinux_context(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_file_times(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_fontset_font(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_frame_height(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_frame_position(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_frame_selected_window(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_frame_size(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_frame_width(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_frame_window_state_change(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_fringe_bitmap_face(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_input_interrupt_mode(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_input_meta_mode(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_input_mode(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_keyboard_coding_system_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_keymap_parent(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_marker(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_marker_insertion_type(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_match_data(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_minibuffer_window(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_mouse_pixel_position(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_mouse_position(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_network_process_option(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_output_flow_control(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_process_buffer(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_process_coding_system(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_process_datagram_address(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_process_filter(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_process_filter_multibyte(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_process_inherit_coding_system_flag(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_process_plist(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_process_query_on_exit_flag(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_process_sentinel(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_process_thread(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_process_window_size(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_quit_char(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_safe_terminal_coding_system_internal(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_standard_case_table(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_syntax_table(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_terminal_coding_system_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_terminal_parameter(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_text_properties(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_time_zone_rule(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_visited_file_modtime(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_buffer(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_combination_limit(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_configuration(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_dedicated_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_display_table(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_fringes(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_hscroll(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_margins(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_new_normal(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_new_pixel(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_new_total(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_next_buffers(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_parameter(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_point(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_prev_buffers(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_redisplay_end_trigger(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_scroll_bars(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_start(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fset_window_vscroll(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fsetcar(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsetcdr(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsetplist(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsetq(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fshow_face_resources() -> Lisp_Object;
}
extern "C" {
    pub fn Fsignal_process(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsin(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsingle_key_description(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fskip_chars_backward(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fskip_chars_forward(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fskip_syntax_backward(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fskip_syntax_forward(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsleep_for(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsnarf_documentation(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsort(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsort_charsets(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fspecial_variable_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsplit_char(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsplit_window_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fsqrt(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstandard_case_table() -> Lisp_Object;
}
extern "C" {
    pub fn Fstandard_category_table() -> Lisp_Object;
}
extern "C" {
    pub fn Fstandard_syntax_table() -> Lisp_Object;
}
extern "C" {
    pub fn Fstart_kbd_macro(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstop_process(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstore_kbd_macro_event(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_as_multibyte(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_as_unibyte(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_bytes(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_collate_equalp(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_collate_lessp(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_distance(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_equal(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_lessp(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_make_multibyte(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_make_unibyte(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_match(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_search(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_to_char(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_to_multibyte(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_to_number(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_to_syntax(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_to_unibyte(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_version_lessp(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstring_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fstringp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsub1(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsubr_arity(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsubr_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsubr_native_comp_unit(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsubr_native_elisp_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsubr_native_lambda_list(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsubr_type(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsubrp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsubst_char_in_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fsubstitute_in_file_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsubstring(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsubstring_no_properties(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fsuspend_emacs(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsuspend_tty(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsuspicious_object(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsxhash_eq(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsxhash_eql(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsxhash_equal(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsymbol_function(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsymbol_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsymbol_plist(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsymbol_value(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsymbolp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsyntax_table() -> Lisp_Object;
}
extern "C" {
    pub fn Fsyntax_table_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fsystem_groups() -> Lisp_Object;
}
extern "C" {
    pub fn Fsystem_name() -> Lisp_Object;
}
extern "C" {
    pub fn Fsystem_users() -> Lisp_Object;
}
extern "C" {
    pub fn Ftab_bar_height(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftan(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fterminal_coding_system(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fterminal_list() -> Lisp_Object;
}
extern "C" {
    pub fn Fterminal_live_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fterminal_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fterminal_parameter(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fterminal_parameters(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fterpri(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftest_completion(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Ftext_char_description(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftext_properties_at(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftext_property_any(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Ftext_property_not_all(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Ftext_quoting_style() -> Lisp_Object;
}
extern "C" {
    pub fn Fthis_command_keys() -> Lisp_Object;
}
extern "C" {
    pub fn Fthis_command_keys_vector() -> Lisp_Object;
}
extern "C" {
    pub fn Fthis_single_command_keys() -> Lisp_Object;
}
extern "C" {
    pub fn Fthis_single_command_raw_keys() -> Lisp_Object;
}
extern "C" {
    pub fn Fthread_blocker(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fthread_join(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fthread_last_error(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fthread_live_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fthread_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fthread_signal(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fthread_yield() -> Lisp_Object;
}
extern "C" {
    pub fn Fthreadp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fthrow(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftime_add(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftime_convert(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftime_equal_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftime_less_p(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftime_subtract(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftimes(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftool_bar_height(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftool_bar_pixel_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftop_level() -> Lisp_Object;
}
extern "C" {
    pub fn Ftrace_redisplay(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftrace_to_stderr(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftranslate_region_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Ftranspose_regions(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Ftruncate(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftry_completion(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftty_display_color_cells(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftty_display_color_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftty_no_underline(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftty_suppress_bold_inverse_default_colors(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftty_top_frame(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftty_type(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Ftype_of(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fundo_boundary() -> Lisp_Object;
}
extern "C" {
    pub fn Funencodable_char_position(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Funhandled_file_name_directory(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Funibyte_char_to_multibyte(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Funibyte_string(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Funicode_property_table_internal(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Funify_charset(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Funintern(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Funix_sync() -> Lisp_Object;
}
extern "C" {
    pub fn Funlock_buffer() -> Lisp_Object;
}
extern "C" {
    pub fn Funwind_protect(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fupcase(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fupcase_initials(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fupcase_initials_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fupcase_region(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fupcase_word(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fuse_global_map(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fuse_local_map(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fuser_full_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fuser_login_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fuser_ptrp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fuser_real_login_name() -> Lisp_Object;
}
extern "C" {
    pub fn Fuser_real_uid() -> Lisp_Object;
}
extern "C" {
    pub fn Fuser_uid() -> Lisp_Object;
}
extern "C" {
    pub fn Fvariable_binding_locus(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fvconcat(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fvector(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fvector_or_char_table_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fvectorp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fverify_visited_file_modtime(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fvertical_motion(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object)
        -> Lisp_Object;
}
extern "C" {
    pub fn Fvisible_frame_list() -> Lisp_Object;
}
extern "C" {
    pub fn Fvisited_file_modtime() -> Lisp_Object;
}
extern "C" {
    pub fn Fwaiting_for_user_input_p() -> Lisp_Object;
}
extern "C" {
    pub fn Fwhere_is_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fwhile(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwiden() -> Lisp_Object;
}
extern "C" {
    pub fn Fwidget_apply(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwidget_get(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwidget_put(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_at(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_body_height(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_body_width(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_bottom_divider_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_bump_use_time(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_combination_limit(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_configuration_frame(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_configuration_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_dedicated_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_display_table(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_end(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_frame(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_fringes(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_header_line_height(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_hscroll(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_left_child(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_left_column(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_line_height(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_lines_pixel_dimensions(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_list(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_list_1(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_live_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_margins(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_minibuffer_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_mode_line_height(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_new_normal(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_new_pixel(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_new_total(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_next_buffers(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_next_sibling(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_normal_size(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_old_body_pixel_height(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_old_body_pixel_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_old_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_old_pixel_height(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_old_pixel_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_old_point(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_parameter(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_parameters(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_parent(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_pixel_height(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_pixel_left(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_pixel_top(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_pixel_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_point(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_prev_buffers(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_prev_sibling(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_redisplay_end_trigger(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_resize_apply(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_resize_apply_total(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_right_divider_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_scroll_bar_height(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_scroll_bar_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_scroll_bars(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_start(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_system(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_tab_line_height(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_text_height(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_text_pixel_size(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_text_width(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_top_child(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_top_line(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_total_height(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_total_width(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_use_time(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_valid_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindow_vscroll(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwindowp(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwrite_char(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fwrite_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_change_window_property(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_create_frame(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_display_color_cells(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_display_grayscale_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_display_monitor_attributes_list(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_display_pixel_height(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_display_pixel_width(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_display_planes(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_display_visual_class(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_family_fonts(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_focus_frame(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_get_resource(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_get_selection_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_hide_tip() -> Lisp_Object;
}
extern "C" {
    pub fn Fx_list_fonts(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_load_color_file(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_open_connection(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_own_selection_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_parse_geometry(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_popup_dialog(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_popup_menu(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_register_dnd_atom(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fx_wm_set_size_hint(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fxw_color_values(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fxw_display_color_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fyes_or_no_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn Fzlib_available_p() -> Lisp_Object;
}
extern "C" {
    pub fn Fzlib_decompress_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union vectorlike_header {
    pub size: isize,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_vectorlike_header() {
    assert_eq!(
        ::std::mem::size_of::<vectorlike_header>(),
        8usize,
        concat!("Size of: ", stringify!(vectorlike_header))
    );
    assert_eq!(
        ::std::mem::align_of::<vectorlike_header>(),
        8usize,
        concat!("Alignment of ", stringify!(vectorlike_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vectorlike_header>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vectorlike_header),
            "::",
            stringify!(size)
        )
    );
}
impl Default for vectorlike_header {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn SYMBOLP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XSYMBOL(a: Lisp_Object) -> *mut Lisp_Symbol;
}
extern "C" {
    pub fn make_lisp_symbol(sym: *mut Lisp_Symbol) -> Lisp_Object;
}
extern "C" {
    pub fn builtin_lisp_symbol(index: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn c_symbol_p(sym: *mut Lisp_Symbol) -> bool;
}
extern "C" {
    pub fn CHECK_SYMBOL(x: Lisp_Object);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pvec_type {
    PVEC_NORMAL_VECTOR = 0,
    PVEC_FREE = 1,
    PVEC_BIGNUM = 2,
    PVEC_MARKER = 3,
    PVEC_OVERLAY = 4,
    PVEC_FINALIZER = 5,
    PVEC_MISC_PTR = 6,
    PVEC_USER_PTR = 7,
    PVEC_PROCESS = 8,
    PVEC_FRAME = 9,
    PVEC_WINDOW = 10,
    PVEC_BOOL_VECTOR = 11,
    PVEC_BUFFER = 12,
    PVEC_HASH_TABLE = 13,
    PVEC_TERMINAL = 14,
    PVEC_WINDOW_CONFIGURATION = 15,
    PVEC_SUBR = 16,
    PVEC_OTHER = 17,
    PVEC_XWIDGET = 18,
    PVEC_XWIDGET_VIEW = 19,
    PVEC_THREAD = 20,
    PVEC_MUTEX = 21,
    PVEC_CONDVAR = 22,
    PVEC_MODULE_FUNCTION = 23,
    PVEC_NATIVE_COMP_UNIT = 24,
    PVEC_COMPILED = 25,
    PVEC_CHAR_TABLE = 26,
    PVEC_SUB_CHAR_TABLE = 27,
    PVEC_RECORD = 28,
    PVEC_FONT = 29,
}
pub mod More_Lisp_Bits {
    pub type Type = u32;
    pub const PSEUDOVECTOR_SIZE_BITS: Type = 12;
    pub const PSEUDOVECTOR_SIZE_MASK: Type = 4095;
    pub const PSEUDOVECTOR_REST_BITS: Type = 12;
    pub const PSEUDOVECTOR_REST_MASK: Type = 16773120;
    pub const PSEUDOVECTOR_AREA_BITS: Type = 24;
    pub const PVEC_TYPE_MASK: Type = 1056964608;
}
extern "C" {
    pub fn make_fixnum(n: EMACS_INT) -> Lisp_Object;
}
extern "C" {
    pub fn XFIXNUM_RAW(a: Lisp_Object) -> EMACS_INT;
}
extern "C" {
    pub fn make_ufixnum(n: EMACS_INT) -> Lisp_Object;
}
extern "C" {
    pub fn FIXNUMP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XFIXNUM(a: Lisp_Object) -> EMACS_INT;
}
extern "C" {
    pub fn XUFIXNUM_RAW(a: Lisp_Object) -> EMACS_UINT;
}
extern "C" {
    pub fn XUFIXNUM(a: Lisp_Object) -> EMACS_UINT;
}
extern "C" {
    pub fn XHASH(a: Lisp_Object) -> EMACS_INT;
}
extern "C" {
    pub fn make_fixed_natnum(n: EMACS_INT) -> Lisp_Object;
}
extern "C" {
    pub fn EQ(x: Lisp_Object, y: Lisp_Object) -> bool;
}
extern "C" {
    pub fn clip_to_bounds(lower: intmax_t, num: intmax_t, upper: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn make_lisp_ptr(ptr: *mut ::libc::c_void, type_: Lisp_Type) -> Lisp_Object;
}
extern "C" {
    pub fn dead_object() -> Lisp_Object;
}
extern "C" {
    pub fn XFIXNUMPTR(a: Lisp_Object) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn make_pointer_integer_unsafe(p: *mut ::libc::c_void) -> Lisp_Object;
}
extern "C" {
    pub fn make_pointer_integer(p: *mut ::libc::c_void) -> Lisp_Object;
}
pub type INTERVAL = *mut interval;
#[repr(C)]
pub struct Lisp_Cons {
    pub u: Lisp_Cons__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
pub struct Lisp_Cons__bindgen_ty_1 {
    pub s: __BindgenUnionField<Lisp_Cons__bindgen_ty_1__bindgen_ty_1>,
    pub gcaligned: __BindgenUnionField<::libc::c_char>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
pub struct Lisp_Cons__bindgen_ty_1__bindgen_ty_1 {
    pub car: Lisp_Object,
    pub u: Lisp_Cons__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
pub union Lisp_Cons__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub cdr: Lisp_Object,
    pub chain: *mut Lisp_Cons,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Lisp_Cons__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Cons__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(Lisp_Cons__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Cons__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Lisp_Cons__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Cons__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).cdr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Cons__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(cdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Cons__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).chain
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Cons__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(chain)
        )
    );
}
impl Default for Lisp_Cons__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_Lisp_Cons__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Cons__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(Lisp_Cons__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Cons__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Lisp_Cons__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Cons__bindgen_ty_1__bindgen_ty_1>())).car as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Cons__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(car)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Cons__bindgen_ty_1__bindgen_ty_1>())).u as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Cons__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(u)
        )
    );
}
impl Default for Lisp_Cons__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_Lisp_Cons__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Cons__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(Lisp_Cons__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Cons__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Cons__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Cons__bindgen_ty_1>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Cons__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Cons__bindgen_ty_1>())).gcaligned as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Cons__bindgen_ty_1),
            "::",
            stringify!(gcaligned)
        )
    );
}
impl Default for Lisp_Cons__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_Lisp_Cons() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Cons>(),
        16usize,
        concat!("Size of: ", stringify!(Lisp_Cons))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Cons>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Cons))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Cons>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Cons),
            "::",
            stringify!(u)
        )
    );
}
impl Default for Lisp_Cons {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn NILP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CONSP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_CONS(x: Lisp_Object);
}
extern "C" {
    pub fn XCONS(a: Lisp_Object) -> *mut Lisp_Cons;
}
extern "C" {
    pub fn xcar_addr(c: Lisp_Object) -> *mut Lisp_Object;
}
extern "C" {
    pub fn xcdr_addr(c: Lisp_Object) -> *mut Lisp_Object;
}
extern "C" {
    pub fn XCAR(c: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn XCDR(c: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn XSETCAR(c: Lisp_Object, n: Lisp_Object);
}
extern "C" {
    pub fn XSETCDR(c: Lisp_Object, n: Lisp_Object);
}
extern "C" {
    pub fn CAR(c: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn CDR(c: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn CAR_SAFE(c: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn CDR_SAFE(c: Lisp_Object) -> Lisp_Object;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Lisp_String {
    pub u: Lisp_String__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union Lisp_String__bindgen_ty_1 {
    pub s: Lisp_String__bindgen_ty_1__bindgen_ty_1,
    pub next: *mut Lisp_String,
    pub gcaligned: ::libc::c_char,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Lisp_String__bindgen_ty_1__bindgen_ty_1 {
    pub size: isize,
    pub size_byte: isize,
    pub intervals: INTERVAL,
    pub data: *mut ::libc::c_uchar,
}
#[test]
fn bindgen_test_layout_Lisp_String__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_String__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(Lisp_String__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_String__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Lisp_String__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_String__bindgen_ty_1__bindgen_ty_1>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_String__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_String__bindgen_ty_1__bindgen_ty_1>())).size_byte
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_String__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size_byte)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_String__bindgen_ty_1__bindgen_ty_1>())).intervals
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_String__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(intervals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_String__bindgen_ty_1__bindgen_ty_1>())).data as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_String__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
impl Default for Lisp_String__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_Lisp_String__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_String__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(Lisp_String__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_String__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_String__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_String__bindgen_ty_1>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_String__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_String__bindgen_ty_1>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_String__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_String__bindgen_ty_1>())).gcaligned as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_String__bindgen_ty_1),
            "::",
            stringify!(gcaligned)
        )
    );
}
impl Default for Lisp_String__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_Lisp_String() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_String>(),
        32usize,
        concat!("Size of: ", stringify!(Lisp_String))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_String>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_String))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_String>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_String),
            "::",
            stringify!(u)
        )
    );
}
impl Default for Lisp_String {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn STRINGP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_STRING(x: Lisp_Object);
}
extern "C" {
    pub fn XSTRING(a: Lisp_Object) -> *mut Lisp_String;
}
extern "C" {
    pub fn STRING_MULTIBYTE(str: Lisp_Object) -> bool;
}
extern "C" {
    pub fn SDATA(string: Lisp_Object) -> *mut ::libc::c_uchar;
}
extern "C" {
    pub fn SSDATA(string: Lisp_Object) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn SREF(string: Lisp_Object, index: isize) -> ::libc::c_uchar;
}
extern "C" {
    pub fn SSET(string: Lisp_Object, index: isize, new: ::libc::c_uchar);
}
extern "C" {
    pub fn SCHARS(string: Lisp_Object) -> isize;
}
extern "C" {
    pub fn STRING_BYTES(s: *mut Lisp_String) -> isize;
}
extern "C" {
    pub fn SBYTES(string: Lisp_Object) -> isize;
}
extern "C" {
    pub fn STRING_SET_CHARS(string: Lisp_Object, newsize: isize);
}
#[repr(C)]
pub struct Lisp_Vector {
    pub header: vectorlike_header,
    pub contents: __IncompleteArrayField<Lisp_Object>,
}
#[test]
fn bindgen_test_layout_Lisp_Vector() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Vector>(),
        8usize,
        concat!("Size of: ", stringify!(Lisp_Vector))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Vector>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Vector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Vector>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Vector),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Vector>())).contents as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Vector),
            "::",
            stringify!(contents)
        )
    );
}
impl Default for Lisp_Vector {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn VECTORLIKEP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XVECTOR(a: Lisp_Object) -> *mut Lisp_Vector;
}
extern "C" {
    pub fn ASIZE(array: Lisp_Object) -> isize;
}
extern "C" {
    pub fn gc_asize(array: Lisp_Object) -> isize;
}
extern "C" {
    pub fn PVSIZE(pv: Lisp_Object) -> isize;
}
extern "C" {
    pub fn VECTORP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_VECTOR(x: Lisp_Object);
}
extern "C" {
    pub fn PSEUDOVECTOR_TYPE(v: *const Lisp_Vector) -> pvec_type;
}
extern "C" {
    pub fn PSEUDOVECTOR_TYPEP(a: *const vectorlike_header, code: pvec_type) -> bool;
}
extern "C" {
    pub fn PSEUDOVECTORP(a: Lisp_Object, code: ::libc::c_int) -> bool;
}
#[repr(C)]
pub struct Lisp_Bool_Vector {
    pub header: vectorlike_header,
    pub size: EMACS_INT,
    pub data: __IncompleteArrayField<bits_word>,
}
#[test]
fn bindgen_test_layout_Lisp_Bool_Vector() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Bool_Vector>(),
        16usize,
        concat!("Size of: ", stringify!(Lisp_Bool_Vector))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Bool_Vector>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Bool_Vector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Bool_Vector>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Bool_Vector),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Bool_Vector>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Bool_Vector),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Bool_Vector>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Bool_Vector),
            "::",
            stringify!(data)
        )
    );
}
impl Default for Lisp_Bool_Vector {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod _bindgen_ty_4 {
    pub type Type = u32;
    pub const header_size: Type = 8;
    pub const bool_header_size: Type = 16;
    pub const word_size: Type = 8;
}
extern "C" {
    pub fn bool_vector_words(size: EMACS_INT) -> EMACS_INT;
}
extern "C" {
    pub fn bool_vector_bytes(size: EMACS_INT) -> EMACS_INT;
}
extern "C" {
    pub fn BOOL_VECTOR_P(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_BOOL_VECTOR(x: Lisp_Object);
}
extern "C" {
    pub fn XBOOL_VECTOR(a: Lisp_Object) -> *mut Lisp_Bool_Vector;
}
extern "C" {
    pub fn bool_vector_size(a: Lisp_Object) -> EMACS_INT;
}
extern "C" {
    pub fn bool_vector_data(a: Lisp_Object) -> *mut bits_word;
}
extern "C" {
    pub fn bool_vector_uchar_data(a: Lisp_Object) -> *mut ::libc::c_uchar;
}
extern "C" {
    pub fn bool_vector_bitref(a: Lisp_Object, i: EMACS_INT) -> bool;
}
extern "C" {
    pub fn bool_vector_ref(a: Lisp_Object, i: EMACS_INT) -> Lisp_Object;
}
extern "C" {
    pub fn bool_vector_set(a: Lisp_Object, i: EMACS_INT, b: bool);
}
extern "C" {
    pub fn AREF(array: Lisp_Object, idx: isize) -> Lisp_Object;
}
extern "C" {
    pub fn aref_addr(array: Lisp_Object, idx: isize) -> *mut Lisp_Object;
}
extern "C" {
    pub fn ASET(array: Lisp_Object, idx: isize, val: Lisp_Object);
}
extern "C" {
    pub fn gc_aset(array: Lisp_Object, idx: isize, val: Lisp_Object);
}
pub mod _bindgen_ty_5 {
    pub type Type = u32;
    pub const NIL_IS_ZERO: Type = 1;
}
extern "C" {
    pub fn memclear(p: *mut ::libc::c_void, nbytes: isize);
}
extern "C" {
    pub fn ASCII_CHAR_P(c: intmax_t) -> bool;
}
pub mod CHARTAB_SIZE_BITS {
    pub type Type = u32;
    pub const CHARTAB_SIZE_BITS_0: Type = 6;
    pub const CHARTAB_SIZE_BITS_1: Type = 4;
    pub const CHARTAB_SIZE_BITS_2: Type = 5;
    pub const CHARTAB_SIZE_BITS_3: Type = 7;
}
extern "C" {
    #[link_name = "\u{1}chartab_size"]
    pub static mut chartab_size: [::libc::c_int; 4usize];
}
#[repr(C)]
pub struct Lisp_Char_Table {
    pub header: vectorlike_header,
    pub defalt: Lisp_Object,
    pub parent: Lisp_Object,
    pub purpose: Lisp_Object,
    pub ascii: Lisp_Object,
    pub contents: [Lisp_Object; 64usize],
    pub extras: __IncompleteArrayField<Lisp_Object>,
}
#[test]
fn bindgen_test_layout_Lisp_Char_Table() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Char_Table>(),
        552usize,
        concat!("Size of: ", stringify!(Lisp_Char_Table))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Char_Table>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Char_Table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Char_Table>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Char_Table),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Char_Table>())).defalt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Char_Table),
            "::",
            stringify!(defalt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Char_Table>())).parent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Char_Table),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Char_Table>())).purpose as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Char_Table),
            "::",
            stringify!(purpose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Char_Table>())).ascii as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Char_Table),
            "::",
            stringify!(ascii)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Char_Table>())).contents as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Char_Table),
            "::",
            stringify!(contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Char_Table>())).extras as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Char_Table),
            "::",
            stringify!(extras)
        )
    );
}
impl Default for Lisp_Char_Table {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn CHAR_TABLE_P(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XCHAR_TABLE(a: Lisp_Object) -> *mut Lisp_Char_Table;
}
#[repr(C)]
pub struct Lisp_Sub_Char_Table {
    pub header: vectorlike_header,
    pub depth: ::libc::c_int,
    pub min_char: ::libc::c_int,
    pub contents: __IncompleteArrayField<Lisp_Object>,
}
#[test]
fn bindgen_test_layout_Lisp_Sub_Char_Table() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Sub_Char_Table>(),
        16usize,
        concat!("Size of: ", stringify!(Lisp_Sub_Char_Table))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Sub_Char_Table>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Sub_Char_Table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Sub_Char_Table>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Sub_Char_Table),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Sub_Char_Table>())).depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Sub_Char_Table),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Sub_Char_Table>())).min_char as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Sub_Char_Table),
            "::",
            stringify!(min_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Sub_Char_Table>())).contents as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Sub_Char_Table),
            "::",
            stringify!(contents)
        )
    );
}
impl Default for Lisp_Sub_Char_Table {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn SUB_CHAR_TABLE_P(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XSUB_CHAR_TABLE(a: Lisp_Object) -> *mut Lisp_Sub_Char_Table;
}
extern "C" {
    pub fn CHAR_TABLE_REF_ASCII(ct: Lisp_Object, idx: isize) -> Lisp_Object;
}
extern "C" {
    pub fn CHAR_TABLE_REF(ct: Lisp_Object, idx: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn CHAR_TABLE_SET(ct: Lisp_Object, idx: ::libc::c_int, val: Lisp_Object);
}
pub mod _bindgen_ty_6 {
    pub type Type = u32;
    pub const NATIVE_COMP_FLAG: Type = 1;
}
pub type dynlib_handle_ptr = *mut ::libc::c_void;
extern "C" {
    pub fn dynlib_open(path: *const ::libc::c_char) -> dynlib_handle_ptr;
}
extern "C" {
    pub fn dynlib_close(h: dynlib_handle_ptr) -> ::libc::c_int;
}
extern "C" {
    pub fn dynlib_error() -> *const ::libc::c_char;
}
extern "C" {
    pub fn dynlib_sym(h: dynlib_handle_ptr, sym: *const ::libc::c_char) -> *mut ::libc::c_void;
}
pub type dynlib_function_ptr = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn dynlib_func(h: dynlib_handle_ptr, sym: *const ::libc::c_char) -> dynlib_function_ptr;
}
extern "C" {
    pub fn dynlib_addr(
        ptr: ::std::option::Option<unsafe extern "C" fn()>,
        file: *mut *const ::libc::c_char,
        sym: *mut *const ::libc::c_char,
    );
}
#[repr(C)]
pub struct Lisp_Native_Comp_Unit {
    pub header: vectorlike_header,
    pub file: Lisp_Object,
    pub optimize_qualities: Lisp_Object,
    pub lambda_gc_guard_h: Lisp_Object,
    pub lambda_c_name_idx_h: Lisp_Object,
    pub data_fdoc_v: Lisp_Object,
    pub data_vec: Lisp_Object,
    pub data_impure_vec: Lisp_Object,
    pub data_imp_relocs: *mut Lisp_Object,
    pub loaded_once: bool,
    pub load_ongoing: bool,
    pub handle: dynlib_handle_ptr,
}
#[test]
fn bindgen_test_layout_Lisp_Native_Comp_Unit() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Native_Comp_Unit>(),
        88usize,
        concat!("Size of: ", stringify!(Lisp_Native_Comp_Unit))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Native_Comp_Unit>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Native_Comp_Unit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Native_Comp_Unit>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Native_Comp_Unit),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Native_Comp_Unit>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Native_Comp_Unit),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Native_Comp_Unit>())).optimize_qualities as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Native_Comp_Unit),
            "::",
            stringify!(optimize_qualities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Native_Comp_Unit>())).lambda_gc_guard_h as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Native_Comp_Unit),
            "::",
            stringify!(lambda_gc_guard_h)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Native_Comp_Unit>())).lambda_c_name_idx_h as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Native_Comp_Unit),
            "::",
            stringify!(lambda_c_name_idx_h)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Native_Comp_Unit>())).data_fdoc_v as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Native_Comp_Unit),
            "::",
            stringify!(data_fdoc_v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Native_Comp_Unit>())).data_vec as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Native_Comp_Unit),
            "::",
            stringify!(data_vec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Native_Comp_Unit>())).data_impure_vec as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Native_Comp_Unit),
            "::",
            stringify!(data_impure_vec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Native_Comp_Unit>())).data_imp_relocs as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Native_Comp_Unit),
            "::",
            stringify!(data_imp_relocs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Native_Comp_Unit>())).loaded_once as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Native_Comp_Unit),
            "::",
            stringify!(loaded_once)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Native_Comp_Unit>())).load_ongoing as *const _ as usize
        },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Native_Comp_Unit),
            "::",
            stringify!(load_ongoing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Native_Comp_Unit>())).handle as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Native_Comp_Unit),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for Lisp_Native_Comp_Unit {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn NATIVE_COMP_UNITP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XNATIVE_COMP_UNIT(a: Lisp_Object) -> *mut Lisp_Native_Comp_Unit;
}
extern "C" {
    pub fn hash_native_abi();
}
extern "C" {
    pub fn load_comp_unit(
        comp_u: *mut Lisp_Native_Comp_Unit,
        loading_dump: bool,
        late_load: bool,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn unload_comp_unit(arg1: *mut Lisp_Native_Comp_Unit);
}
extern "C" {
    pub fn native_function_doc(function: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn syms_of_comp();
}
extern "C" {
    pub fn maybe_defer_native_compilation(function_name: Lisp_Object, definition: Lisp_Object);
}
extern "C" {
    pub fn eln_load_path_final_clean_up();
}
extern "C" {
    pub fn fixup_eln_load_path(directory: Lisp_Object);
}
#[repr(C)]
pub struct Lisp_Subr {
    pub header: vectorlike_header,
    pub function: Lisp_Subr__bindgen_ty_1,
    pub min_args: ::libc::c_short,
    pub max_args: ::libc::c_short,
    pub symbol_name: *const ::libc::c_char,
    pub __bindgen_anon_1: Lisp_Subr__bindgen_ty_2,
    pub doc: EMACS_INT,
    pub native_comp_u: [Lisp_Object; 1usize],
    pub native_c_name: [*mut ::libc::c_char; 1usize],
    pub lambda_list: [Lisp_Object; 1usize],
    pub type_: [Lisp_Object; 1usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union Lisp_Subr__bindgen_ty_1 {
    pub a0: ::std::option::Option<unsafe extern "C" fn() -> Lisp_Object>,
    pub a1: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object) -> Lisp_Object>,
    pub a2: ::std::option::Option<
        unsafe extern "C" fn(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object,
    >,
    pub a3: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: Lisp_Object,
            arg2: Lisp_Object,
            arg3: Lisp_Object,
        ) -> Lisp_Object,
    >,
    pub a4: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: Lisp_Object,
            arg2: Lisp_Object,
            arg3: Lisp_Object,
            arg4: Lisp_Object,
        ) -> Lisp_Object,
    >,
    pub a5: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: Lisp_Object,
            arg2: Lisp_Object,
            arg3: Lisp_Object,
            arg4: Lisp_Object,
            arg5: Lisp_Object,
        ) -> Lisp_Object,
    >,
    pub a6: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: Lisp_Object,
            arg2: Lisp_Object,
            arg3: Lisp_Object,
            arg4: Lisp_Object,
            arg5: Lisp_Object,
            arg6: Lisp_Object,
        ) -> Lisp_Object,
    >,
    pub a7: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: Lisp_Object,
            arg2: Lisp_Object,
            arg3: Lisp_Object,
            arg4: Lisp_Object,
            arg5: Lisp_Object,
            arg6: Lisp_Object,
            arg7: Lisp_Object,
        ) -> Lisp_Object,
    >,
    pub a8: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: Lisp_Object,
            arg2: Lisp_Object,
            arg3: Lisp_Object,
            arg4: Lisp_Object,
            arg5: Lisp_Object,
            arg6: Lisp_Object,
            arg7: Lisp_Object,
            arg8: Lisp_Object,
        ) -> Lisp_Object,
    >,
    pub aUNEVALLED: ::std::option::Option<unsafe extern "C" fn(args: Lisp_Object) -> Lisp_Object>,
    pub aMANY: ::std::option::Option<
        unsafe extern "C" fn(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object,
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Lisp_Subr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Subr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(Lisp_Subr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Subr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Subr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_1>())).a0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_1),
            "::",
            stringify!(a0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_1>())).a1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_1),
            "::",
            stringify!(a1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_1>())).a2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_1),
            "::",
            stringify!(a2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_1>())).a3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_1),
            "::",
            stringify!(a3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_1>())).a4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_1),
            "::",
            stringify!(a4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_1>())).a5 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_1),
            "::",
            stringify!(a5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_1>())).a6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_1),
            "::",
            stringify!(a6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_1>())).a7 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_1),
            "::",
            stringify!(a7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_1>())).a8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_1),
            "::",
            stringify!(a8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_1>())).aUNEVALLED as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_1),
            "::",
            stringify!(aUNEVALLED)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_1>())).aMANY as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_1),
            "::",
            stringify!(aMANY)
        )
    );
}
impl Default for Lisp_Subr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(8))]
pub union Lisp_Subr__bindgen_ty_2 {
    pub intspec: *const ::libc::c_char,
    pub native_intspec: Lisp_Object,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Lisp_Subr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Subr__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(Lisp_Subr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Subr__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Subr__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_2>())).intspec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_2),
            "::",
            stringify!(intspec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Subr__bindgen_ty_2>())).native_intspec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr__bindgen_ty_2),
            "::",
            stringify!(native_intspec)
        )
    );
}
impl Default for Lisp_Subr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_Lisp_Subr() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Subr>(),
        80usize,
        concat!("Size of: ", stringify!(Lisp_Subr))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Subr>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Subr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr>())).function as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr>())).min_args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr),
            "::",
            stringify!(min_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr>())).max_args as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr),
            "::",
            stringify!(max_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr>())).symbol_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr),
            "::",
            stringify!(symbol_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr>())).doc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr),
            "::",
            stringify!(doc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr>())).native_comp_u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr),
            "::",
            stringify!(native_comp_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr>())).native_c_name as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr),
            "::",
            stringify!(native_c_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr>())).lambda_list as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr),
            "::",
            stringify!(lambda_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Subr>())).type_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Subr),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for Lisp_Subr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(8))]
pub struct Aligned_Lisp_Subr {
    pub s: __BindgenUnionField<Lisp_Subr>,
    pub gcaligned: __BindgenUnionField<::libc::c_char>,
    pub bindgen_union_field: [u64; 10usize],
}
#[test]
fn bindgen_test_layout_Aligned_Lisp_Subr() {
    assert_eq!(
        ::std::mem::size_of::<Aligned_Lisp_Subr>(),
        80usize,
        concat!("Size of: ", stringify!(Aligned_Lisp_Subr))
    );
    assert_eq!(
        ::std::mem::align_of::<Aligned_Lisp_Subr>(),
        8usize,
        concat!("Alignment of ", stringify!(Aligned_Lisp_Subr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aligned_Lisp_Subr>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aligned_Lisp_Subr),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aligned_Lisp_Subr>())).gcaligned as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aligned_Lisp_Subr),
            "::",
            stringify!(gcaligned)
        )
    );
}
impl Default for Aligned_Lisp_Subr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn SUBRP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XSUBR(a: Lisp_Object) -> *mut Lisp_Subr;
}
pub mod char_table_specials {
    pub type Type = u32;
    pub const CHAR_TABLE_STANDARD_SLOTS: Type = 68;
    pub const SUB_CHAR_TABLE_OFFSET: Type = 1;
}
extern "C" {
    pub fn CHAR_TABLE_EXTRA_SLOTS(ct: *mut Lisp_Char_Table) -> ::libc::c_int;
}
pub type sys_jmp_buf = jmp_buf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_registers {
    pub num_regs: isize,
    pub start: *mut isize,
    pub end: *mut isize,
}
#[test]
fn bindgen_test_layout_re_registers() {
    assert_eq!(
        ::std::mem::size_of::<re_registers>(),
        24usize,
        concat!("Size of: ", stringify!(re_registers))
    );
    assert_eq!(
        ::std::mem::align_of::<re_registers>(),
        8usize,
        concat!("Alignment of ", stringify!(re_registers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_registers>())).num_regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(re_registers),
            "::",
            stringify!(num_regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_registers>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(re_registers),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_registers>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(re_registers),
            "::",
            stringify!(end)
        )
    );
}
impl Default for re_registers {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}re_match_object"]
    pub static mut re_match_object: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}emacs_re_max_failures"]
    pub static mut emacs_re_max_failures: isize;
}
extern "C" {
    #[link_name = "\u{1}emacs_re_safe_alloca"]
    pub static mut emacs_re_safe_alloca: isize;
}
#[repr(C)]
pub struct re_pattern_buffer {
    pub buffer: *mut ::libc::c_uchar,
    pub allocated: isize,
    pub used: isize,
    pub charset_unibyte: ::libc::c_int,
    pub fastmap: *mut ::libc::c_char,
    pub translate: Lisp_Object,
    pub re_nsub: isize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_re_pattern_buffer() {
    assert_eq!(
        ::std::mem::size_of::<re_pattern_buffer>(),
        64usize,
        concat!("Size of: ", stringify!(re_pattern_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<re_pattern_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(re_pattern_buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).allocated as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).used as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<re_pattern_buffer>())).charset_unibyte as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(charset_unibyte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).fastmap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(fastmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).translate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(translate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).re_nsub as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(re_nsub)
        )
    );
}
impl Default for re_pattern_buffer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl re_pattern_buffer {
    #[inline]
    pub fn can_be_null(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_be_null(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn regs_allocated(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_regs_allocated(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fastmap_accurate(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fastmap_accurate(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn used_syntax(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_used_syntax(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn multibyte(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_multibyte(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn target_multibyte(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_target_multibyte(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        can_be_null: bool_bf,
        regs_allocated: ::libc::c_uint,
        fastmap_accurate: bool_bf,
        used_syntax: bool_bf,
        multibyte: bool_bf,
        target_multibyte: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_be_null: u8 = unsafe { ::std::mem::transmute(can_be_null) };
            can_be_null as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let regs_allocated: u32 = unsafe { ::std::mem::transmute(regs_allocated) };
            regs_allocated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fastmap_accurate: u8 = unsafe { ::std::mem::transmute(fastmap_accurate) };
            fastmap_accurate as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let used_syntax: u8 = unsafe { ::std::mem::transmute(used_syntax) };
            used_syntax as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let multibyte: u8 = unsafe { ::std::mem::transmute(multibyte) };
            multibyte as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let target_multibyte: u8 = unsafe { ::std::mem::transmute(target_multibyte) };
            target_multibyte as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn rpl_re_compile_pattern(
        pattern: *const ::libc::c_char,
        length: isize,
        posix_backtracking: bool,
        whitespace_regexp: *const ::libc::c_char,
        buffer: *mut re_pattern_buffer,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn rpl_re_search(
        buffer: *mut re_pattern_buffer,
        string: *const ::libc::c_char,
        length: isize,
        start: isize,
        range: isize,
        regs: *mut re_registers,
    ) -> isize;
}
extern "C" {
    pub fn rpl_re_search_2(
        buffer: *mut re_pattern_buffer,
        string1: *const ::libc::c_char,
        length1: isize,
        string2: *const ::libc::c_char,
        length2: isize,
        start: isize,
        range: isize,
        regs: *mut re_registers,
        stop: isize,
    ) -> isize;
}
extern "C" {
    pub fn rpl_re_match_2(
        buffer: *mut re_pattern_buffer,
        string1: *const ::libc::c_char,
        length1: isize,
        string2: *const ::libc::c_char,
        length2: isize,
        start: isize,
        regs: *mut re_registers,
        stop: isize,
    ) -> isize;
}
extern "C" {
    pub fn rpl_re_set_registers(
        buffer: *mut re_pattern_buffer,
        regs: *mut re_registers,
        num_regs: isize,
        starts: *mut isize,
        ends: *mut isize,
    );
}
pub mod re_wctype_t {
    pub type Type = u32;
    pub const RECC_ERROR: Type = 0;
    pub const RECC_ALNUM: Type = 1;
    pub const RECC_ALPHA: Type = 2;
    pub const RECC_WORD: Type = 3;
    pub const RECC_GRAPH: Type = 4;
    pub const RECC_PRINT: Type = 5;
    pub const RECC_LOWER: Type = 6;
    pub const RECC_UPPER: Type = 7;
    pub const RECC_PUNCT: Type = 8;
    pub const RECC_CNTRL: Type = 9;
    pub const RECC_DIGIT: Type = 10;
    pub const RECC_XDIGIT: Type = 11;
    pub const RECC_BLANK: Type = 12;
    pub const RECC_SPACE: Type = 13;
    pub const RECC_MULTIBYTE: Type = 14;
    pub const RECC_NONASCII: Type = 15;
    pub const RECC_ASCII: Type = 16;
    pub const RECC_UNIBYTE: Type = 17;
}
extern "C" {
    pub fn re_iswctype(ch: ::libc::c_int, cc: re_wctype_t::Type) -> bool;
}
extern "C" {
    pub fn re_wctype_parse(strp: *mut *const ::libc::c_uchar, limit: isize) -> re_wctype_t::Type;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type uint = ::libc::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::libc::c_long;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type __fd_mask = ::libc::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::libc::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::libc::c_int,
    pub __count: ::libc::c_uint,
    pub __owner: ::libc::c_int,
    pub __nusers: ::libc::c_uint,
    pub __kind: ::libc::c_int,
    pub __spins: ::libc::c_short,
    pub __elision: ::libc::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::libc::c_uint,
    pub __writers: ::libc::c_uint,
    pub __wrphase_futex: ::libc::c_uint,
    pub __writers_futex: ::libc::c_uint,
    pub __pad3: ::libc::c_uint,
    pub __pad4: ::libc::c_uint,
    pub __cur_writer: ::libc::c_int,
    pub __shared: ::libc::c_int,
    pub __rwelision: ::libc::c_schar,
    pub __pad1: [::libc::c_uchar; 7usize],
    pub __pad2: ::libc::c_ulong,
    pub __flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::libc::c_uint; 2usize],
    pub __g_size: [::libc::c_uint; 2usize],
    pub __g1_orig_size: ::libc::c_uint,
    pub __wrefs: ::libc::c_uint,
    pub __g_signals: [::libc::c_uint; 2usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::libc::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::libc::c_uint,
    pub __high: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::libc::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::libc::c_uint,
    pub __high: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __tss_t = ::libc::c_uint;
pub type __thrd_t = ::libc::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::libc::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::libc::c_ulong;
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::libc::c_char; 4usize],
    pub __align: ::libc::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::libc::c_char; 4usize],
    pub __align: ::libc::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_key_t = ::libc::c_uint;
pub type pthread_once_t = ::libc::c_int;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::libc::c_char; 56usize],
    pub __align: ::libc::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::libc::c_char; 40usize],
    pub __align: ::libc::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::libc::c_char; 48usize],
    pub __align: ::libc::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::libc::c_char; 56usize],
    pub __align: ::libc::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::libc::c_char; 8usize],
    pub __align: ::libc::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_spinlock_t = ::libc::c_int;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::libc::c_char; 32usize],
    pub __align: ::libc::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::libc::c_char; 4usize],
    pub __align: ::libc::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn fd_CLR(fd: ::libc::c_int, set: *mut fd_set);
}
extern "C" {
    pub fn fd_ISSET(fd: ::libc::c_int, set: *mut fd_set) -> bool;
}
extern "C" {
    pub fn fd_SET(fd: ::libc::c_int, set: *mut fd_set);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
extern "C" {
    pub fn clone(
        __fn: ::std::option::Option<
            unsafe extern "C" fn(__arg: *mut ::libc::c_void) -> ::libc::c_int,
        >,
        __child_stack: *mut ::libc::c_void,
        __flags: ::libc::c_int,
        __arg: *mut ::libc::c_void,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn unshare(__flags: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sched_getcpu() -> ::libc::c_int;
}
extern "C" {
    pub fn getcpu(arg1: *mut ::libc::c_uint, arg2: *mut ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    pub fn setns(__fd: ::libc::c_int, __nstype: ::libc::c_int) -> ::libc::c_int;
}
pub type __cpu_mask = ::libc::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::libc::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::libc::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::libc::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::libc::c_int,
        __param: *const sched_param,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::libc::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn sched_setaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sched_getaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::libc::c_int,
    pub tm_min: ::libc::c_int,
    pub tm_hour: ::libc::c_int,
    pub tm_mday: ::libc::c_int,
    pub tm_mon: ::libc::c_int,
    pub tm_year: ::libc::c_int,
    pub tm_wday: ::libc::c_int,
    pub tm_yday: ::libc::c_int,
    pub tm_isdst: ::libc::c_int,
    pub tm_gmtoff: ::libc::c_long,
    pub tm_zone: *const ::libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
impl Default for tm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
impl Default for itimerspec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::libc::c_char,
        __maxsize: usize,
        __format: *const ::libc::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        __s: *const ::libc::c_char,
        __fmt: *const ::libc::c_char,
        __tp: *mut tm,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::libc::c_char,
        __maxsize: usize,
        __format: *const ::libc::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strptime_l(
        __s: *const ::libc::c_char,
        __fmt: *const ::libc::c_char,
        __tp: *mut tm,
        __loc: locale_t,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}__tzname"]
    pub static mut __tzname: [*mut ::libc::c_char; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__daylight"]
    pub static mut __daylight: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__timezone"]
    pub static mut __timezone: ::libc::c_long;
}
extern "C" {
    #[link_name = "\u{1}tzname"]
    pub static mut tzname: [*mut ::libc::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "\u{1}daylight"]
    pub static mut daylight: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}timezone"]
    pub static mut timezone: ::libc::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::libc::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::libc::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}getdate_err"]
    pub static mut getdate_err: ::libc::c_int;
}
extern "C" {
    pub fn getdate(__string: *const ::libc::c_char) -> *mut tm;
}
extern "C" {
    pub fn getdate_r(__string: *const ::libc::c_char, __resbufp: *mut tm) -> ::libc::c_int;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct __time_t_must_be_integral {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout___time_t_must_be_integral() {
    assert_eq!(
        ::std::mem::size_of::<__time_t_must_be_integral>(),
        4usize,
        concat!("Size of: ", stringify!(__time_t_must_be_integral))
    );
    assert_eq!(
        ::std::mem::align_of::<__time_t_must_be_integral>(),
        4usize,
        concat!("Alignment of ", stringify!(__time_t_must_be_integral))
    );
}
impl __time_t_must_be_integral {
    #[inline]
    pub fn __floating_time_t_unsupported(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___floating_time_t_unsupported(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __floating_time_t_unsupported: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __floating_time_t_unsupported: u32 =
                unsafe { ::std::mem::transmute(__floating_time_t_unsupported) };
            __floating_time_t_unsupported as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm_zone {
    _unused: [u8; 0],
}
pub type timezone_t = *mut tm_zone;
extern "C" {
    pub fn tzalloc(__name: *const ::libc::c_char) -> timezone_t;
}
extern "C" {
    pub fn tzfree(__tz: timezone_t);
}
extern "C" {
    pub fn localtime_rz(__tz: timezone_t, __timer: *const time_t, __result: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn mktime_z(__tz: timezone_t, __result: *mut tm) -> time_t;
}
pub mod _bindgen_ty_7 {
    pub type Type = u32;
    pub const PTHREAD_CREATE_JOINABLE: Type = 0;
    pub const PTHREAD_CREATE_DETACHED: Type = 1;
}
pub mod _bindgen_ty_8 {
    pub type Type = u32;
    pub const PTHREAD_MUTEX_TIMED_NP: Type = 0;
    pub const PTHREAD_MUTEX_RECURSIVE_NP: Type = 1;
    pub const PTHREAD_MUTEX_ERRORCHECK_NP: Type = 2;
    pub const PTHREAD_MUTEX_ADAPTIVE_NP: Type = 3;
    pub const PTHREAD_MUTEX_NORMAL: Type = 0;
    pub const PTHREAD_MUTEX_RECURSIVE: Type = 1;
    pub const PTHREAD_MUTEX_ERRORCHECK: Type = 2;
    pub const PTHREAD_MUTEX_DEFAULT: Type = 0;
    pub const PTHREAD_MUTEX_FAST_NP: Type = 0;
}
pub mod _bindgen_ty_9 {
    pub type Type = u32;
    pub const PTHREAD_MUTEX_STALLED: Type = 0;
    pub const PTHREAD_MUTEX_STALLED_NP: Type = 0;
    pub const PTHREAD_MUTEX_ROBUST: Type = 1;
    pub const PTHREAD_MUTEX_ROBUST_NP: Type = 1;
}
pub mod _bindgen_ty_10 {
    pub type Type = u32;
    pub const PTHREAD_PRIO_NONE: Type = 0;
    pub const PTHREAD_PRIO_INHERIT: Type = 1;
    pub const PTHREAD_PRIO_PROTECT: Type = 2;
}
pub mod _bindgen_ty_11 {
    pub type Type = u32;
    pub const PTHREAD_RWLOCK_PREFER_READER_NP: Type = 0;
    pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: Type = 1;
    pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: Type = 2;
    pub const PTHREAD_RWLOCK_DEFAULT_NP: Type = 0;
}
pub mod _bindgen_ty_12 {
    pub type Type = u32;
    pub const PTHREAD_INHERIT_SCHED: Type = 0;
    pub const PTHREAD_EXPLICIT_SCHED: Type = 1;
}
pub mod _bindgen_ty_13 {
    pub type Type = u32;
    pub const PTHREAD_SCOPE_SYSTEM: Type = 0;
    pub const PTHREAD_SCOPE_PROCESS: Type = 1;
}
pub mod _bindgen_ty_14 {
    pub type Type = u32;
    pub const PTHREAD_PROCESS_PRIVATE: Type = 0;
    pub const PTHREAD_PROCESS_SHARED: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
    pub __arg: *mut ::libc::c_void,
    pub __canceltype: ::libc::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
impl Default for _pthread_cleanup_buffer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod _bindgen_ty_15 {
    pub type Type = u32;
    pub const PTHREAD_CANCEL_ENABLE: Type = 0;
    pub const PTHREAD_CANCEL_DISABLE: Type = 1;
}
pub mod _bindgen_ty_16 {
    pub type Type = u32;
    pub const PTHREAD_CANCEL_DEFERRED: Type = 0;
    pub const PTHREAD_CANCEL_ASYNCHRONOUS: Type = 1;
}
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void) -> *mut ::libc::c_void,
        >,
        __arg: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::libc::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_tryjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_timedjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::libc::c_void,
        __abstime: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_clockjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::libc::c_void,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::libc::c_void,
        __stacksize: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::libc::c_void,
        __stacksize: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setaffinity_np(
        __attr: *mut pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getaffinity_np(
        __attr: *const pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_getattr_default_np(__attr: *mut pthread_attr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setsigmask_np(
        __attr: *mut pthread_attr_t,
        sigmask: *const __sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getsigmask_np(
        __attr: *const pthread_attr_t,
        sigmask: *mut __sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_setattr_default_np(__attr: *const pthread_attr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_getattr_np(__th: pthread_t, __attr: *mut pthread_attr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::libc::c_int,
        __param: *const sched_param,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::libc::c_int,
        __param: *mut sched_param,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(__target_thread: pthread_t, __prio: ::libc::c_int)
        -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        __target_thread: pthread_t,
        __buf: *mut ::libc::c_char,
        __buflen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_setname_np(
        __target_thread: pthread_t,
        __name: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(__level: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_yield() -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_setaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_getaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::libc::c_int,
        __oldstate: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::libc::c_int,
        __oldtype: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::libc::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__cancel_jmp_buf_tag>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__cancel_jmp_buf_tag>())).__mask_was_saved as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::libc::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
impl Default for __pthread_unwind_buf_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
    pub __cancel_arg: *mut ::libc::c_void,
    pub __do_it: ::libc::c_int,
    pub __cancel_type: ::libc::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
impl Default for __pthread_cleanup_frame {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_register_cancel_defer(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel_restore(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_clocklock(
        __mutex: *mut pthread_mutex_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::libc::c_int,
        __old_ceiling: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent_np(__mutex: *mut pthread_mutex_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust_np(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust_np(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_clockrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_clockwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_cond_clockwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __clock_id: __clockid_t,
        __abstime: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::libc::c_int;
}
pub type sys_mutex_t = pthread_mutex_t;
pub type sys_cond_t = pthread_cond_t;
pub type sys_thread_t = pthread_t;
pub type thread_creation_function =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void) -> *mut ::libc::c_void>;
extern "C" {
    pub fn sys_mutex_init(arg1: *mut sys_mutex_t);
}
extern "C" {
    pub fn sys_mutex_lock(arg1: *mut sys_mutex_t);
}
extern "C" {
    pub fn sys_mutex_unlock(arg1: *mut sys_mutex_t);
}
extern "C" {
    pub fn sys_cond_init(arg1: *mut sys_cond_t);
}
extern "C" {
    pub fn sys_cond_wait(arg1: *mut sys_cond_t, arg2: *mut sys_mutex_t);
}
extern "C" {
    pub fn sys_cond_signal(arg1: *mut sys_cond_t);
}
extern "C" {
    pub fn sys_cond_broadcast(arg1: *mut sys_cond_t);
}
extern "C" {
    pub fn sys_cond_destroy(arg1: *mut sys_cond_t);
}
extern "C" {
    pub fn sys_thread_self() -> sys_thread_t;
}
extern "C" {
    pub fn sys_thread_equal(arg1: sys_thread_t, arg2: sys_thread_t) -> bool;
}
extern "C" {
    pub fn sys_thread_create(
        arg1: *mut sys_thread_t,
        arg2: thread_creation_function,
        arg3: *mut ::libc::c_void,
    ) -> bool;
}
extern "C" {
    pub fn sys_thread_yield();
}
extern "C" {
    pub fn sys_thread_set_name(arg1: *const ::libc::c_char);
}
#[repr(C)]
pub struct thread_state {
    pub header: vectorlike_header,
    pub m_last_thing_searched: Lisp_Object,
    pub m_saved_last_thing_searched: Lisp_Object,
    pub name: Lisp_Object,
    pub function: Lisp_Object,
    pub result: Lisp_Object,
    pub error_symbol: Lisp_Object,
    pub error_data: Lisp_Object,
    pub event_object: Lisp_Object,
    pub m_stack_bottom: *const ::libc::c_char,
    pub stack_top: *const ::libc::c_void,
    pub m_catchlist: *mut catchtag,
    pub m_handlerlist: *mut handler,
    pub m_handlerlist_sentinel: *mut handler,
    pub m_specpdl_size: isize,
    pub m_specpdl: *mut specbinding,
    pub m_specpdl_ptr: *mut specbinding,
    pub m_lisp_eval_depth: intmax_t,
    pub m_current_buffer: *mut buffer,
    pub m_search_regs: re_registers,
    pub m_saved_search_regs: re_registers,
    pub m_waiting_for_user_input_p: ::libc::c_int,
    pub m_waiting_for_input: bool,
    pub m_getcjmp: sys_jmp_buf,
    pub thread_id: sys_thread_t,
    pub thread_condvar: sys_cond_t,
    pub wait_condvar: *mut sys_cond_t,
    pub thread_name: *mut ::libc::c_char,
    pub not_holding_lock: ::libc::c_int,
    pub next_thread: *mut thread_state,
}
#[test]
fn bindgen_test_layout_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<thread_state>(),
        496usize,
        concat!("Size of: ", stringify!(thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_state>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<thread_state>())).m_last_thing_searched as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_last_thing_searched)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<thread_state>())).m_saved_last_thing_searched as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_saved_last_thing_searched)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).function as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).result as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).error_symbol as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(error_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).error_data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(error_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).event_object as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(event_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).m_stack_bottom as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_stack_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).stack_top as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(stack_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).m_catchlist as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_catchlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).m_handlerlist as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_handlerlist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<thread_state>())).m_handlerlist_sentinel as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_handlerlist_sentinel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).m_specpdl_size as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_specpdl_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).m_specpdl as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_specpdl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).m_specpdl_ptr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_specpdl_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).m_lisp_eval_depth as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_lisp_eval_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).m_current_buffer as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_current_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).m_search_regs as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_search_regs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<thread_state>())).m_saved_search_regs as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_saved_search_regs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<thread_state>())).m_waiting_for_user_input_p as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_waiting_for_user_input_p)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<thread_state>())).m_waiting_for_input as *const _ as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_waiting_for_input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).m_getcjmp as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(m_getcjmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).thread_id as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).thread_condvar as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(thread_condvar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).wait_condvar as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(wait_condvar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).thread_name as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(thread_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).not_holding_lock as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(not_holding_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_state>())).next_thread as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_state),
            "::",
            stringify!(next_thread)
        )
    );
}
impl Default for thread_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn THREADP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_THREAD(x: Lisp_Object);
}
extern "C" {
    pub fn XTHREAD(a: Lisp_Object) -> *mut thread_state;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lisp_mutex_t {
    pub owner: *mut thread_state,
    pub count: ::libc::c_uint,
    pub condition: sys_cond_t,
}
#[test]
fn bindgen_test_layout_lisp_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<lisp_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(lisp_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lisp_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lisp_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lisp_mutex_t>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lisp_mutex_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lisp_mutex_t>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lisp_mutex_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lisp_mutex_t>())).condition as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lisp_mutex_t),
            "::",
            stringify!(condition)
        )
    );
}
impl Default for lisp_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct Lisp_Mutex {
    pub header: vectorlike_header,
    pub name: Lisp_Object,
    pub mutex: lisp_mutex_t,
}
#[test]
fn bindgen_test_layout_Lisp_Mutex() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Mutex>(),
        80usize,
        concat!("Size of: ", stringify!(Lisp_Mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Mutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Mutex>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Mutex),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Mutex>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Mutex),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Mutex>())).mutex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Mutex),
            "::",
            stringify!(mutex)
        )
    );
}
impl Default for Lisp_Mutex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn MUTEXP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_MUTEX(x: Lisp_Object);
}
extern "C" {
    pub fn XMUTEX(a: Lisp_Object) -> *mut Lisp_Mutex;
}
#[repr(C)]
pub struct Lisp_CondVar {
    pub header: vectorlike_header,
    pub mutex: Lisp_Object,
    pub name: Lisp_Object,
    pub cond: sys_cond_t,
}
#[test]
fn bindgen_test_layout_Lisp_CondVar() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_CondVar>(),
        72usize,
        concat!("Size of: ", stringify!(Lisp_CondVar))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_CondVar>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_CondVar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_CondVar>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_CondVar),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_CondVar>())).mutex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_CondVar),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_CondVar>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_CondVar),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_CondVar>())).cond as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_CondVar),
            "::",
            stringify!(cond)
        )
    );
}
impl Default for Lisp_CondVar {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn CONDVARP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_CONDVAR(x: Lisp_Object);
}
extern "C" {
    pub fn XCONDVAR(a: Lisp_Object) -> *mut Lisp_CondVar;
}
extern "C" {
    #[link_name = "\u{1}current_thread"]
    pub static mut current_thread: *mut thread_state;
}
extern "C" {
    pub fn finalize_one_thread(state: *mut thread_state);
}
extern "C" {
    pub fn finalize_one_mutex(arg1: *mut Lisp_Mutex);
}
extern "C" {
    pub fn finalize_one_condvar(arg1: *mut Lisp_CondVar);
}
extern "C" {
    pub fn maybe_reacquire_global_lock();
}
extern "C" {
    pub fn init_threads();
}
extern "C" {
    pub fn syms_of_threads();
}
extern "C" {
    pub fn main_thread_p(arg1: *const ::libc::c_void) -> bool;
}
extern "C" {
    pub fn in_current_thread() -> bool;
}
pub type select_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::libc::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn thread_select(
        func: select_func,
        max_fds: ::libc::c_int,
        rfds: *mut fd_set,
        wfds: *mut fd_set,
        efds: *mut fd_set,
        timeout: *mut timespec,
        sigmask: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn thread_check_current_buffer(arg1: *mut buffer) -> bool;
}
extern "C" {
    #[doc = "Symbols"]
    pub fn SYMBOL_VAL(sym: *mut Lisp_Symbol) -> Lisp_Object;
}
extern "C" {
    pub fn SYMBOL_ALIAS(sym: *mut Lisp_Symbol) -> *mut Lisp_Symbol;
}
extern "C" {
    pub fn SYMBOL_BLV(sym: *mut Lisp_Symbol) -> *mut Lisp_Buffer_Local_Value;
}
extern "C" {
    pub fn SYMBOL_FWD(sym: *mut Lisp_Symbol) -> lispfwd;
}
extern "C" {
    pub fn SET_SYMBOL_VAL(sym: *mut Lisp_Symbol, v: Lisp_Object);
}
extern "C" {
    pub fn SET_SYMBOL_ALIAS(sym: *mut Lisp_Symbol, v: *mut Lisp_Symbol);
}
extern "C" {
    pub fn SET_SYMBOL_BLV(sym: *mut Lisp_Symbol, v: *mut Lisp_Buffer_Local_Value);
}
extern "C" {
    pub fn SET_SYMBOL_FWD(sym: *mut Lisp_Symbol, v: *const ::libc::c_void);
}
extern "C" {
    pub fn SYMBOL_NAME(sym: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn SYMBOL_INTERNED_P(sym: Lisp_Object) -> bool;
}
extern "C" {
    pub fn SYMBOL_INTERNED_IN_INITIAL_OBARRAY_P(sym: Lisp_Object) -> bool;
}
extern "C" {
    pub fn SYMBOL_TRAPPED_WRITE_P(sym: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    pub fn SYMBOL_CONSTANT_P(sym: Lisp_Object) -> ::libc::c_int;
}
#[repr(C)]
pub struct hash_table_test {
    pub name: Lisp_Object,
    pub user_hash_function: Lisp_Object,
    pub user_cmp_function: Lisp_Object,
    pub cmpfn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: Lisp_Object,
            arg2: Lisp_Object,
            arg3: *mut Lisp_Hash_Table,
        ) -> Lisp_Object,
    >,
    pub hashfn: ::std::option::Option<
        unsafe extern "C" fn(arg1: Lisp_Object, arg2: *mut Lisp_Hash_Table) -> Lisp_Object,
    >,
}
#[test]
fn bindgen_test_layout_hash_table_test() {
    assert_eq!(
        ::std::mem::size_of::<hash_table_test>(),
        40usize,
        concat!("Size of: ", stringify!(hash_table_test))
    );
    assert_eq!(
        ::std::mem::align_of::<hash_table_test>(),
        8usize,
        concat!("Alignment of ", stringify!(hash_table_test))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hash_table_test>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_table_test),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hash_table_test>())).user_hash_function as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_table_test),
            "::",
            stringify!(user_hash_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hash_table_test>())).user_cmp_function as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_table_test),
            "::",
            stringify!(user_cmp_function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hash_table_test>())).cmpfn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_table_test),
            "::",
            stringify!(cmpfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hash_table_test>())).hashfn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_table_test),
            "::",
            stringify!(hashfn)
        )
    );
}
impl Default for hash_table_test {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "Hash Tables"]
#[repr(C)]
pub struct Lisp_Hash_Table {
    pub header: vectorlike_header,
    pub weak: Lisp_Object,
    pub hash: Lisp_Object,
    pub next: Lisp_Object,
    pub index: Lisp_Object,
    pub count: isize,
    pub next_free: isize,
    pub purecopy: bool,
    pub mutable: bool,
    pub rehash_threshold: f32,
    pub rehash_size: f32,
    pub key_and_value: Lisp_Object,
    pub test: hash_table_test,
    pub next_weak: *mut Lisp_Hash_Table,
}
#[test]
fn bindgen_test_layout_Lisp_Hash_Table() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Hash_Table>(),
        128usize,
        concat!("Size of: ", stringify!(Lisp_Hash_Table))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Hash_Table>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Hash_Table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).weak as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(weak)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).index as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).count as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).next_free as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(next_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).purecopy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(purecopy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).mutable as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(mutable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Hash_Table>())).rehash_threshold as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(rehash_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).rehash_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(rehash_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).key_and_value as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(key_and_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).test as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(test)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Hash_Table>())).next_weak as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Hash_Table),
            "::",
            stringify!(next_weak)
        )
    );
}
impl Default for Lisp_Hash_Table {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn HASH_TABLE_P(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XHASH_TABLE(a: Lisp_Object) -> *mut Lisp_Hash_Table;
}
extern "C" {
    pub fn HASH_KEY(h: *const Lisp_Hash_Table, idx: isize) -> Lisp_Object;
}
extern "C" {
    pub fn HASH_VALUE(h: *const Lisp_Hash_Table, idx: isize) -> Lisp_Object;
}
extern "C" {
    pub fn HASH_HASH(h: *const Lisp_Hash_Table, idx: isize) -> Lisp_Object;
}
extern "C" {
    pub fn HASH_TABLE_SIZE(h: *const Lisp_Hash_Table) -> isize;
}
extern "C" {
    pub fn hash_table_rehash(arg1: Lisp_Object);
}
pub mod DEFAULT_HASH_SIZE {
    pub type Type = u32;
    pub const DEFAULT_HASH_SIZE: Type = 65;
}
pub const DEFAULT_REHASH_THRESHOLD: f32 = 0.8125;
pub const DEFAULT_REHASH_SIZE: f32 = 0.5;
extern "C" {
    pub fn sxhash_combine(x: EMACS_UINT, y: EMACS_UINT) -> EMACS_UINT;
}
extern "C" {
    pub fn SXHASH_REDUCE(x: EMACS_UINT) -> EMACS_UINT;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Lisp_Marker {
    pub header: vectorlike_header,
    pub buffer: *mut buffer,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub next: *mut Lisp_Marker,
    pub charpos: isize,
    pub bytepos: isize,
}
#[test]
fn bindgen_test_layout_Lisp_Marker() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Marker>(),
        48usize,
        concat!("Size of: ", stringify!(Lisp_Marker))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Marker>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Marker>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Marker),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Marker>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Marker),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Marker>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Marker),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Marker>())).charpos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Marker),
            "::",
            stringify!(charpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Marker>())).bytepos as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Marker),
            "::",
            stringify!(bytepos)
        )
    );
}
impl Default for Lisp_Marker {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl Lisp_Marker {
    #[inline]
    pub fn need_adjustment(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_need_adjustment(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn insertion_type(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_insertion_type(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        need_adjustment: bool_bf,
        insertion_type: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let need_adjustment: u8 = unsafe { ::std::mem::transmute(need_adjustment) };
            need_adjustment as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let insertion_type: u8 = unsafe { ::std::mem::transmute(insertion_type) };
            insertion_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct Lisp_Overlay {
    pub header: vectorlike_header,
    pub start: Lisp_Object,
    pub end: Lisp_Object,
    pub plist: Lisp_Object,
    pub next: *mut Lisp_Overlay,
}
#[test]
fn bindgen_test_layout_Lisp_Overlay() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Overlay>(),
        40usize,
        concat!("Size of: ", stringify!(Lisp_Overlay))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Overlay>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Overlay))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Overlay>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Overlay),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Overlay>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Overlay),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Overlay>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Overlay),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Overlay>())).plist as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Overlay),
            "::",
            stringify!(plist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Overlay>())).next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Overlay),
            "::",
            stringify!(next)
        )
    );
}
impl Default for Lisp_Overlay {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Lisp_Misc_Ptr {
    pub header: vectorlike_header,
    pub pointer: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_Lisp_Misc_Ptr() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Misc_Ptr>(),
        16usize,
        concat!("Size of: ", stringify!(Lisp_Misc_Ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Misc_Ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Misc_Ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Misc_Ptr>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Misc_Ptr),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Misc_Ptr>())).pointer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Misc_Ptr),
            "::",
            stringify!(pointer)
        )
    );
}
impl Default for Lisp_Misc_Ptr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn make_misc_ptr(arg1: *mut ::libc::c_void) -> Lisp_Object;
}
extern "C" {
    pub fn make_mint_ptr(a: *mut ::libc::c_void) -> Lisp_Object;
}
extern "C" {
    pub fn mint_ptrp(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn xmint_pointer(a: Lisp_Object) -> *mut ::libc::c_void;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Lisp_User_Ptr {
    pub header: vectorlike_header,
    pub finalizer: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
    pub p: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_Lisp_User_Ptr() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_User_Ptr>(),
        24usize,
        concat!("Size of: ", stringify!(Lisp_User_Ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_User_Ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_User_Ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_User_Ptr>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_User_Ptr),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_User_Ptr>())).finalizer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_User_Ptr),
            "::",
            stringify!(finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_User_Ptr>())).p as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_User_Ptr),
            "::",
            stringify!(p)
        )
    );
}
impl Default for Lisp_User_Ptr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct Lisp_Finalizer {
    pub header: vectorlike_header,
    pub function: Lisp_Object,
    pub prev: *mut Lisp_Finalizer,
    pub next: *mut Lisp_Finalizer,
}
#[test]
fn bindgen_test_layout_Lisp_Finalizer() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Finalizer>(),
        32usize,
        concat!("Size of: ", stringify!(Lisp_Finalizer))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Finalizer>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Finalizer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Finalizer>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Finalizer),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Finalizer>())).function as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Finalizer),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Finalizer>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Finalizer),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Finalizer>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Finalizer),
            "::",
            stringify!(next)
        )
    );
}
impl Default for Lisp_Finalizer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}finalizers"]
    pub static mut finalizers: Lisp_Finalizer;
}
extern "C" {
    #[link_name = "\u{1}doomed_finalizers"]
    pub static mut doomed_finalizers: Lisp_Finalizer;
}
extern "C" {
    pub fn FINALIZERP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XFINALIZER(a: Lisp_Object) -> *mut Lisp_Finalizer;
}
extern "C" {
    pub fn MARKERP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XMARKER(a: Lisp_Object) -> *mut Lisp_Marker;
}
extern "C" {
    pub fn OVERLAYP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XOVERLAY(a: Lisp_Object) -> *mut Lisp_Overlay;
}
extern "C" {
    pub fn USER_PTRP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XUSER_PTR(a: Lisp_Object) -> *mut Lisp_User_Ptr;
}
extern "C" {
    pub fn BIGNUMP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn INTEGERP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn make_int(n: intmax_t) -> Lisp_Object;
}
extern "C" {
    pub fn make_uint(n: uintmax_t) -> Lisp_Object;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Lisp_Intfwd {
    pub type_: Lisp_Fwd_Type::Type,
    pub intvar: *mut intmax_t,
}
#[test]
fn bindgen_test_layout_Lisp_Intfwd() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Intfwd>(),
        16usize,
        concat!("Size of: ", stringify!(Lisp_Intfwd))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Intfwd>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Intfwd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Intfwd>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Intfwd),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Intfwd>())).intvar as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Intfwd),
            "::",
            stringify!(intvar)
        )
    );
}
impl Default for Lisp_Intfwd {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Lisp_Boolfwd {
    pub type_: Lisp_Fwd_Type::Type,
    pub boolvar: *mut bool,
}
#[test]
fn bindgen_test_layout_Lisp_Boolfwd() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Boolfwd>(),
        16usize,
        concat!("Size of: ", stringify!(Lisp_Boolfwd))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Boolfwd>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Boolfwd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Boolfwd>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Boolfwd),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Boolfwd>())).boolvar as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Boolfwd),
            "::",
            stringify!(boolvar)
        )
    );
}
impl Default for Lisp_Boolfwd {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Lisp_Objfwd {
    pub type_: Lisp_Fwd_Type::Type,
    pub objvar: *mut Lisp_Object,
}
#[test]
fn bindgen_test_layout_Lisp_Objfwd() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Objfwd>(),
        16usize,
        concat!("Size of: ", stringify!(Lisp_Objfwd))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Objfwd>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Objfwd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Objfwd>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Objfwd),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Objfwd>())).objvar as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Objfwd),
            "::",
            stringify!(objvar)
        )
    );
}
impl Default for Lisp_Objfwd {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct Lisp_Buffer_Objfwd {
    pub type_: Lisp_Fwd_Type::Type,
    pub offset: ::libc::c_int,
    pub predicate: Lisp_Object,
}
#[test]
fn bindgen_test_layout_Lisp_Buffer_Objfwd() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Buffer_Objfwd>(),
        16usize,
        concat!("Size of: ", stringify!(Lisp_Buffer_Objfwd))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Buffer_Objfwd>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Buffer_Objfwd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Buffer_Objfwd>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Buffer_Objfwd),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Buffer_Objfwd>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Buffer_Objfwd),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Buffer_Objfwd>())).predicate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Buffer_Objfwd),
            "::",
            stringify!(predicate)
        )
    );
}
impl Default for Lisp_Buffer_Objfwd {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct Lisp_Buffer_Local_Value {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub fwd: lispfwd,
    pub where_: Lisp_Object,
    pub defcell: Lisp_Object,
    pub valcell: Lisp_Object,
}
#[test]
fn bindgen_test_layout_Lisp_Buffer_Local_Value() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Buffer_Local_Value>(),
        40usize,
        concat!("Size of: ", stringify!(Lisp_Buffer_Local_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Buffer_Local_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Buffer_Local_Value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Buffer_Local_Value>())).fwd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Buffer_Local_Value),
            "::",
            stringify!(fwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Buffer_Local_Value>())).where_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Buffer_Local_Value),
            "::",
            stringify!(where_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Buffer_Local_Value>())).defcell as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Buffer_Local_Value),
            "::",
            stringify!(defcell)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Buffer_Local_Value>())).valcell as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Buffer_Local_Value),
            "::",
            stringify!(valcell)
        )
    );
}
impl Default for Lisp_Buffer_Local_Value {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl Lisp_Buffer_Local_Value {
    #[inline]
    pub fn local_if_set(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_local_if_set(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn found(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_found(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        local_if_set: bool_bf,
        found: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let local_if_set: u8 = unsafe { ::std::mem::transmute(local_if_set) };
            local_if_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let found: u8 = unsafe { ::std::mem::transmute(found) };
            found as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Lisp_Kboard_Objfwd {
    pub type_: Lisp_Fwd_Type::Type,
    pub offset: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_Lisp_Kboard_Objfwd() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Kboard_Objfwd>(),
        8usize,
        concat!("Size of: ", stringify!(Lisp_Kboard_Objfwd))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Kboard_Objfwd>(),
        4usize,
        concat!("Alignment of ", stringify!(Lisp_Kboard_Objfwd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Kboard_Objfwd>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Kboard_Objfwd),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Kboard_Objfwd>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Kboard_Objfwd),
            "::",
            stringify!(offset)
        )
    );
}
impl Default for Lisp_Kboard_Objfwd {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn XFWDTYPE(a: lispfwd) -> Lisp_Fwd_Type::Type;
}
extern "C" {
    pub fn BUFFER_OBJFWDP(a: lispfwd) -> bool;
}
extern "C" {
    pub fn XBUFFER_OBJFWD(a: lispfwd) -> *const Lisp_Buffer_Objfwd;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Lisp_Float {
    pub u: Lisp_Float__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union Lisp_Float__bindgen_ty_1 {
    pub data: f64,
    pub chain: *mut Lisp_Float,
    pub gcaligned: ::libc::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Lisp_Float__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Float__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(Lisp_Float__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Float__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Float__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Float__bindgen_ty_1>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Float__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Float__bindgen_ty_1>())).chain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Float__bindgen_ty_1),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Float__bindgen_ty_1>())).gcaligned as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Float__bindgen_ty_1),
            "::",
            stringify!(gcaligned)
        )
    );
}
impl Default for Lisp_Float__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_Lisp_Float() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Float>(),
        8usize,
        concat!("Size of: ", stringify!(Lisp_Float))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Float>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Float))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Float>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Float),
            "::",
            stringify!(u)
        )
    );
}
impl Default for Lisp_Float {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn FLOATP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XFLOAT(a: Lisp_Object) -> *mut Lisp_Float;
}
extern "C" {
    pub fn XFLOAT_DATA(f: Lisp_Object) -> f64;
}
pub mod Lisp_Compiled {
    pub type Type = u32;
    pub const COMPILED_ARGLIST: Type = 0;
    pub const COMPILED_BYTECODE: Type = 1;
    pub const COMPILED_CONSTANTS: Type = 2;
    pub const COMPILED_STACK_DEPTH: Type = 3;
    pub const COMPILED_DOC_STRING: Type = 4;
    pub const COMPILED_INTERACTIVE: Type = 5;
}
pub mod char_bits {
    pub type Type = u32;
    pub const CHAR_ALT: Type = 4194304;
    pub const CHAR_SUPER: Type = 8388608;
    pub const CHAR_HYPER: Type = 16777216;
    pub const CHAR_SHIFT: Type = 33554432;
    pub const CHAR_CTL: Type = 67108864;
    pub const CHAR_META: Type = 134217728;
    pub const CHAR_MODIFIER_MASK: Type = 264241152;
    pub const CHARACTERBITS: Type = 22;
}
extern "C" {
    pub fn FIXNATP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XFIXNAT(a: Lisp_Object) -> EMACS_INT;
}
extern "C" {
    pub fn NUMBERP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn RANGED_FIXNUMP(lo: intmax_t, x: Lisp_Object, hi: intmax_t) -> bool;
}
extern "C" {
    pub fn AUTOLOADP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn WINDOW_CONFIGURATIONP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn COMPILEDP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn FRAMEP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn RECORDP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_RECORD(x: Lisp_Object);
}
extern "C" {
    pub fn IMAGEP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn ARRAYP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_LIST(x: Lisp_Object);
}
extern "C" {
    pub fn CHECK_LIST_END(x: Lisp_Object, y: Lisp_Object);
}
extern "C" {
    pub fn CHECK_FIXNUM(x: Lisp_Object);
}
extern "C" {
    pub fn CHECK_STRING_CAR(x: Lisp_Object);
}
extern "C" {
    pub fn CHECK_VECTOR_OR_STRING(x: Lisp_Object) -> isize;
}
extern "C" {
    pub fn CHECK_ARRAY(x: Lisp_Object, predicate: Lisp_Object);
}
extern "C" {
    pub fn CHECK_FIXNAT(x: Lisp_Object);
}
extern "C" {
    pub fn XFLOATINT(n: Lisp_Object) -> f64;
}
extern "C" {
    pub fn CHECK_NUMBER(x: Lisp_Object);
}
extern "C" {
    pub fn CHECK_INTEGER(x: Lisp_Object);
}
extern "C" {
    pub fn CHECK_SUBR(x: Lisp_Object);
}
extern "C" {
    pub fn defsubr(arg1: *mut Aligned_Lisp_Subr);
}
pub mod maxargs {
    pub type Type = i32;
    pub const MANY: Type = -2;
    pub const UNEVALLED: Type = -1;
}
extern "C" {
    pub fn defvar_lisp(arg1: *const Lisp_Objfwd, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn defvar_lisp_nopro(arg1: *const Lisp_Objfwd, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn defvar_bool(arg1: *const Lisp_Boolfwd, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn defvar_int(arg1: *const Lisp_Intfwd, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn defvar_kboard(arg1: *const Lisp_Kboard_Objfwd, arg2: *const ::libc::c_char);
}
pub mod specbind_tag {
    pub type Type = u32;
    pub const SPECPDL_UNWIND: Type = 0;
    pub const SPECPDL_UNWIND_ARRAY: Type = 1;
    pub const SPECPDL_UNWIND_PTR: Type = 2;
    pub const SPECPDL_UNWIND_INT: Type = 3;
    pub const SPECPDL_UNWIND_INTMAX: Type = 4;
    pub const SPECPDL_UNWIND_EXCURSION: Type = 5;
    pub const SPECPDL_UNWIND_VOID: Type = 6;
    pub const SPECPDL_BACKTRACE: Type = 7;
    pub const SPECPDL_MODULE_RUNTIME: Type = 8;
    pub const SPECPDL_MODULE_ENVIRONMENT: Type = 9;
    pub const SPECPDL_LET: Type = 10;
    pub const SPECPDL_LET_LOCAL: Type = 11;
    pub const SPECPDL_LET_DEFAULT: Type = 12;
}
#[repr(C)]
#[repr(align(8))]
pub struct specbinding {
    pub _bitfield_1: __BindgenUnionField<__BindgenBitfieldUnit<[u8; 1usize], u8>>,
    pub unwind: __BindgenUnionField<specbinding__bindgen_ty_1>,
    pub unwind_array: __BindgenUnionField<specbinding__bindgen_ty_2>,
    pub unwind_ptr: __BindgenUnionField<specbinding__bindgen_ty_3>,
    pub unwind_int: __BindgenUnionField<specbinding__bindgen_ty_4>,
    pub unwind_intmax: __BindgenUnionField<specbinding__bindgen_ty_5>,
    pub unwind_excursion: __BindgenUnionField<specbinding__bindgen_ty_6>,
    pub unwind_void: __BindgenUnionField<specbinding__bindgen_ty_7>,
    pub let_: __BindgenUnionField<specbinding__bindgen_ty_8>,
    pub bt: __BindgenUnionField<specbinding__bindgen_ty_9>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
pub struct specbinding__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub func: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object)>,
    pub arg: Lisp_Object,
    pub eval_depth: EMACS_INT,
}
#[test]
fn bindgen_test_layout_specbinding__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<specbinding__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(specbinding__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<specbinding__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(specbinding__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_1>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_1),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_1>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_1),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<specbinding__bindgen_ty_1>())).eval_depth as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_1),
            "::",
            stringify!(eval_depth)
        )
    );
}
impl Default for specbinding__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl specbinding__bindgen_ty_1 {
    #[inline]
    pub fn kind(&self) -> specbind_tag::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: specbind_tag::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(kind: specbind_tag::Type) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct specbinding__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub nelts: isize,
    pub array: *mut Lisp_Object,
}
#[test]
fn bindgen_test_layout_specbinding__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<specbinding__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(specbinding__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<specbinding__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(specbinding__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_2>())).nelts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_2),
            "::",
            stringify!(nelts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_2>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_2),
            "::",
            stringify!(array)
        )
    );
}
impl Default for specbinding__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl specbinding__bindgen_ty_2 {
    #[inline]
    pub fn kind(&self) -> specbind_tag::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: specbind_tag::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(kind: specbind_tag::Type) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct specbinding__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
    pub arg: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_specbinding__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<specbinding__bindgen_ty_3>(),
        24usize,
        concat!("Size of: ", stringify!(specbinding__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<specbinding__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(specbinding__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_3>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_3),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_3>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_3),
            "::",
            stringify!(arg)
        )
    );
}
impl Default for specbinding__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl specbinding__bindgen_ty_3 {
    #[inline]
    pub fn kind(&self) -> specbind_tag::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: specbind_tag::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(kind: specbind_tag::Type) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct specbinding__bindgen_ty_4 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub func: ::std::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    pub arg: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_specbinding__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<specbinding__bindgen_ty_4>(),
        24usize,
        concat!("Size of: ", stringify!(specbinding__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<specbinding__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(specbinding__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_4>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_4),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_4>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_4),
            "::",
            stringify!(arg)
        )
    );
}
impl Default for specbinding__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl specbinding__bindgen_ty_4 {
    #[inline]
    pub fn kind(&self) -> specbind_tag::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: specbind_tag::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(kind: specbind_tag::Type) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct specbinding__bindgen_ty_5 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub func: ::std::option::Option<unsafe extern "C" fn(arg1: intmax_t)>,
    pub arg: intmax_t,
}
#[test]
fn bindgen_test_layout_specbinding__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<specbinding__bindgen_ty_5>(),
        24usize,
        concat!("Size of: ", stringify!(specbinding__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<specbinding__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(specbinding__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_5>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_5),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_5>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_5),
            "::",
            stringify!(arg)
        )
    );
}
impl Default for specbinding__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl specbinding__bindgen_ty_5 {
    #[inline]
    pub fn kind(&self) -> specbind_tag::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: specbind_tag::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(kind: specbind_tag::Type) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct specbinding__bindgen_ty_6 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub marker: Lisp_Object,
    pub window: Lisp_Object,
}
#[test]
fn bindgen_test_layout_specbinding__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<specbinding__bindgen_ty_6>(),
        24usize,
        concat!("Size of: ", stringify!(specbinding__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<specbinding__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(specbinding__bindgen_ty_6))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<specbinding__bindgen_ty_6>())).marker as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_6),
            "::",
            stringify!(marker)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<specbinding__bindgen_ty_6>())).window as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_6),
            "::",
            stringify!(window)
        )
    );
}
impl Default for specbinding__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl specbinding__bindgen_ty_6 {
    #[inline]
    pub fn kind(&self) -> specbind_tag::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: specbind_tag::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(kind: specbind_tag::Type) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct specbinding__bindgen_ty_7 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub func: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_specbinding__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<specbinding__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(specbinding__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<specbinding__bindgen_ty_7>(),
        8usize,
        concat!("Alignment of ", stringify!(specbinding__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_7>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_7),
            "::",
            stringify!(func)
        )
    );
}
impl Default for specbinding__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl specbinding__bindgen_ty_7 {
    #[inline]
    pub fn kind(&self) -> specbind_tag::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: specbind_tag::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(kind: specbind_tag::Type) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct specbinding__bindgen_ty_8 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub symbol: Lisp_Object,
    pub old_value: Lisp_Object,
    pub where_: Lisp_Object,
    pub saved_value: Lisp_Object,
}
#[test]
fn bindgen_test_layout_specbinding__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<specbinding__bindgen_ty_8>(),
        40usize,
        concat!("Size of: ", stringify!(specbinding__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<specbinding__bindgen_ty_8>(),
        8usize,
        concat!("Alignment of ", stringify!(specbinding__bindgen_ty_8))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<specbinding__bindgen_ty_8>())).symbol as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_8),
            "::",
            stringify!(symbol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<specbinding__bindgen_ty_8>())).old_value as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_8),
            "::",
            stringify!(old_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<specbinding__bindgen_ty_8>())).where_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_8),
            "::",
            stringify!(where_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<specbinding__bindgen_ty_8>())).saved_value as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_8),
            "::",
            stringify!(saved_value)
        )
    );
}
impl Default for specbinding__bindgen_ty_8 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl specbinding__bindgen_ty_8 {
    #[inline]
    pub fn kind(&self) -> specbind_tag::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: specbind_tag::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(kind: specbind_tag::Type) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct specbinding__bindgen_ty_9 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub function: Lisp_Object,
    pub args: *mut Lisp_Object,
    pub nargs: isize,
}
#[test]
fn bindgen_test_layout_specbinding__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<specbinding__bindgen_ty_9>(),
        32usize,
        concat!("Size of: ", stringify!(specbinding__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<specbinding__bindgen_ty_9>(),
        8usize,
        concat!("Alignment of ", stringify!(specbinding__bindgen_ty_9))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<specbinding__bindgen_ty_9>())).function as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_9),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_9>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_9),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding__bindgen_ty_9>())).nargs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding__bindgen_ty_9),
            "::",
            stringify!(nargs)
        )
    );
}
impl Default for specbinding__bindgen_ty_9 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl specbinding__bindgen_ty_9 {
    #[inline]
    pub fn kind(&self) -> specbind_tag::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: specbind_tag::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn debug_on_exit(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_debug_on_exit(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        kind: specbind_tag::Type,
        debug_on_exit: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let debug_on_exit: u8 = unsafe { ::std::mem::transmute(debug_on_exit) };
            debug_on_exit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_specbinding() {
    assert_eq!(
        ::std::mem::size_of::<specbinding>(),
        40usize,
        concat!("Size of: ", stringify!(specbinding))
    );
    assert_eq!(
        ::std::mem::align_of::<specbinding>(),
        8usize,
        concat!("Alignment of ", stringify!(specbinding))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding>())).unwind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding),
            "::",
            stringify!(unwind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding>())).unwind_array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding),
            "::",
            stringify!(unwind_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding>())).unwind_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding),
            "::",
            stringify!(unwind_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding>())).unwind_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding),
            "::",
            stringify!(unwind_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding>())).unwind_intmax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding),
            "::",
            stringify!(unwind_intmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding>())).unwind_excursion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding),
            "::",
            stringify!(unwind_excursion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding>())).unwind_void as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding),
            "::",
            stringify!(unwind_void)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding>())).let_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding),
            "::",
            stringify!(let_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<specbinding>())).bt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(specbinding),
            "::",
            stringify!(bt)
        )
    );
}
impl Default for specbinding {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl specbinding {
    #[inline]
    pub fn kind(&self) -> specbind_tag::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.as_ref().get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: specbind_tag::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.as_mut().set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(kind: specbind_tag::Type) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn SPECPDL_INDEX() -> isize;
}
pub mod handlertype {
    pub type Type = u32;
    pub const CATCHER: Type = 0;
    pub const CONDITION_CASE: Type = 1;
    pub const CATCHER_ALL: Type = 2;
}
pub mod nonlocal_exit {
    pub type Type = u32;
    pub const NONLOCAL_EXIT_SIGNAL: Type = 0;
    pub const NONLOCAL_EXIT_THROW: Type = 1;
}
#[repr(C)]
pub struct handler {
    pub type_: handlertype::Type,
    pub tag_or_ch: Lisp_Object,
    pub nonlocal_exit: nonlocal_exit::Type,
    pub val: Lisp_Object,
    pub next: *mut handler,
    pub nextfree: *mut handler,
    pub bytecode_top: *mut Lisp_Object,
    pub bytecode_dest: ::libc::c_int,
    pub jmp: sys_jmp_buf,
    pub f_lisp_eval_depth: EMACS_INT,
    pub pdlcount: isize,
    pub poll_suppress_count: ::libc::c_int,
    pub interrupt_input_blocked: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_handler() {
    assert_eq!(
        ::std::mem::size_of::<handler>(),
        288usize,
        concat!("Size of: ", stringify!(handler))
    );
    assert_eq!(
        ::std::mem::align_of::<handler>(),
        8usize,
        concat!("Alignment of ", stringify!(handler))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).tag_or_ch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(tag_or_ch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).nonlocal_exit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(nonlocal_exit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).val as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).nextfree as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(nextfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).bytecode_top as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(bytecode_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).bytecode_dest as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(bytecode_dest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).jmp as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(jmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).f_lisp_eval_depth as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(f_lisp_eval_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).pdlcount as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(pdlcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).poll_suppress_count as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(poll_suppress_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<handler>())).interrupt_input_blocked as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(handler),
            "::",
            stringify!(interrupt_input_blocked)
        )
    );
}
impl Default for handler {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}memory_signal_data"]
    pub static mut memory_signal_data: Lisp_Object;
}
extern "C" {
    pub fn maybe_quit();
}
extern "C" {
    pub fn rarely_quit(count: ::libc::c_ushort);
}
extern "C" {
    #[link_name = "\u{1}Vascii_downcase_table"]
    pub static mut Vascii_downcase_table: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}Vascii_canon_table"]
    pub static mut Vascii_canon_table: Lisp_Object;
}
extern "C" {
    pub fn staticpro(arg1: *const Lisp_Object);
}
pub mod _bindgen_ty_17 {
    pub type Type = u32;
    pub const NSTATICS: Type = 2048;
}
extern "C" {
    #[link_name = "\u{1}staticvec"]
    pub static mut staticvec: [*const Lisp_Object; 2048usize];
}
extern "C" {
    #[link_name = "\u{1}staticidx"]
    pub static mut staticidx: ::libc::c_int;
}
extern "C" {
    pub fn xvector_contents_addr(a: Lisp_Object, i: isize) -> *mut Lisp_Object;
}
extern "C" {
    pub fn xvector_contents(a: Lisp_Object) -> *mut Lisp_Object;
}
extern "C" {
    pub fn vcopy(v: Lisp_Object, offset: isize, args: *const Lisp_Object, count: isize);
}
extern "C" {
    pub fn set_hash_key_slot(h: *mut Lisp_Hash_Table, idx: isize, val: Lisp_Object);
}
extern "C" {
    pub fn set_hash_value_slot(h: *mut Lisp_Hash_Table, idx: isize, val: Lisp_Object);
}
extern "C" {
    pub fn set_symbol_function(sym: Lisp_Object, function: Lisp_Object);
}
extern "C" {
    pub fn set_symbol_plist(sym: Lisp_Object, plist: Lisp_Object);
}
extern "C" {
    pub fn set_symbol_next(sym: Lisp_Object, next: *mut Lisp_Symbol);
}
extern "C" {
    pub fn make_symbol_constant(sym: Lisp_Object);
}
extern "C" {
    pub fn blv_found(blv: *mut Lisp_Buffer_Local_Value) -> ::libc::c_int;
}
extern "C" {
    pub fn set_overlay_plist(overlay: Lisp_Object, plist: Lisp_Object);
}
extern "C" {
    pub fn string_intervals(s: Lisp_Object) -> INTERVAL;
}
extern "C" {
    pub fn set_string_intervals(s: Lisp_Object, i: INTERVAL);
}
extern "C" {
    pub fn set_char_table_defalt(table: Lisp_Object, val: Lisp_Object);
}
extern "C" {
    pub fn set_char_table_purpose(table: Lisp_Object, val: Lisp_Object);
}
extern "C" {
    pub fn set_char_table_extras(table: Lisp_Object, idx: isize, val: Lisp_Object);
}
extern "C" {
    pub fn set_char_table_contents(table: Lisp_Object, idx: isize, val: Lisp_Object);
}
extern "C" {
    pub fn bignum_to_intmax(arg1: Lisp_Object) -> intmax_t;
}
extern "C" {
    pub fn bignum_to_uintmax(arg1: Lisp_Object) -> uintmax_t;
}
extern "C" {
    pub fn bignum_bufsize(arg1: Lisp_Object, arg2: ::libc::c_int) -> isize;
}
extern "C" {
    pub fn bignum_to_c_string(
        arg1: *mut ::libc::c_char,
        arg2: isize,
        arg3: Lisp_Object,
        arg4: ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn bignum_to_string(arg1: Lisp_Object, arg2: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn make_bignum_str(arg1: *const ::libc::c_char, arg2: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn make_neg_biguint(arg1: uintmax_t) -> Lisp_Object;
}
extern "C" {
    pub fn double_to_integer(arg1: f64) -> Lisp_Object;
}
extern "C" {
    pub fn integer_to_intmax(num: Lisp_Object, n: *mut intmax_t) -> bool;
}
extern "C" {
    pub fn integer_to_uintmax(num: Lisp_Object, n: *mut uintmax_t) -> bool;
}
pub type modiff_count = intmax_t;
extern "C" {
    pub fn modiff_incr(a: *mut modiff_count) -> modiff_count;
}
extern "C" {
    pub fn modiff_to_integer(a: modiff_count) -> Lisp_Object;
}
extern "C" {
    pub fn notify_variable_watchers(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    );
}
extern "C" {
    pub fn indirect_function(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn find_symbol_value(arg1: Lisp_Object) -> Lisp_Object;
}
pub mod Arith_Comparison {
    pub type Type = u32;
    pub const ARITH_EQUAL: Type = 0;
    pub const ARITH_NOTEQUAL: Type = 1;
    pub const ARITH_LESS: Type = 2;
    pub const ARITH_GRTR: Type = 3;
    pub const ARITH_LESS_OR_EQUAL: Type = 4;
    pub const ARITH_GRTR_OR_EQUAL: Type = 5;
}
extern "C" {
    pub fn arithcompare(
        num1: Lisp_Object,
        num2: Lisp_Object,
        comparison: Arith_Comparison::Type,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn cons_to_signed(arg1: Lisp_Object, arg2: intmax_t, arg3: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn cons_to_unsigned(arg1: Lisp_Object, arg2: uintmax_t) -> uintmax_t;
}
extern "C" {
    pub fn indirect_variable(arg1: *mut Lisp_Symbol) -> *mut Lisp_Symbol;
}
extern "C" {
    pub fn args_out_of_range(arg1: Lisp_Object, arg2: Lisp_Object);
}
extern "C" {
    pub fn do_symval_forwarding(arg1: lispfwd) -> Lisp_Object;
}
pub mod Set_Internal_Bind {
    pub type Type = u32;
    pub const SET_INTERNAL_SET: Type = 0;
    pub const SET_INTERNAL_BIND: Type = 1;
    pub const SET_INTERNAL_UNBIND: Type = 2;
    pub const SET_INTERNAL_THREAD_SWITCH: Type = 3;
}
extern "C" {
    pub fn set_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Set_Internal_Bind::Type,
    );
}
extern "C" {
    pub fn set_default_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        bindflag: Set_Internal_Bind::Type,
    );
}
extern "C" {
    pub fn expt_integer(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn syms_of_data();
}
extern "C" {
    pub fn swap_in_global_binding(arg1: *mut Lisp_Symbol);
}
extern "C" {
    pub fn syms_of_cmds();
}
extern "C" {
    pub fn detect_coding_system(
        arg1: *const ::libc::c_uchar,
        arg2: isize,
        arg3: isize,
        arg4: bool,
        arg5: bool,
        arg6: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn init_coding();
}
extern "C" {
    pub fn init_coding_once();
}
extern "C" {
    pub fn syms_of_coding();
}
extern "C" {
    pub fn chars_in_text(arg1: *const ::libc::c_uchar, arg2: isize) -> isize;
}
extern "C" {
    pub fn multibyte_chars_in_text(arg1: *const ::libc::c_uchar, arg2: isize) -> isize;
}
extern "C" {
    pub fn syms_of_character();
}
extern "C" {
    pub fn init_charset();
}
extern "C" {
    pub fn init_charset_once();
}
extern "C" {
    pub fn syms_of_charset();
}
extern "C" {
    pub fn init_syntax_once();
}
extern "C" {
    pub fn syms_of_syntax();
}
pub mod _bindgen_ty_18 {
    pub type Type = u32;
    pub const NEXT_ALMOST_PRIME_LIMIT: Type = 11;
}
extern "C" {
    pub fn list_length(arg1: Lisp_Object) -> isize;
}
extern "C" {
    pub fn next_almost_prime(arg1: EMACS_INT) -> EMACS_INT;
}
extern "C" {
    pub fn larger_vector(arg1: Lisp_Object, arg2: isize, arg3: isize) -> Lisp_Object;
}
extern "C" {
    pub fn sweep_weak_table(arg1: *mut Lisp_Hash_Table, arg2: bool) -> bool;
}
extern "C" {
    pub fn hexbuf_digest(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_void,
        arg3: ::libc::c_int,
    );
}
extern "C" {
    pub fn extract_data_from_object(
        arg1: Lisp_Object,
        arg2: *mut isize,
        arg3: *mut isize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn hash_string(arg1: *const ::libc::c_char, arg2: isize) -> EMACS_UINT;
}
extern "C" {
    pub fn sxhash(arg1: Lisp_Object) -> EMACS_UINT;
}
extern "C" {
    pub fn hashfn_eql(arg1: Lisp_Object, arg2: *mut Lisp_Hash_Table) -> Lisp_Object;
}
extern "C" {
    pub fn hashfn_equal(arg1: Lisp_Object, arg2: *mut Lisp_Hash_Table) -> Lisp_Object;
}
extern "C" {
    pub fn hashfn_user_defined(arg1: Lisp_Object, arg2: *mut Lisp_Hash_Table) -> Lisp_Object;
}
extern "C" {
    pub fn make_hash_table(
        arg1: hash_table_test,
        arg2: EMACS_INT,
        arg3: f32,
        arg4: f32,
        arg5: Lisp_Object,
        arg6: bool,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn hash_lookup(
        arg1: *mut Lisp_Hash_Table,
        arg2: Lisp_Object,
        arg3: *mut Lisp_Object,
    ) -> isize;
}
extern "C" {
    pub fn hash_put(
        arg1: *mut Lisp_Hash_Table,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> isize;
}
extern "C" {
    pub fn hash_remove_from_table(arg1: *mut Lisp_Hash_Table, arg2: Lisp_Object);
}
extern "C" {
    #[link_name = "\u{1}hashtest_eq"]
    pub static hashtest_eq: hash_table_test;
}
extern "C" {
    #[link_name = "\u{1}hashtest_eql"]
    pub static hashtest_eql: hash_table_test;
}
extern "C" {
    #[link_name = "\u{1}hashtest_equal"]
    pub static hashtest_equal: hash_table_test;
}
extern "C" {
    pub fn validate_subarray(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: isize,
        arg5: *mut isize,
        arg6: *mut isize,
    );
}
extern "C" {
    pub fn substring_both(
        arg1: Lisp_Object,
        arg2: isize,
        arg3: isize,
        arg4: isize,
        arg5: isize,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn merge(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn merge_c(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: Lisp_Object, arg2: Lisp_Object) -> bool,
        >,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn do_yes_or_no_p(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn string_version_cmp(arg1: Lisp_Object, arg2: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    pub fn concat2(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn concat3(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn equal_no_quit(arg1: Lisp_Object, arg2: Lisp_Object) -> bool;
}
extern "C" {
    pub fn nconc2(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn assq_no_quit(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn assoc_no_quit(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn clear_string_char_byte_cache();
}
extern "C" {
    pub fn string_char_to_byte(arg1: Lisp_Object, arg2: isize) -> isize;
}
extern "C" {
    pub fn string_byte_to_char(arg1: Lisp_Object, arg2: isize) -> isize;
}
extern "C" {
    pub fn string_to_multibyte(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn string_make_unibyte(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn syms_of_fns();
}
pub mod _bindgen_ty_19 {
    pub type Type = u32;
    pub const LOG2_FLT_RADIX: Type = 1;
}
extern "C" {
    pub fn double_integer_scale(arg1: f64) -> ::libc::c_int;
}
extern "C" {
    pub fn fmod_float(x: Lisp_Object, y: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn syms_of_floatfns();
}
extern "C" {
    pub fn syms_of_fringe();
}
extern "C" {
    pub fn init_fringe();
}
extern "C" {
    pub fn mark_fringe_data();
}
extern "C" {
    pub fn init_fringe_once();
}
extern "C" {
    pub fn x_bitmap_mask(arg1: *mut frame, arg2: isize) -> ::libc::c_int;
}
extern "C" {
    pub fn syms_of_image();
}
extern "C" {
    pub fn init_json();
}
extern "C" {
    pub fn syms_of_json();
}
extern "C" {
    pub fn move_gap_both(arg1: isize, arg2: isize);
}
extern "C" {
    pub fn buffer_overflow();
}
extern "C" {
    pub fn make_gap(arg1: isize);
}
extern "C" {
    pub fn make_gap_1(arg1: *mut buffer, arg2: isize);
}
extern "C" {
    pub fn copy_text(
        arg1: *const ::libc::c_uchar,
        arg2: *mut ::libc::c_uchar,
        arg3: isize,
        arg4: bool,
        arg5: bool,
    ) -> isize;
}
extern "C" {
    pub fn count_combining_before(
        arg1: *const ::libc::c_uchar,
        arg2: isize,
        arg3: isize,
        arg4: isize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn count_combining_after(
        arg1: *const ::libc::c_uchar,
        arg2: isize,
        arg3: isize,
        arg4: isize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn insert(arg1: *const ::libc::c_char, arg2: isize);
}
extern "C" {
    pub fn insert_and_inherit(arg1: *const ::libc::c_char, arg2: isize);
}
extern "C" {
    pub fn insert_1_both(
        arg1: *const ::libc::c_char,
        arg2: isize,
        arg3: isize,
        arg4: bool,
        arg5: bool,
        arg6: bool,
    );
}
extern "C" {
    pub fn insert_from_gap_1(arg1: isize, arg2: isize, text_at_gap_tail: bool);
}
extern "C" {
    pub fn insert_from_gap(arg1: isize, arg2: isize, text_at_gap_tail: bool);
}
extern "C" {
    pub fn insert_from_string(
        arg1: Lisp_Object,
        arg2: isize,
        arg3: isize,
        arg4: isize,
        arg5: isize,
        arg6: bool,
    );
}
extern "C" {
    pub fn insert_from_buffer(arg1: *mut buffer, arg2: isize, arg3: isize, arg4: bool);
}
extern "C" {
    pub fn insert_char(arg1: ::libc::c_int);
}
extern "C" {
    pub fn insert_string(arg1: *const ::libc::c_char);
}
extern "C" {
    pub fn insert_before_markers(arg1: *const ::libc::c_char, arg2: isize);
}
extern "C" {
    pub fn insert_before_markers_and_inherit(arg1: *const ::libc::c_char, arg2: isize);
}
extern "C" {
    pub fn insert_from_string_before_markers(
        arg1: Lisp_Object,
        arg2: isize,
        arg3: isize,
        arg4: isize,
        arg5: isize,
        arg6: bool,
    );
}
extern "C" {
    pub fn del_range(arg1: isize, arg2: isize);
}
extern "C" {
    pub fn del_range_1(arg1: isize, arg2: isize, arg3: bool, arg4: bool) -> Lisp_Object;
}
extern "C" {
    pub fn del_range_byte(arg1: isize, arg2: isize);
}
extern "C" {
    pub fn del_range_both(arg1: isize, arg2: isize, arg3: isize, arg4: isize, arg5: bool);
}
extern "C" {
    pub fn del_range_2(
        arg1: isize,
        arg2: isize,
        arg3: isize,
        arg4: isize,
        arg5: bool,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn modify_text(arg1: isize, arg2: isize);
}
extern "C" {
    pub fn prepare_to_modify_buffer(arg1: isize, arg2: isize, arg3: *mut isize);
}
extern "C" {
    pub fn prepare_to_modify_buffer_1(arg1: isize, arg2: isize, arg3: *mut isize);
}
extern "C" {
    pub fn invalidate_buffer_caches(arg1: *mut buffer, arg2: isize, arg3: isize);
}
extern "C" {
    pub fn signal_after_change(arg1: isize, arg2: isize, arg3: isize);
}
extern "C" {
    pub fn adjust_after_insert(arg1: isize, arg2: isize, arg3: isize, arg4: isize, arg5: isize);
}
extern "C" {
    pub fn adjust_markers_for_delete(arg1: isize, arg2: isize, arg3: isize, arg4: isize);
}
extern "C" {
    pub fn adjust_markers_bytepos(
        arg1: isize,
        arg2: isize,
        arg3: isize,
        arg4: isize,
        arg5: ::libc::c_int,
    );
}
extern "C" {
    pub fn replace_range(
        arg1: isize,
        arg2: isize,
        arg3: Lisp_Object,
        arg4: bool,
        arg5: bool,
        arg6: bool,
        arg7: bool,
    );
}
extern "C" {
    pub fn replace_range_2(
        arg1: isize,
        arg2: isize,
        arg3: isize,
        arg4: isize,
        arg5: *const ::libc::c_char,
        arg6: isize,
        arg7: isize,
        arg8: bool,
    );
}
extern "C" {
    pub fn syms_of_insdel();
}
extern "C" {
    #[link_name = "\u{1}Vwindow_system"]
    pub static mut Vwindow_system: Lisp_Object;
}
extern "C" {
    pub fn sit_for(arg1: Lisp_Object, arg2: bool, arg3: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}noninteractive_need_newline"]
    pub static mut noninteractive_need_newline: bool;
}
extern "C" {
    #[link_name = "\u{1}echo_area_buffer"]
    pub static mut echo_area_buffer: [Lisp_Object; 2usize];
}
extern "C" {
    pub fn add_to_log(arg1: *const ::libc::c_char, ...);
}
extern "C" {
    pub fn vadd_to_log(arg1: *const ::libc::c_char, arg2: *mut __va_list_tag);
}
extern "C" {
    pub fn check_message_stack();
}
extern "C" {
    pub fn clear_message_stack();
}
extern "C" {
    pub fn setup_echo_area_for_printing(arg1: bool);
}
extern "C" {
    pub fn push_message() -> bool;
}
extern "C" {
    pub fn pop_message_unwind();
}
extern "C" {
    pub fn restore_message_unwind(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn restore_message();
}
extern "C" {
    pub fn current_message() -> Lisp_Object;
}
extern "C" {
    pub fn clear_message(arg1: bool, arg2: bool);
}
extern "C" {
    pub fn message(arg1: *const ::libc::c_char, ...);
}
extern "C" {
    pub fn message1(arg1: *const ::libc::c_char);
}
extern "C" {
    pub fn message1_nolog(arg1: *const ::libc::c_char);
}
extern "C" {
    pub fn message3(arg1: Lisp_Object);
}
extern "C" {
    pub fn message3_nolog(arg1: Lisp_Object);
}
extern "C" {
    pub fn message_dolog(arg1: *const ::libc::c_char, arg2: isize, arg3: bool, arg4: bool);
}
extern "C" {
    pub fn message_with_string(arg1: *const ::libc::c_char, arg2: Lisp_Object, arg3: bool);
}
extern "C" {
    pub fn message_log_maybe_newline();
}
extern "C" {
    pub fn update_echo_area();
}
extern "C" {
    pub fn truncate_echo_area(arg1: isize);
}
extern "C" {
    pub fn redisplay();
}
extern "C" {
    pub fn count_lines(start_byte: isize, end_byte: isize) -> isize;
}
extern "C" {
    pub fn set_frame_cursor_types(arg1: *mut frame, arg2: Lisp_Object);
}
extern "C" {
    pub fn syms_of_xdisp();
}
extern "C" {
    pub fn init_xdisp();
}
extern "C" {
    pub fn safe_eval(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn pos_visible_p(
        arg1: *mut window,
        arg2: isize,
        arg3: *mut ::libc::c_int,
        arg4: *mut ::libc::c_int,
        arg5: *mut ::libc::c_int,
        arg6: *mut ::libc::c_int,
        arg7: *mut ::libc::c_int,
        arg8: *mut ::libc::c_int,
    ) -> bool;
}
extern "C" {
    pub fn syms_of_xsettings();
}
extern "C" {
    pub fn memory_warnings(
        arg1: *mut ::libc::c_void,
        warnfun: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::libc::c_char)>,
    );
}
extern "C" {
    pub fn parse_str_as_multibyte(
        arg1: *const ::libc::c_uchar,
        arg2: isize,
        arg3: *mut isize,
        arg4: *mut isize,
    );
}
extern "C" {
    pub fn my_heap_start() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn check_pure_size();
}
extern "C" {
    pub fn resize_string_data(
        arg1: Lisp_Object,
        arg2: isize,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
    ) -> *mut ::libc::c_uchar;
}
extern "C" {
    pub fn malloc_warning(arg1: *const ::libc::c_char);
}
extern "C" {
    pub fn buffer_memory_full(arg1: isize);
}
extern "C" {
    pub fn survives_gc_p(arg1: Lisp_Object) -> bool;
}
extern "C" {
    pub fn mark_object(arg1: Lisp_Object);
}
extern "C" {
    pub fn mark_objects(arg1: *mut Lisp_Object, arg2: isize);
}
extern "C" {
    pub fn alloc_unexec_pre();
}
extern "C" {
    pub fn alloc_unexec_post();
}
extern "C" {
    pub fn mark_stack(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn flush_stack_call_func1(
        func: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::libc::c_void)>,
        arg: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn flush_stack_call_func(
        func: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::libc::c_void)>,
        arg: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn garbage_collect();
}
extern "C" {
    pub fn maybe_garbage_collect();
}
extern "C" {
    pub fn maybe_garbage_collect_eagerly(factor: EMACS_INT) -> bool;
}
extern "C" {
    #[link_name = "\u{1}pending_malloc_warning"]
    pub static mut pending_malloc_warning: *const ::libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}zero_vector"]
    pub static mut zero_vector: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}consing_until_gc"]
    pub static mut consing_until_gc: EMACS_INT;
}
extern "C" {
    #[link_name = "\u{1}number_finalizers_run"]
    pub static mut number_finalizers_run: ::libc::c_int;
}
extern "C" {
    pub fn list1(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn list2(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn list3(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn list4(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn list5(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn listn(arg1: isize, arg2: Lisp_Object, ...) -> Lisp_Object;
}
extern "C" {
    pub fn pure_listn(arg1: isize, arg2: Lisp_Object, ...) -> Lisp_Object;
}
pub mod gc_root_type {
    pub type Type = u32;
    pub const GC_ROOT_STATICPRO: Type = 0;
    pub const GC_ROOT_BUFFER_LOCAL_DEFAULT: Type = 1;
    pub const GC_ROOT_BUFFER_LOCAL_NAME: Type = 2;
    pub const GC_ROOT_C_SYMBOL: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gc_root_visitor {
    pub visit: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const Lisp_Object,
            arg2: gc_root_type::Type,
            arg3: *mut ::libc::c_void,
        ),
    >,
    pub data: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_gc_root_visitor() {
    assert_eq!(
        ::std::mem::size_of::<gc_root_visitor>(),
        16usize,
        concat!("Size of: ", stringify!(gc_root_visitor))
    );
    assert_eq!(
        ::std::mem::align_of::<gc_root_visitor>(),
        8usize,
        concat!("Alignment of ", stringify!(gc_root_visitor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gc_root_visitor>())).visit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gc_root_visitor),
            "::",
            stringify!(visit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gc_root_visitor>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gc_root_visitor),
            "::",
            stringify!(data)
        )
    );
}
impl Default for gc_root_visitor {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn visit_static_gc_roots(visitor: gc_root_visitor);
}
extern "C" {
    pub fn list1i(a: intmax_t) -> Lisp_Object;
}
extern "C" {
    pub fn list2i(a: intmax_t, b: intmax_t) -> Lisp_Object;
}
extern "C" {
    pub fn list3i(a: intmax_t, b: intmax_t, c: intmax_t) -> Lisp_Object;
}
extern "C" {
    pub fn list4i(a: intmax_t, b: intmax_t, c: intmax_t, d: intmax_t) -> Lisp_Object;
}
extern "C" {
    pub fn make_uninit_bool_vector(arg1: EMACS_INT) -> Lisp_Object;
}
extern "C" {
    pub fn bool_vector_fill(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn string_overflow();
}
extern "C" {
    pub fn make_string(arg1: *const ::libc::c_char, arg2: isize) -> Lisp_Object;
}
extern "C" {
    pub fn make_formatted_string(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        ...
    ) -> Lisp_Object;
}
extern "C" {
    pub fn make_unibyte_string(arg1: *const ::libc::c_char, arg2: isize) -> Lisp_Object;
}
extern "C" {
    pub fn vectorlike_nbytes(hdr: *const vectorlike_header) -> isize;
}
extern "C" {
    pub fn vector_nbytes(v: *const Lisp_Vector) -> isize;
}
extern "C" {
    pub fn build_unibyte_string(str: *const ::libc::c_char) -> Lisp_Object;
}
extern "C" {
    pub fn make_multibyte_string(
        arg1: *const ::libc::c_char,
        arg2: isize,
        arg3: isize,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn make_event_array(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn make_uninit_string(arg1: EMACS_INT) -> Lisp_Object;
}
extern "C" {
    pub fn make_uninit_multibyte_string(arg1: EMACS_INT, arg2: EMACS_INT) -> Lisp_Object;
}
extern "C" {
    pub fn make_string_from_bytes(
        arg1: *const ::libc::c_char,
        arg2: isize,
        arg3: isize,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn make_specified_string(
        arg1: *const ::libc::c_char,
        arg2: isize,
        arg3: isize,
        arg4: bool,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn make_pure_string(
        arg1: *const ::libc::c_char,
        arg2: isize,
        arg3: isize,
        arg4: bool,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn make_pure_c_string(arg1: *const ::libc::c_char, arg2: isize) -> Lisp_Object;
}
extern "C" {
    pub fn build_pure_c_string(str: *const ::libc::c_char) -> Lisp_Object;
}
extern "C" {
    pub fn build_string(str: *const ::libc::c_char) -> Lisp_Object;
}
extern "C" {
    pub fn pure_cons(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn make_vector(arg1: isize, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn allocate_nil_vector(arg1: isize) -> *mut Lisp_Vector;
}
extern "C" {
    pub fn allocate_vector(arg1: isize) -> *mut Lisp_Vector;
}
extern "C" {
    pub fn make_uninit_vector(size: isize) -> Lisp_Object;
}
extern "C" {
    pub fn make_uninit_sub_char_table(depth: ::libc::c_int, min_char: ::libc::c_int)
        -> Lisp_Object;
}
extern "C" {
    pub fn make_nil_vector(size: isize) -> Lisp_Object;
}
extern "C" {
    pub fn allocate_pseudovector(
        arg1: ::libc::c_int,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: pvec_type,
    ) -> *mut Lisp_Vector;
}
extern "C" {
    #[link_name = "\u{1}gc_in_progress"]
    pub static mut gc_in_progress: bool;
}
extern "C" {
    pub fn make_float(arg1: f64) -> Lisp_Object;
}
extern "C" {
    pub fn display_malloc_warning();
}
extern "C" {
    pub fn inhibit_garbage_collection() -> isize;
}
extern "C" {
    pub fn build_overlay(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn free_cons(arg1: *mut Lisp_Cons);
}
extern "C" {
    pub fn init_alloc_once();
}
extern "C" {
    pub fn init_alloc();
}
extern "C" {
    pub fn syms_of_alloc();
}
extern "C" {
    pub fn allocate_buffer() -> *mut buffer;
}
extern "C" {
    pub fn valid_lisp_object_p(arg1: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    pub fn malloc_enable_thread();
}
extern "C" {
    pub fn copy_char_table(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn char_table_ref_and_range(
        arg1: Lisp_Object,
        arg2: ::libc::c_int,
        arg3: *mut ::libc::c_int,
        arg4: *mut ::libc::c_int,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn char_table_set_range(
        arg1: Lisp_Object,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: Lisp_Object,
    );
}
extern "C" {
    pub fn map_char_table(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object),
        >,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    );
}
extern "C" {
    pub fn map_char_table_for_charset(
        c_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: Lisp_Object, arg2: Lisp_Object),
        >,
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: *mut charset,
        arg5: ::libc::c_uint,
        arg6: ::libc::c_uint,
    );
}
extern "C" {
    pub fn uniprop_table(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn get_unicode_property(arg1: Lisp_Object, arg2: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn syms_of_chartab();
}
extern "C" {
    #[link_name = "\u{1}Vprin1_to_string_buffer"]
    pub static mut Vprin1_to_string_buffer: Lisp_Object;
}
extern "C" {
    pub fn debug_print(arg1: Lisp_Object);
}
extern "C" {
    pub fn temp_output_buffer_setup(arg1: *const ::libc::c_char);
}
extern "C" {
    #[link_name = "\u{1}print_level"]
    pub static mut print_level: ::libc::c_int;
}
extern "C" {
    pub fn print_error_message(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: *const ::libc::c_char,
        arg4: Lisp_Object,
    );
}
extern "C" {
    pub fn internal_with_output_to_temp_buffer(
        arg1: *const ::libc::c_char,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object) -> Lisp_Object>,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn float_to_string(arg1: *mut ::libc::c_char, arg2: f64) -> ::libc::c_int;
}
extern "C" {
    pub fn init_print_once();
}
extern "C" {
    pub fn syms_of_print();
}
extern "C" {
    pub fn doprnt(
        arg1: *mut ::libc::c_char,
        arg2: isize,
        arg3: *const ::libc::c_char,
        arg4: *const ::libc::c_char,
        arg5: *mut __va_list_tag,
    ) -> isize;
}
extern "C" {
    pub fn esprintf(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char, ...) -> isize;
}
extern "C" {
    pub fn exprintf(
        arg1: *mut *mut ::libc::c_char,
        arg2: *mut isize,
        arg3: *const ::libc::c_char,
        arg4: isize,
        arg5: *const ::libc::c_char,
        ...
    ) -> isize;
}
extern "C" {
    pub fn evxprintf(
        arg1: *mut *mut ::libc::c_char,
        arg2: *mut isize,
        arg3: *const ::libc::c_char,
        arg4: isize,
        arg5: *const ::libc::c_char,
        arg6: *mut __va_list_tag,
    ) -> isize;
}
extern "C" {
    pub fn check_obarray(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn intern_1(arg1: *const ::libc::c_char, arg2: isize) -> Lisp_Object;
}
extern "C" {
    pub fn intern_c_string_1(arg1: *const ::libc::c_char, arg2: isize) -> Lisp_Object;
}
extern "C" {
    pub fn intern_driver(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn init_symbol(arg1: Lisp_Object, arg2: Lisp_Object);
}
extern "C" {
    pub fn oblookup(
        arg1: Lisp_Object,
        arg2: *const ::libc::c_char,
        arg3: isize,
        arg4: isize,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn LOADHIST_ATTACH(x: Lisp_Object);
}
extern "C" {
    pub fn suffix_p(arg1: Lisp_Object, arg2: *const ::libc::c_char) -> bool;
}
extern "C" {
    pub fn save_match_data_load(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn openp(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: *mut Lisp_Object,
        arg5: Lisp_Object,
        arg6: bool,
        arg7: bool,
    ) -> ::libc::c_int;
}
pub mod _bindgen_ty_20 {
    pub type Type = u32;
    pub const S2N_IGNORE_TRAILING: Type = 1;
}
extern "C" {
    pub fn string_to_number(
        arg1: *const ::libc::c_char,
        arg2: ::libc::c_int,
        arg3: *mut isize,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn map_obarray(
        arg1: Lisp_Object,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object, arg2: Lisp_Object)>,
        arg3: Lisp_Object,
    );
}
extern "C" {
    pub fn dir_warning(arg1: *const ::libc::c_char, arg2: Lisp_Object);
}
extern "C" {
    pub fn init_obarray_once();
}
extern "C" {
    pub fn init_lread();
}
extern "C" {
    pub fn syms_of_lread();
}
extern "C" {
    pub fn intern(str: *const ::libc::c_char) -> Lisp_Object;
}
extern "C" {
    pub fn intern_c_string(str: *const ::libc::c_char) -> Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}minibuffer_quit_level"]
    pub static mut minibuffer_quit_level: EMACS_INT;
}
extern "C" {
    #[link_name = "\u{1}Vautoload_queue"]
    pub static mut Vautoload_queue: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}Vrun_hooks"]
    pub static mut Vrun_hooks: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}Vsignaling_function"]
    pub static mut Vsignaling_function: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}inhibit_lisp_code"]
    pub static mut inhibit_lisp_code: Lisp_Object;
}
extern "C" {
    pub fn signal_or_quit(arg1: Lisp_Object, arg2: Lisp_Object, arg3: bool) -> Lisp_Object;
}
extern "C" {
    pub fn run_hook(arg1: Lisp_Object);
}
extern "C" {
    pub fn run_hook_with_args_2(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn run_hook_with_args(
        nargs: isize,
        args: *mut Lisp_Object,
        funcall: ::std::option::Option<
            unsafe extern "C" fn(nargs: isize, args: *mut Lisp_Object) -> Lisp_Object,
        >,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn quit() -> Lisp_Object;
}
extern "C" {
    pub fn xsignal(error_symbol: Lisp_Object, data: Lisp_Object);
}
extern "C" {
    pub fn xsignal0(arg1: Lisp_Object);
}
extern "C" {
    pub fn xsignal1(arg1: Lisp_Object, arg2: Lisp_Object);
}
extern "C" {
    pub fn xsignal2(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn xsignal3(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object, arg4: Lisp_Object);
}
extern "C" {
    pub fn signal_error(arg1: *const ::libc::c_char, arg2: Lisp_Object);
}
extern "C" {
    pub fn overflow_error();
}
extern "C" {
    pub fn FUNCTIONP(arg1: Lisp_Object) -> bool;
}
extern "C" {
    pub fn funcall_subr(
        subr: *mut Lisp_Subr,
        numargs: isize,
        arg_vector: *mut Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn eval_sub(form: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn apply1(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn call0(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn call1(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn call2(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn call3(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn call4(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn call5(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn call6(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn call7(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
        arg8: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn call8(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
        arg8: Lisp_Object,
        arg9: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn internal_catch(
        arg1: Lisp_Object,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object) -> Lisp_Object>,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn internal_lisp_condition_case(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn internal_condition_case(
        arg1: ::std::option::Option<unsafe extern "C" fn() -> Lisp_Object>,
        arg2: Lisp_Object,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object) -> Lisp_Object>,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn internal_condition_case_1(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object) -> Lisp_Object>,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object) -> Lisp_Object>,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn internal_condition_case_2(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object,
        >,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object) -> Lisp_Object>,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn internal_condition_case_3(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: Lisp_Object,
                arg2: Lisp_Object,
                arg3: Lisp_Object,
            ) -> Lisp_Object,
        >,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object) -> Lisp_Object>,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn internal_condition_case_4(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: Lisp_Object,
                arg2: Lisp_Object,
                arg3: Lisp_Object,
                arg4: Lisp_Object,
            ) -> Lisp_Object,
        >,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object) -> Lisp_Object>,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn internal_condition_case_5(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: Lisp_Object,
                arg2: Lisp_Object,
                arg3: Lisp_Object,
                arg4: Lisp_Object,
                arg5: Lisp_Object,
            ) -> Lisp_Object,
        >,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
        arg8: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object) -> Lisp_Object>,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn internal_condition_case_n(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: isize, arg2: *mut Lisp_Object) -> Lisp_Object,
        >,
        arg2: isize,
        arg3: *mut Lisp_Object,
        arg4: Lisp_Object,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: Lisp_Object,
                arg2: isize,
                arg3: *mut Lisp_Object,
            ) -> Lisp_Object,
        >,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn internal_catch_all(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void) -> Lisp_Object>,
        arg2: *mut ::libc::c_void,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: nonlocal_exit::Type, arg2: Lisp_Object) -> Lisp_Object,
        >,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn push_handler(arg1: Lisp_Object, arg2: handlertype::Type) -> *mut handler;
}
extern "C" {
    pub fn push_handler_nosignal(arg1: Lisp_Object, arg2: handlertype::Type) -> *mut handler;
}
extern "C" {
    pub fn specbind(arg1: Lisp_Object, arg2: Lisp_Object);
}
extern "C" {
    pub fn record_unwind_protect(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object)>,
        arg2: Lisp_Object,
    );
}
extern "C" {
    pub fn record_unwind_protect_array(arg1: *mut Lisp_Object, arg2: isize);
}
extern "C" {
    pub fn record_unwind_protect_ptr(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        arg2: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn record_unwind_protect_int(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
        arg2: ::libc::c_int,
    );
}
extern "C" {
    pub fn record_unwind_protect_intmax(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: intmax_t)>,
        arg2: intmax_t,
    );
}
extern "C" {
    pub fn record_unwind_protect_void(arg1: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn record_unwind_protect_excursion();
}
extern "C" {
    pub fn record_unwind_protect_nothing();
}
extern "C" {
    pub fn record_unwind_protect_module(arg1: specbind_tag::Type, arg2: *mut ::libc::c_void);
}
extern "C" {
    pub fn clear_unwind_protect(arg1: isize);
}
extern "C" {
    pub fn set_unwind_protect(
        arg1: isize,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object)>,
        arg3: Lisp_Object,
    );
}
extern "C" {
    pub fn set_unwind_protect_ptr(
        arg1: isize,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        arg3: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn unbind_to(arg1: isize, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn rebind_for_thread_switch();
}
extern "C" {
    pub fn unbind_for_thread_switch(arg1: *mut thread_state);
}
extern "C" {
    pub fn verror(arg1: *const ::libc::c_char, arg2: *mut __va_list_tag);
}
extern "C" {
    pub fn vformat_string(arg1: *const ::libc::c_char, arg2: *mut __va_list_tag) -> Lisp_Object;
}
extern "C" {
    pub fn un_autoload(arg1: Lisp_Object);
}
extern "C" {
    pub fn call_debugger(arg: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn init_eval_once();
}
extern "C" {
    pub fn safe_call(arg1: isize, arg2: Lisp_Object, ...) -> Lisp_Object;
}
extern "C" {
    pub fn safe_call1(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn safe_call2(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn init_eval();
}
extern "C" {
    pub fn syms_of_eval();
}
extern "C" {
    pub fn prog_ignore(arg1: Lisp_Object);
}
extern "C" {
    pub fn record_in_backtrace(arg1: Lisp_Object, arg2: *mut Lisp_Object, arg3: isize) -> isize;
}
extern "C" {
    pub fn mark_specpdl(first: *mut specbinding, ptr: *mut specbinding);
}
extern "C" {
    pub fn get_backtrace(array: Lisp_Object);
}
extern "C" {
    pub fn backtrace_top_function() -> Lisp_Object;
}
extern "C" {
    pub fn let_shadows_buffer_binding_p(symbol: *mut Lisp_Symbol) -> bool;
}
extern "C" {
    pub fn MODULE_FUNCTIONP(o: Lisp_Object) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Lisp_Module_Function {
    _unused: [u8; 0],
}
extern "C" {
    pub fn XMODULE_FUNCTION(o: Lisp_Object) -> *mut Lisp_Module_Function;
}
pub type module_funcptr = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn make_user_ptr(
        finalizer: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        p: *mut ::libc::c_void,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn funcall_module(arg1: Lisp_Object, arg2: isize, arg3: *mut Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn module_function_arity(arg1: *const Lisp_Module_Function) -> Lisp_Object;
}
extern "C" {
    pub fn module_function_documentation(arg1: *const Lisp_Module_Function) -> Lisp_Object;
}
extern "C" {
    pub fn module_function_interactive_form(arg1: *const Lisp_Module_Function) -> Lisp_Object;
}
extern "C" {
    pub fn module_function_command_modes(arg1: *const Lisp_Module_Function) -> Lisp_Object;
}
extern "C" {
    pub fn module_function_address(arg1: *const Lisp_Module_Function) -> module_funcptr;
}
extern "C" {
    pub fn module_function_data(arg1: *const Lisp_Module_Function) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn module_finalize_function(arg1: *const Lisp_Module_Function);
}
extern "C" {
    pub fn mark_module_environment(arg1: *mut ::libc::c_void);
}
extern "C" {
    pub fn finalize_runtime_unwind(arg1: *mut ::libc::c_void);
}
extern "C" {
    pub fn finalize_environment_unwind(arg1: *mut ::libc::c_void);
}
extern "C" {
    pub fn init_module_assertions(arg1: bool);
}
extern "C" {
    pub fn syms_of_module();
}
extern "C" {
    pub fn mark_threads();
}
extern "C" {
    pub fn unmark_main_thread();
}
extern "C" {
    pub fn insert1(arg1: Lisp_Object);
}
extern "C" {
    pub fn save_excursion_save(arg1: *mut specbinding);
}
extern "C" {
    pub fn save_excursion_restore(arg1: Lisp_Object, arg2: Lisp_Object);
}
extern "C" {
    pub fn save_restriction_save() -> Lisp_Object;
}
extern "C" {
    pub fn save_restriction_restore(arg1: Lisp_Object);
}
extern "C" {
    pub fn make_buffer_string(arg1: isize, arg2: isize, arg3: bool) -> Lisp_Object;
}
extern "C" {
    pub fn make_buffer_string_both(
        arg1: isize,
        arg2: isize,
        arg3: isize,
        arg4: isize,
        arg5: bool,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn init_editfns();
}
extern "C" {
    pub fn syms_of_editfns();
}
extern "C" {
    pub fn mouse_face_overlay_overlaps(arg1: Lisp_Object) -> bool;
}
extern "C" {
    pub fn disable_line_numbers_overlay_at_eob() -> Lisp_Object;
}
extern "C" {
    pub fn adjust_overlays_for_insert(arg1: isize, arg2: isize);
}
extern "C" {
    pub fn adjust_overlays_for_delete(arg1: isize, arg2: isize);
}
extern "C" {
    pub fn fix_start_end_in_overlays(arg1: isize, arg2: isize);
}
extern "C" {
    pub fn report_overlay_modification(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: bool,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
    );
}
extern "C" {
    pub fn overlay_touches_p(arg1: isize) -> bool;
}
extern "C" {
    pub fn other_buffer_safely(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn get_truename_buffer(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn init_buffer_once();
}
extern "C" {
    pub fn init_buffer();
}
extern "C" {
    pub fn syms_of_buffer();
}
extern "C" {
    pub fn marker_position(arg1: Lisp_Object) -> isize;
}
extern "C" {
    pub fn marker_byte_position(arg1: Lisp_Object) -> isize;
}
extern "C" {
    pub fn clear_charpos_cache(arg1: *mut buffer);
}
extern "C" {
    pub fn buf_charpos_to_bytepos(arg1: *mut buffer, arg2: isize) -> isize;
}
extern "C" {
    pub fn buf_bytepos_to_charpos(arg1: *mut buffer, arg2: isize) -> isize;
}
extern "C" {
    pub fn detach_marker(arg1: Lisp_Object);
}
extern "C" {
    pub fn unchain_marker(arg1: *mut Lisp_Marker);
}
extern "C" {
    pub fn set_marker_restricted(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn set_marker_both(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: isize,
        arg4: isize,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn set_marker_restricted_both(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: isize,
        arg4: isize,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn build_marker(arg1: *mut buffer, arg2: isize, arg3: isize) -> Lisp_Object;
}
extern "C" {
    pub fn syms_of_marker();
}
extern "C" {
    pub fn splice_dir_file(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn file_name_absolute_p(arg1: *const ::libc::c_char) -> bool;
}
extern "C" {
    pub fn get_homedir() -> *const ::libc::c_char;
}
extern "C" {
    pub fn expand_and_dir_to_file(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn write_region(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
        arg8: ::libc::c_int,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn close_file_unwind(arg1: ::libc::c_int);
}
extern "C" {
    pub fn fclose_unwind(arg1: *mut ::libc::c_void);
}
extern "C" {
    pub fn restore_point_unwind(arg1: Lisp_Object);
}
extern "C" {
    pub fn file_access_p(arg1: *const ::libc::c_char, arg2: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn get_file_errno_data(
        arg1: *const ::libc::c_char,
        arg2: Lisp_Object,
        arg3: ::libc::c_int,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn report_file_errno(arg1: *const ::libc::c_char, arg2: Lisp_Object, arg3: ::libc::c_int);
}
extern "C" {
    pub fn report_file_error(arg1: *const ::libc::c_char, arg2: Lisp_Object);
}
extern "C" {
    pub fn report_file_notify_error(arg1: *const ::libc::c_char, arg2: Lisp_Object);
}
extern "C" {
    pub fn file_attribute_errno(arg1: Lisp_Object, arg2: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn internal_delete_file(arg1: Lisp_Object) -> bool;
}
extern "C" {
    pub fn check_emacs_readlinkat(
        arg1: ::libc::c_int,
        arg2: Lisp_Object,
        arg3: *const ::libc::c_char,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn file_directory_p(arg1: Lisp_Object) -> bool;
}
extern "C" {
    pub fn file_accessible_directory_p(arg1: Lisp_Object) -> bool;
}
extern "C" {
    pub fn init_fileio();
}
extern "C" {
    pub fn syms_of_fileio();
}
extern "C" {
    pub fn shrink_regexp_cache();
}
extern "C" {
    pub fn restore_search_regs();
}
extern "C" {
    pub fn update_search_regs(oldstart: isize, oldend: isize, newend: isize);
}
extern "C" {
    pub fn record_unwind_save_match_data();
}
extern "C" {
    pub fn fast_string_match_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> isize;
}
extern "C" {
    pub fn fast_string_match(regexp: Lisp_Object, string: Lisp_Object) -> isize;
}
extern "C" {
    pub fn fast_string_match_ignore_case(regexp: Lisp_Object, string: Lisp_Object) -> isize;
}
extern "C" {
    pub fn fast_c_string_match_ignore_case(
        arg1: Lisp_Object,
        arg2: *const ::libc::c_char,
        arg3: isize,
    ) -> isize;
}
extern "C" {
    pub fn fast_looking_at(
        arg1: Lisp_Object,
        arg2: isize,
        arg3: isize,
        arg4: isize,
        arg5: isize,
        arg6: Lisp_Object,
    ) -> isize;
}
extern "C" {
    pub fn find_newline(
        arg1: isize,
        arg2: isize,
        arg3: isize,
        arg4: isize,
        arg5: isize,
        arg6: *mut isize,
        arg7: *mut isize,
        arg8: bool,
    ) -> isize;
}
extern "C" {
    pub fn scan_newline(
        arg1: isize,
        arg2: isize,
        arg3: isize,
        arg4: isize,
        arg5: isize,
        arg6: bool,
    );
}
extern "C" {
    pub fn scan_newline_from_point(arg1: isize, arg2: *mut isize, arg3: *mut isize) -> isize;
}
extern "C" {
    pub fn find_newline_no_quit(arg1: isize, arg2: isize, arg3: isize, arg4: *mut isize) -> isize;
}
extern "C" {
    pub fn find_before_next_newline(
        arg1: isize,
        arg2: isize,
        arg3: isize,
        arg4: *mut isize,
    ) -> isize;
}
extern "C" {
    pub fn syms_of_search();
}
extern "C" {
    pub fn clear_regexp_cache();
}
extern "C" {
    #[link_name = "\u{1}Vminibuffer_list"]
    pub static mut Vminibuffer_list: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}last_minibuf_string"]
    pub static mut last_minibuf_string: Lisp_Object;
}
extern "C" {
    pub fn move_minibuffers_onto_frame(arg1: *mut frame, arg2: bool);
}
extern "C" {
    pub fn is_minibuffer(arg1: EMACS_INT, arg2: Lisp_Object) -> bool;
}
extern "C" {
    pub fn this_minibuffer_depth(arg1: Lisp_Object) -> EMACS_INT;
}
extern "C" {
    #[link_name = "\u{1}minibuf_level"]
    pub static mut minibuf_level: EMACS_INT;
}
extern "C" {
    pub fn get_minibuffer(arg1: EMACS_INT) -> Lisp_Object;
}
extern "C" {
    pub fn init_minibuf_once();
}
extern "C" {
    pub fn syms_of_minibuf();
}
extern "C" {
    pub fn barf_if_interaction_inhibited();
}
extern "C" {
    pub fn syms_of_callint();
}
extern "C" {
    pub fn syms_of_casefiddle();
}
extern "C" {
    pub fn init_casetab_once();
}
extern "C" {
    pub fn syms_of_casetab();
}
extern "C" {
    #[link_name = "\u{1}command_loop_level"]
    pub static mut command_loop_level: EMACS_INT;
}
extern "C" {
    #[link_name = "\u{1}echo_message_buffer"]
    pub static mut echo_message_buffer: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}echo_kboard"]
    pub static mut echo_kboard: *mut kboard;
}
extern "C" {
    pub fn cancel_echoing();
}
extern "C" {
    #[link_name = "\u{1}input_pending"]
    pub static mut input_pending: bool;
}
extern "C" {
    #[link_name = "\u{1}return_to_command_loop"]
    pub static mut return_to_command_loop: sigjmp_buf;
}
extern "C" {
    pub fn menu_bar_items(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn tab_bar_items(arg1: Lisp_Object, arg2: *mut ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn tool_bar_items(arg1: Lisp_Object, arg2: *mut ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn discard_mouse_events();
}
extern "C" {
    pub fn handle_input_available_signal(arg1: ::libc::c_int);
}
extern "C" {
    #[link_name = "\u{1}pending_funcalls"]
    pub static mut pending_funcalls: Lisp_Object;
}
extern "C" {
    pub fn detect_input_pending() -> bool;
}
extern "C" {
    pub fn detect_input_pending_ignore_squeezables() -> bool;
}
extern "C" {
    pub fn detect_input_pending_run_timers(arg1: bool) -> bool;
}
extern "C" {
    pub fn safe_run_hooks(arg1: Lisp_Object);
}
extern "C" {
    pub fn cmd_error_internal(arg1: Lisp_Object, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn command_loop_1() -> Lisp_Object;
}
extern "C" {
    pub fn read_menu_command() -> Lisp_Object;
}
extern "C" {
    pub fn recursive_edit_1() -> Lisp_Object;
}
extern "C" {
    pub fn record_auto_save();
}
extern "C" {
    pub fn force_auto_save_soon();
}
extern "C" {
    pub fn init_keyboard();
}
extern "C" {
    pub fn syms_of_keyboard();
}
extern "C" {
    pub fn keys_of_keyboard();
}
extern "C" {
    pub fn current_column() -> isize;
}
extern "C" {
    pub fn invalidate_current_column();
}
extern "C" {
    pub fn indented_beyond_p(arg1: isize, arg2: isize, arg3: EMACS_INT) -> bool;
}
extern "C" {
    pub fn syms_of_indent();
}
extern "C" {
    pub fn store_frame_param(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn store_in_alist(arg1: *mut Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn do_switch_frame(
        arg1: Lisp_Object,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn get_frame_param(arg1: *mut frame, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn frames_discard_buffer(arg1: Lisp_Object);
}
extern "C" {
    pub fn init_frame_once();
}
extern "C" {
    pub fn syms_of_frame();
}
extern "C" {
    #[link_name = "\u{1}initial_argv"]
    pub static mut initial_argv: *mut *mut ::libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}initial_argc"]
    pub static mut initial_argc: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}emacs_wd"]
    pub static mut emacs_wd: *const ::libc::c_char;
}
extern "C" {
    pub fn decode_env_path(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: bool,
    ) -> Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}empty_unibyte_string"]
    pub static mut empty_unibyte_string: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}empty_multibyte_string"]
    pub static mut empty_multibyte_string: Lisp_Object;
}
extern "C" {
    pub fn terminate_due_to_signal(arg1: ::libc::c_int, arg2: ::libc::c_int);
}
extern "C" {
    pub fn init_vars_for_load(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn fixup_locale();
}
extern "C" {
    pub fn synchronize_system_messages_locale();
}
extern "C" {
    pub fn synchronize_system_time_locale();
}
extern "C" {
    pub fn emacs_strerror(arg1: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn shut_down_emacs(arg1: ::libc::c_int, arg2: Lisp_Object);
}
extern "C" {
    #[link_name = "\u{1}noninteractive"]
    pub static mut noninteractive: bool;
}
extern "C" {
    #[link_name = "\u{1}no_site_lisp"]
    pub static mut no_site_lisp: bool;
}
extern "C" {
    #[link_name = "\u{1}build_details"]
    pub static mut build_details: bool;
}
extern "C" {
    #[link_name = "\u{1}daemon_type"]
    pub static mut daemon_type: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}fatal_error_in_progress"]
    pub static mut fatal_error_in_progress: bool;
}
extern "C" {
    #[link_name = "\u{1}inhibit_window_system"]
    pub static mut inhibit_window_system: bool;
}
extern "C" {
    #[link_name = "\u{1}running_asynch_code"]
    pub static mut running_asynch_code: bool;
}
extern "C" {
    pub fn kill_buffer_processes(arg1: Lisp_Object);
}
extern "C" {
    pub fn wait_reading_process_output(
        arg1: intmax_t,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: bool,
        arg5: Lisp_Object,
        arg6: *mut Lisp_Process,
        arg7: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn add_timer_wait_descriptor(arg1: ::libc::c_int);
}
extern "C" {
    pub fn add_keyboard_wait_descriptor(arg1: ::libc::c_int);
}
extern "C" {
    pub fn delete_keyboard_wait_descriptor(arg1: ::libc::c_int);
}
extern "C" {
    pub fn add_gpm_wait_descriptor(arg1: ::libc::c_int);
}
extern "C" {
    pub fn delete_gpm_wait_descriptor(arg1: ::libc::c_int);
}
extern "C" {
    pub fn init_process_emacs(arg1: ::libc::c_int);
}
extern "C" {
    pub fn syms_of_process();
}
extern "C" {
    pub fn setup_process_coding_systems(arg1: Lisp_Object);
}
extern "C" {
    pub fn emacs_spawn(
        arg1: *mut pid_t,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
        arg5: *mut *mut ::libc::c_char,
        arg6: *mut *mut ::libc::c_char,
        arg7: *const ::libc::c_char,
        arg8: *const ::libc::c_char,
        arg9: *const sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn make_environment_block(arg1: Lisp_Object) -> *mut *mut ::libc::c_char;
}
extern "C" {
    pub fn init_callproc_1();
}
extern "C" {
    pub fn init_callproc();
}
extern "C" {
    pub fn set_initial_environment();
}
extern "C" {
    pub fn syms_of_callproc();
}
extern "C" {
    pub fn read_doc_string(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn get_doc_string(arg1: Lisp_Object, arg2: bool, arg3: bool) -> Lisp_Object;
}
extern "C" {
    pub fn syms_of_doc();
}
extern "C" {
    pub fn read_bytecode_char(arg1: bool) -> ::libc::c_int;
}
extern "C" {
    pub fn syms_of_bytecode();
}
extern "C" {
    pub fn exec_byte_code(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: isize,
        arg6: *mut Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn get_byte_code_arity(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn init_macros();
}
extern "C" {
    pub fn syms_of_macros();
}
extern "C" {
    pub fn truncate_undo_list(arg1: *mut buffer);
}
extern "C" {
    pub fn record_insert(arg1: isize, arg2: isize);
}
extern "C" {
    pub fn record_delete(arg1: isize, arg2: Lisp_Object, arg3: bool);
}
extern "C" {
    pub fn record_first_change();
}
extern "C" {
    pub fn record_change(arg1: isize, arg2: isize);
}
extern "C" {
    pub fn record_property_change(
        arg1: isize,
        arg2: isize,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    );
}
extern "C" {
    pub fn syms_of_undo();
}
extern "C" {
    pub fn report_interval_modification(arg1: Lisp_Object, arg2: Lisp_Object);
}
extern "C" {
    pub fn syms_of_menu();
}
extern "C" {
    pub fn syms_of_xmenu();
}
extern "C" {
    pub fn maybe_disable_address_randomization(
        arg1: ::libc::c_int,
        arg2: *mut *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn emacs_exec_file(
        arg1: *const ::libc::c_char,
        arg2: *const *mut ::libc::c_char,
        arg3: *const *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn init_standard_fds();
}
extern "C" {
    pub fn emacs_get_current_dir_name() -> *mut ::libc::c_char;
}
extern "C" {
    pub fn stuff_char(c: ::libc::c_char);
}
extern "C" {
    pub fn init_foreground_group();
}
extern "C" {
    pub fn sys_subshell();
}
extern "C" {
    pub fn sys_suspend();
}
extern "C" {
    pub fn discard_tty_input();
}
extern "C" {
    pub fn init_sys_modes(arg1: *mut tty_display_info);
}
extern "C" {
    pub fn reset_sys_modes(arg1: *mut tty_display_info);
}
extern "C" {
    pub fn init_all_sys_modes();
}
extern "C" {
    pub fn reset_all_sys_modes();
}
extern "C" {
    pub fn child_setup_tty(arg1: ::libc::c_int);
}
extern "C" {
    pub fn setup_pty(arg1: ::libc::c_int);
}
extern "C" {
    pub fn set_window_size(
        arg1: ::libc::c_int,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn get_random() -> EMACS_INT;
}
extern "C" {
    pub fn seed_random(arg1: *mut ::libc::c_void, arg2: isize);
}
extern "C" {
    pub fn init_random();
}
extern "C" {
    pub fn emacs_backtrace(arg1: ::libc::c_int);
}
extern "C" {
    pub fn emacs_fstatat(
        arg1: ::libc::c_int,
        arg2: *const ::libc::c_char,
        arg3: *mut ::libc::c_void,
        arg4: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn emacs_openat(
        arg1: ::libc::c_int,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn emacs_open(
        arg1: *const ::libc::c_char,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn emacs_open_noquit(
        arg1: *const ::libc::c_char,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn emacs_pipe(arg1: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn emacs_close(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn emacs_read(arg1: ::libc::c_int, arg2: *mut ::libc::c_void, arg3: isize) -> isize;
}
extern "C" {
    pub fn emacs_read_quit(arg1: ::libc::c_int, arg2: *mut ::libc::c_void, arg3: isize) -> isize;
}
extern "C" {
    pub fn emacs_write(arg1: ::libc::c_int, arg2: *const ::libc::c_void, arg3: isize) -> isize;
}
extern "C" {
    pub fn emacs_write_sig(arg1: ::libc::c_int, arg2: *const ::libc::c_void, arg3: isize) -> isize;
}
extern "C" {
    pub fn emacs_write_quit(arg1: ::libc::c_int, arg2: *const ::libc::c_void, arg3: isize)
        -> isize;
}
extern "C" {
    pub fn emacs_perror(arg1: *const ::libc::c_char);
}
extern "C" {
    pub fn renameat_noreplace(
        arg1: ::libc::c_int,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_int,
        arg4: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn str_collate(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn syms_of_sysdep();
}
extern "C" {
    pub fn lock_file(arg1: Lisp_Object);
}
extern "C" {
    pub fn unlock_file(arg1: Lisp_Object);
}
extern "C" {
    pub fn unlock_all_files();
}
extern "C" {
    pub fn unlock_buffer(arg1: *mut buffer);
}
extern "C" {
    pub fn syms_of_filelock();
}
extern "C" {
    pub fn syms_of_sound();
}
extern "C" {
    pub fn init_category_once();
}
extern "C" {
    pub fn char_category_set(arg1: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn syms_of_category();
}
extern "C" {
    pub fn syms_of_ccl();
}
extern "C" {
    pub fn syms_of_dired();
}
extern "C" {
    pub fn directory_files_internal(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: bool,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}char_ins_del_vector"]
    pub static mut char_ins_del_vector: *mut ::libc::c_int;
}
extern "C" {
    pub fn syms_of_term();
}
extern "C" {
    pub fn fatal(msgid: *const ::libc::c_char, ...);
}
extern "C" {
    pub fn syms_of_terminal();
}
extern "C" {
    pub fn syms_of_font();
}
extern "C" {
    pub fn init_font();
}
extern "C" {
    pub fn syms_of_fontset();
}
extern "C" {
    pub fn syms_of_inotify();
}
extern "C" {
    #[link_name = "\u{1}Vface_alternative_font_family_alist"]
    pub static mut Vface_alternative_font_family_alist: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}Vface_alternative_font_registry_alist"]
    pub static mut Vface_alternative_font_registry_alist: Lisp_Object;
}
extern "C" {
    pub fn syms_of_xfaces();
}
extern "C" {
    pub fn init_xfaces();
}
extern "C" {
    pub fn syms_of_wrterm();
}
extern "C" {
    pub fn get_keysym_name(arg1: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn syms_of_xml();
}
extern "C" {
    pub fn xml_cleanup_parser();
}
extern "C" {
    pub fn syms_of_lcms2();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::libc::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::libc::c_uint,
    pub __wchb: [::libc::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::libc::c_int,
    pub _IO_read_ptr: *mut ::libc::c_char,
    pub _IO_read_end: *mut ::libc::c_char,
    pub _IO_read_base: *mut ::libc::c_char,
    pub _IO_write_base: *mut ::libc::c_char,
    pub _IO_write_ptr: *mut ::libc::c_char,
    pub _IO_write_end: *mut ::libc::c_char,
    pub _IO_buf_base: *mut ::libc::c_char,
    pub _IO_buf_end: *mut ::libc::c_char,
    pub _IO_save_base: *mut ::libc::c_char,
    pub _IO_backup_base: *mut ::libc::c_char,
    pub _IO_save_end: *mut ::libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::libc::c_int,
    pub _flags2: ::libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::libc::c_ushort,
    pub _vtable_offset: ::libc::c_schar,
    pub _shortbuf: [::libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::libc::c_void,
    pub __pad5: usize,
    pub _mode: ::libc::c_int,
    pub _unused2: [::libc::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::libc::c_void,
        __buf: *mut ::libc::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::libc::c_void,
        __buf: *const ::libc::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::libc::c_void,
        __pos: *mut __off64_t,
        __w: ::libc::c_int,
    ) -> ::libc::c_int,
>;
pub type cookie_close_function_t =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void) -> ::libc::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).write as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).seek as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).close as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
impl Default for _IO_cookie_io_functions_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type fpos_t = __fpos_t;
pub type fpos64_t = __fpos64_t;
extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::libc::c_char, __new: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::libc::c_int,
        __old: *const ::libc::c_char,
        __newfd: ::libc::c_int,
        __new: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn renameat2(
        __oldfd: ::libc::c_int,
        __old: *const ::libc::c_char,
        __newfd: ::libc::c_int,
        __new: *const ::libc::c_char,
        __flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::libc::c_char,
        __pfx: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fcloseall() -> ::libc::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::libc::c_char, __modes: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::libc::c_char,
        __modes: *const ::libc::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(__filename: *const ::libc::c_char, __modes: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen64(
        __filename: *const ::libc::c_char,
        __modes: *const ::libc::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::libc::c_int, __modes: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::libc::c_void,
        __modes: *const ::libc::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::libc::c_void,
        __len: usize,
        __modes: *const ::libc::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::libc::c_char, __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::libc::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::libc::c_char,
        __modes: ::libc::c_int,
        __n: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::libc::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::libc::c_char, __format: *const ::libc::c_char, ...)
        -> ::libc::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::libc::c_char, __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::libc::c_char,
        __format: *const ::libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::libc::c_char,
        __maxlen: usize,
        __format: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::libc::c_char,
        __maxlen: usize,
        __format: *const ::libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::libc::c_char,
        __f: *const ::libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::libc::c_char,
        __fmt: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::libc::c_char,
        __fmt: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::libc::c_int,
        __fmt: *const ::libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::libc::c_int, __fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::libc::c_char,
        __format: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::libc::c_char,
        __format: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::libc::c_char, __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::libc::c_char,
        __format: *const ::libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::libc::c_char, __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::libc::c_char,
        __format: *const ::libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getchar() -> ::libc::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::libc::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fputc(__c: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putc(__c: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putchar(__c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putw(__w: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::libc::c_char,
        __n: ::libc::c_int,
        __stream: *mut FILE,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn fgets_unlocked(
        __s: *mut ::libc::c_char,
        __n: ::libc::c_int,
        __stream: *mut FILE,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::libc::c_char,
        __n: *mut usize,
        __delimiter: ::libc::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::libc::c_char,
        __n: *mut usize,
        __delimiter: ::libc::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::libc::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::libc::c_char, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::libc::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> ::libc::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::libc::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> ::libc::c_ulong;
}
extern "C" {
    pub fn fputs_unlocked(__s: *const ::libc::c_char, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::libc::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::libc::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::libc::c_long,
        __whence: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::libc::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fseeko64(
        __stream: *mut FILE,
        __off: __off64_t,
        __whence: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
}
extern "C" {
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t) -> ::libc::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::libc::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::libc::c_char, __modes: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn cuserid(__s: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
extern "C" {
    pub fn obstack_printf(
        __obstack: *mut obstack,
        __format: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn obstack_vprintf(
        __obstack: *mut obstack,
        __format: *const ::libc::c_char,
        __args: *mut __va_list_tag,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn md5_gz_stream(arg1: *mut FILE, arg2: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn syms_of_decompress();
}
extern "C" {
    pub fn init_dbusbind();
}
extern "C" {
    pub fn syms_of_dbusbind();
}
extern "C" {
    #[link_name = "\u{1}profiler_memory_running"]
    pub static mut profiler_memory_running: bool;
}
extern "C" {
    pub fn malloc_probe(arg1: usize);
}
extern "C" {
    pub fn syms_of_profiler();
}
extern "C" {
    pub fn SUBR_NATIVE_COMPILEDP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn SUBR_NATIVE_COMPILED_DYNP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn SUBR_TYPE(a: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn allocate_native_comp_unit() -> *mut Lisp_Native_Comp_Unit;
}
extern "C" {
    #[link_name = "\u{1}my_edata"]
    pub static mut my_edata: [::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}my_endbss"]
    pub static mut my_endbss: [::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}my_endbss_static"]
    pub static mut my_endbss_static: *mut ::libc::c_char;
}
extern "C" {
    pub fn xmalloc(arg1: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn xzalloc(arg1: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn xrealloc(arg1: *mut ::libc::c_void, arg2: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn xfree(arg1: *mut ::libc::c_void);
}
extern "C" {
    pub fn xnmalloc(arg1: isize, arg2: isize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn xnrealloc(arg1: *mut ::libc::c_void, arg2: isize, arg3: isize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn xpalloc(
        arg1: *mut ::libc::c_void,
        arg2: *mut isize,
        arg3: isize,
        arg4: isize,
        arg5: isize,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn xstrdup(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn xlispstrdup(arg1: Lisp_Object) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn dupstring(arg1: *mut *mut ::libc::c_char, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn lispstpcpy(dest: *mut ::libc::c_char, string: Lisp_Object) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __lsan_ignore_object(p: *const ::libc::c_void);
}
extern "C" {
    pub fn xputenv(arg1: *const ::libc::c_char);
}
extern "C" {
    pub fn egetenv_internal(arg1: *const ::libc::c_char, arg2: isize) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn egetenv(var: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn init_system_name();
}
pub mod MAX_ALLOCA {
    pub type Type = u32;
    pub const MAX_ALLOCA: Type = 16384;
}
extern "C" {
    pub fn record_xmalloc(arg1: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn safe_free(sa_count: isize);
}
extern "C" {
    pub fn safe_free_unbind_to(count: isize, sa_count: isize, val: Lisp_Object) -> Lisp_Object;
}
pub mod _bindgen_ty_21 {
    pub type Type = u32;
    pub const defined_GC_CHECK_STRING_BYTES: Type = 0;
}
pub mod _bindgen_ty_22 {
    pub type Type = u32;
    pub const USE_STACK_CONS: Type = 1;
    pub const USE_STACK_STRING: Type = 1;
}
pub mod _bindgen_ty_23 {
    pub type Type = u32;
    pub const SMALL_LIST_LEN_MAX: Type = 127;
}
#[repr(C)]
pub struct for_each_tail_internal {
    pub tortoise: Lisp_Object,
    pub max: isize,
    pub n: isize,
    pub q: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_for_each_tail_internal() {
    assert_eq!(
        ::std::mem::size_of::<for_each_tail_internal>(),
        32usize,
        concat!("Size of: ", stringify!(for_each_tail_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<for_each_tail_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(for_each_tail_internal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<for_each_tail_internal>())).tortoise as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(for_each_tail_internal),
            "::",
            stringify!(tortoise)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<for_each_tail_internal>())).max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(for_each_tail_internal),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<for_each_tail_internal>())).n as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(for_each_tail_internal),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<for_each_tail_internal>())).q as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(for_each_tail_internal),
            "::",
            stringify!(q)
        )
    );
}
impl Default for for_each_tail_internal {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn maybe_gc();
}
pub mod atimer_type {
    pub type Type = u32;
    pub const ATIMER_ABSOLUTE: Type = 0;
    pub const ATIMER_RELATIVE: Type = 1;
    pub const ATIMER_CONTINUOUS: Type = 2;
}
pub type atimer_callback = ::std::option::Option<unsafe extern "C" fn(timer: *mut atimer)>;
#[repr(C)]
pub struct atimer {
    pub type_: atimer_type::Type,
    pub expiration: timespec,
    pub interval: timespec,
    pub fn_: atimer_callback,
    pub client_data: *mut ::libc::c_void,
    pub next: *mut atimer,
}
#[test]
fn bindgen_test_layout_atimer() {
    assert_eq!(
        ::std::mem::size_of::<atimer>(),
        64usize,
        concat!("Size of: ", stringify!(atimer))
    );
    assert_eq!(
        ::std::mem::align_of::<atimer>(),
        8usize,
        concat!("Alignment of ", stringify!(atimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atimer>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atimer),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atimer>())).expiration as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atimer),
            "::",
            stringify!(expiration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atimer>())).interval as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(atimer),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atimer>())).fn_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(atimer),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atimer>())).client_data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(atimer),
            "::",
            stringify!(client_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atimer>())).next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(atimer),
            "::",
            stringify!(next)
        )
    );
}
impl Default for atimer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn start_atimer(
        arg1: atimer_type::Type,
        arg2: timespec,
        arg3: atimer_callback,
        arg4: *mut ::libc::c_void,
    ) -> *mut atimer;
}
extern "C" {
    pub fn cancel_atimer(arg1: *mut atimer);
}
extern "C" {
    pub fn do_pending_atimers();
}
extern "C" {
    pub fn init_atimer();
}
extern "C" {
    pub fn turn_on_atimers(arg1: bool);
}
extern "C" {
    pub fn stop_other_atimers(arg1: *mut atimer);
}
extern "C" {
    pub fn run_all_atimers();
}
extern "C" {
    pub fn timerfd_callback(arg1: ::libc::c_int, arg2: *mut ::libc::c_void);
}
extern "C" {
    #[link_name = "\u{1}interrupt_input_blocked"]
    pub static mut interrupt_input_blocked: ::libc::c_int;
}
extern "C" {
    pub fn block_input();
}
extern "C" {
    pub fn unblock_input();
}
extern "C" {
    pub fn totally_unblock_input();
}
extern "C" {
    pub fn unblock_input_to(arg1: ::libc::c_int);
}
extern "C" {
    pub fn input_blocked_p() -> bool;
}
pub mod _bindgen_ty_24 {
    pub type Type = u32;
    pub const MAX_CHAR: Type = 4194303;
}
pub mod _bindgen_ty_25 {
    pub type Type = u32;
    pub const MAX_UNICODE_CHAR: Type = 1114111;
}
pub mod _bindgen_ty_26 {
    pub type Type = u32;
    pub const MAX_1_BYTE_CHAR: Type = 127;
}
pub mod _bindgen_ty_27 {
    pub type Type = u32;
    pub const MAX_2_BYTE_CHAR: Type = 2047;
}
pub mod _bindgen_ty_28 {
    pub type Type = u32;
    pub const MAX_3_BYTE_CHAR: Type = 65535;
}
pub mod _bindgen_ty_29 {
    pub type Type = u32;
    pub const MAX_4_BYTE_CHAR: Type = 2097151;
}
pub mod _bindgen_ty_30 {
    pub type Type = u32;
    pub const MAX_5_BYTE_CHAR: Type = 4194175;
}
pub mod _bindgen_ty_31 {
    pub type Type = u32;
    pub const MIN_MULTIBYTE_LEADING_CODE: Type = 192;
}
pub mod _bindgen_ty_32 {
    pub type Type = u32;
    pub const MAX_MULTIBYTE_LEADING_CODE: Type = 248;
}
pub mod _bindgen_ty_33 {
    pub type Type = u32;
    pub const NO_BREAK_SPACE: Type = 160;
    pub const SOFT_HYPHEN: Type = 173;
    pub const ZERO_WIDTH_NON_JOINER: Type = 8204;
    pub const ZERO_WIDTH_JOINER: Type = 8205;
    pub const HYPHEN: Type = 8208;
    pub const NON_BREAKING_HYPHEN: Type = 8209;
    pub const LEFT_SINGLE_QUOTATION_MARK: Type = 8216;
    pub const RIGHT_SINGLE_QUOTATION_MARK: Type = 8217;
    pub const PARAGRAPH_SEPARATOR: Type = 8233;
    pub const LEFT_POINTING_ANGLE_BRACKET: Type = 9001;
    pub const RIGHT_POINTING_ANGLE_BRACKET: Type = 9002;
    pub const LEFT_ANGLE_BRACKET: Type = 12296;
    pub const RIGHT_ANGLE_BRACKET: Type = 12297;
    pub const OBJECT_REPLACEMENT_CHARACTER: Type = 65532;
}
extern "C" {
    pub fn char_string(arg1: ::libc::c_uint, arg2: *mut ::libc::c_uchar) -> ::libc::c_int;
}
extern "C" {
    pub fn SINGLE_BYTE_CHAR_P(c: intmax_t) -> bool;
}
extern "C" {
    pub fn CHAR_BYTE8_P(c: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn BYTE8_TO_CHAR(byte: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn UNIBYTE_TO_CHAR(byte: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn CHAR_TO_BYTE8(c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn CHAR_TO_BYTE_SAFE(c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn CHAR_BYTE8_HEAD_P(byte: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn make_char_multibyte(c: ::libc::c_int) -> ::libc::c_int;
}
pub mod _bindgen_ty_34 {
    pub type Type = u32;
    pub const MAX_MULTIBYTE_LENGTH: Type = 5;
}
extern "C" {
    pub fn CHAR_VALID_P(c: intmax_t) -> bool;
}
extern "C" {
    pub fn CHARACTERP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_CHARACTER(x: Lisp_Object);
}
extern "C" {
    pub fn CHECK_CHARACTER_CAR(x: Lisp_Object);
}
extern "C" {
    pub fn CHECK_CHARACTER_CDR(x: Lisp_Object);
}
extern "C" {
    pub fn CHAR_PRINTABLE_P(c: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn CHAR_BYTES(c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn CHAR_LEADING_CODE(c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn CHAR_STRING(c: ::libc::c_int, p: *mut ::libc::c_uchar) -> ::libc::c_int;
}
extern "C" {
    pub fn BYTE8_STRING(b: ::libc::c_int, p: *mut ::libc::c_uchar) -> ::libc::c_int;
}
extern "C" {
    pub fn LEADING_CODE_P(byte: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn TRAILING_CODE_P(byte: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn CHAR_HEAD_P(byte: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn BYTES_BY_CHAR_HEAD(byte: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn multibyte_length(
        p: *const ::libc::c_uchar,
        pend: *const ::libc::c_uchar,
        check: bool,
        allow_8bit: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn raw_prev_char_len(p: *const ::libc::c_uchar) -> ::libc::c_int;
}
extern "C" {
    pub fn string_char_and_length(
        p: *const ::libc::c_uchar,
        length: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn STRING_CHAR(p: *const ::libc::c_uchar) -> ::libc::c_int;
}
extern "C" {
    pub fn string_char_advance(pp: *mut *const ::libc::c_uchar) -> ::libc::c_int;
}
extern "C" {
    pub fn fetch_string_char_advance(
        string: Lisp_Object,
        charidx: *mut isize,
        byteidx: *mut isize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fetch_string_char_as_multibyte_advance(
        string: Lisp_Object,
        charidx: *mut isize,
        byteidx: *mut isize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fetch_string_char_advance_no_check(
        string: Lisp_Object,
        charidx: *mut isize,
        byteidx: *mut isize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn CHAR_VARIATION_SELECTOR_P(c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn char_surrogate_p(c: ::libc::c_int) -> bool;
}
pub mod unicode_category_t {
    pub type Type = u32;
    pub const UNICODE_CATEGORY_UNKNOWN: Type = 0;
    pub const UNICODE_CATEGORY_Lu: Type = 1;
    pub const UNICODE_CATEGORY_Ll: Type = 2;
    pub const UNICODE_CATEGORY_Lt: Type = 3;
    pub const UNICODE_CATEGORY_Lm: Type = 4;
    pub const UNICODE_CATEGORY_Lo: Type = 5;
    pub const UNICODE_CATEGORY_Mn: Type = 6;
    pub const UNICODE_CATEGORY_Mc: Type = 7;
    pub const UNICODE_CATEGORY_Me: Type = 8;
    pub const UNICODE_CATEGORY_Nd: Type = 9;
    pub const UNICODE_CATEGORY_Nl: Type = 10;
    pub const UNICODE_CATEGORY_No: Type = 11;
    pub const UNICODE_CATEGORY_Pc: Type = 12;
    pub const UNICODE_CATEGORY_Pd: Type = 13;
    pub const UNICODE_CATEGORY_Ps: Type = 14;
    pub const UNICODE_CATEGORY_Pe: Type = 15;
    pub const UNICODE_CATEGORY_Pi: Type = 16;
    pub const UNICODE_CATEGORY_Pf: Type = 17;
    pub const UNICODE_CATEGORY_Po: Type = 18;
    pub const UNICODE_CATEGORY_Sm: Type = 19;
    pub const UNICODE_CATEGORY_Sc: Type = 20;
    pub const UNICODE_CATEGORY_Sk: Type = 21;
    pub const UNICODE_CATEGORY_So: Type = 22;
    pub const UNICODE_CATEGORY_Zs: Type = 23;
    pub const UNICODE_CATEGORY_Zl: Type = 24;
    pub const UNICODE_CATEGORY_Zp: Type = 25;
    pub const UNICODE_CATEGORY_Cc: Type = 26;
    pub const UNICODE_CATEGORY_Cf: Type = 27;
    pub const UNICODE_CATEGORY_Cs: Type = 28;
    pub const UNICODE_CATEGORY_Co: Type = 29;
    pub const UNICODE_CATEGORY_Cn: Type = 30;
}
extern "C" {
    pub fn char_resolve_modifier_mask(arg1: EMACS_INT) -> EMACS_INT;
}
extern "C" {
    pub fn translate_char(arg1: Lisp_Object, c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn count_size_as_multibyte(arg1: *const ::libc::c_uchar, arg2: isize) -> isize;
}
extern "C" {
    pub fn str_as_multibyte(
        arg1: *mut ::libc::c_uchar,
        arg2: isize,
        arg3: isize,
        arg4: *mut isize,
    ) -> isize;
}
extern "C" {
    pub fn str_to_multibyte(arg1: *mut ::libc::c_uchar, arg2: isize, arg3: isize) -> isize;
}
extern "C" {
    pub fn str_as_unibyte(arg1: *mut ::libc::c_uchar, arg2: isize) -> isize;
}
extern "C" {
    pub fn str_to_unibyte(
        arg1: *const ::libc::c_uchar,
        arg2: *mut ::libc::c_uchar,
        arg3: isize,
    ) -> isize;
}
extern "C" {
    pub fn strwidth(arg1: *const ::libc::c_char, arg2: isize) -> isize;
}
extern "C" {
    pub fn c_string_width(
        arg1: *const ::libc::c_uchar,
        arg2: isize,
        arg3: ::libc::c_int,
        arg4: *mut isize,
        arg5: *mut isize,
    ) -> isize;
}
extern "C" {
    pub fn lisp_string_width(
        arg1: Lisp_Object,
        arg2: isize,
        arg3: *mut isize,
        arg4: *mut isize,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}Vchar_unify_table"]
    pub static mut Vchar_unify_table: Lisp_Object;
}
extern "C" {
    pub fn string_escape_byte8(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn alphabeticp(arg1: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn alphanumericp(arg1: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn graphicp(arg1: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn printablep(arg1: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn blankp(arg1: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn graphic_base_p(arg1: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn char_table_translate(obj: Lisp_Object, ch: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}hexdigit"]
    pub static mut hexdigit: [::libc::c_schar; 0usize];
}
extern "C" {
    pub fn char_hexdigit(c: ::libc::c_int) -> ::libc::c_int;
}
pub mod _bindgen_ty_35 {
    pub type Type = u32;
    pub const BEG: Type = 1;
    pub const BEG_BYTE: Type = 1;
}
extern "C" {
    pub fn set_point(arg1: isize);
}
extern "C" {
    pub fn temp_set_point(arg1: *mut buffer, arg2: isize);
}
extern "C" {
    pub fn set_point_both(arg1: isize, arg2: isize);
}
extern "C" {
    pub fn temp_set_point_both(arg1: *mut buffer, arg2: isize, arg3: isize);
}
extern "C" {
    pub fn set_point_from_marker(arg1: Lisp_Object);
}
extern "C" {
    pub fn enlarge_buffer_text(arg1: *mut buffer, arg2: isize);
}
extern "C" {
    pub fn SET_PT(position: isize);
}
extern "C" {
    pub fn TEMP_SET_PT(position: isize);
}
extern "C" {
    pub fn SET_PT_BOTH(position: isize, byte: isize);
}
extern "C" {
    pub fn TEMP_SET_PT_BOTH(position: isize, byte: isize);
}
extern "C" {
    pub fn BUF_TEMP_SET_PT(buffer: *mut buffer, position: isize);
}
pub mod _bindgen_ty_36 {
    pub type Type = u32;
    pub const GAP_BYTES_DFL: Type = 2000;
}
pub mod _bindgen_ty_37 {
    pub type Type = u32;
    pub const GAP_BYTES_MIN: Type = 20;
}
extern "C" {
    pub fn advance_to_char_boundary(byte_pos: isize) -> isize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buffer_text {
    pub beg: *mut ::libc::c_uchar,
    pub gpt: isize,
    pub z: isize,
    pub gpt_byte: isize,
    pub z_byte: isize,
    pub gap_size: isize,
    pub modiff: modiff_count,
    pub chars_modiff: modiff_count,
    pub save_modiff: modiff_count,
    pub overlay_modiff: modiff_count,
    pub compact: modiff_count,
    pub beg_unchanged: isize,
    pub end_unchanged: isize,
    pub unchanged_modified: modiff_count,
    pub overlay_unchanged_modified: modiff_count,
    pub intervals: INTERVAL,
    pub markers: *mut Lisp_Marker,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_buffer_text() {
    assert_eq!(
        ::std::mem::size_of::<buffer_text>(),
        144usize,
        concat!("Size of: ", stringify!(buffer_text))
    );
    assert_eq!(
        ::std::mem::align_of::<buffer_text>(),
        8usize,
        concat!("Alignment of ", stringify!(buffer_text))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).beg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(beg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).gpt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(gpt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).gpt_byte as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(gpt_byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).z_byte as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(z_byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).gap_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(gap_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).modiff as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(modiff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).chars_modiff as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(chars_modiff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).save_modiff as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(save_modiff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).overlay_modiff as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(overlay_modiff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).compact as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(compact)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).beg_unchanged as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(beg_unchanged)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).end_unchanged as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(end_unchanged)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).unchanged_modified as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(unchanged_modified)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<buffer_text>())).overlay_unchanged_modified as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(overlay_unchanged_modified)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).intervals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(intervals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer_text>())).markers as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer_text),
            "::",
            stringify!(markers)
        )
    );
}
impl Default for buffer_text {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl buffer_text {
    #[inline]
    pub fn inhibit_shrinking(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inhibit_shrinking(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redisplay(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redisplay(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inhibit_shrinking: bool_bf,
        redisplay: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inhibit_shrinking: u8 = unsafe { ::std::mem::transmute(inhibit_shrinking) };
            inhibit_shrinking as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let redisplay: u8 = unsafe { ::std::mem::transmute(redisplay) };
            redisplay as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod _bindgen_ty_38 {
    pub type Type = u32;
    pub const MAX_PER_BUFFER_VARS: Type = 50;
}
pub mod _bindgen_ty_39 {
    pub type Type = i32;
    pub const NONEXISTENT_MODTIME_NSECS: Type = -1;
}
pub mod _bindgen_ty_40 {
    pub type Type = i32;
    pub const UNKNOWN_MODTIME_NSECS: Type = -2;
}
#[repr(C)]
pub struct buffer {
    pub header: vectorlike_header,
    pub name_: Lisp_Object,
    pub filename_: Lisp_Object,
    pub directory_: Lisp_Object,
    pub backed_up_: Lisp_Object,
    pub save_length_: Lisp_Object,
    pub auto_save_file_name_: Lisp_Object,
    pub read_only_: Lisp_Object,
    pub mark_: Lisp_Object,
    pub local_var_alist_: Lisp_Object,
    pub major_mode_: Lisp_Object,
    pub local_minor_modes_: Lisp_Object,
    pub mode_name_: Lisp_Object,
    pub mode_line_format_: Lisp_Object,
    pub header_line_format_: Lisp_Object,
    pub tab_line_format_: Lisp_Object,
    pub keymap_: Lisp_Object,
    pub abbrev_table_: Lisp_Object,
    pub syntax_table_: Lisp_Object,
    pub category_table_: Lisp_Object,
    pub case_fold_search_: Lisp_Object,
    pub tab_width_: Lisp_Object,
    pub fill_column_: Lisp_Object,
    pub left_margin_: Lisp_Object,
    pub auto_fill_function_: Lisp_Object,
    pub downcase_table_: Lisp_Object,
    pub upcase_table_: Lisp_Object,
    pub case_canon_table_: Lisp_Object,
    pub case_eqv_table_: Lisp_Object,
    pub truncate_lines_: Lisp_Object,
    pub word_wrap_: Lisp_Object,
    pub ctl_arrow_: Lisp_Object,
    pub bidi_display_reordering_: Lisp_Object,
    pub bidi_paragraph_direction_: Lisp_Object,
    pub bidi_paragraph_separate_re_: Lisp_Object,
    pub bidi_paragraph_start_re_: Lisp_Object,
    pub selective_display_: Lisp_Object,
    pub selective_display_ellipses_: Lisp_Object,
    pub overwrite_mode_: Lisp_Object,
    pub abbrev_mode_: Lisp_Object,
    pub display_table_: Lisp_Object,
    pub mark_active_: Lisp_Object,
    pub enable_multibyte_characters_: Lisp_Object,
    pub buffer_file_coding_system_: Lisp_Object,
    pub file_format_: Lisp_Object,
    pub auto_save_file_format_: Lisp_Object,
    pub cache_long_scans_: Lisp_Object,
    pub width_table_: Lisp_Object,
    pub pt_marker_: Lisp_Object,
    pub begv_marker_: Lisp_Object,
    pub zv_marker_: Lisp_Object,
    pub point_before_scroll_: Lisp_Object,
    pub file_truename_: Lisp_Object,
    pub invisibility_spec_: Lisp_Object,
    pub last_selected_window_: Lisp_Object,
    pub display_count_: Lisp_Object,
    pub left_margin_cols_: Lisp_Object,
    pub right_margin_cols_: Lisp_Object,
    pub left_fringe_width_: Lisp_Object,
    pub right_fringe_width_: Lisp_Object,
    pub fringes_outside_margins_: Lisp_Object,
    pub scroll_bar_width_: Lisp_Object,
    pub scroll_bar_height_: Lisp_Object,
    pub vertical_scroll_bar_type_: Lisp_Object,
    pub horizontal_scroll_bar_type_: Lisp_Object,
    pub indicate_empty_lines_: Lisp_Object,
    pub indicate_buffer_boundaries_: Lisp_Object,
    pub fringe_indicator_alist_: Lisp_Object,
    pub fringe_cursor_alist_: Lisp_Object,
    pub display_time_: Lisp_Object,
    pub scroll_up_aggressively_: Lisp_Object,
    pub scroll_down_aggressively_: Lisp_Object,
    pub cursor_type_: Lisp_Object,
    pub extra_line_spacing_: Lisp_Object,
    pub cursor_in_non_selected_windows_: Lisp_Object,
    pub own_text: buffer_text,
    pub text: *mut buffer_text,
    pub pt: isize,
    pub pt_byte: isize,
    pub begv: isize,
    pub begv_byte: isize,
    pub zv: isize,
    pub zv_byte: isize,
    pub base_buffer: *mut buffer,
    pub indirections: ::libc::c_int,
    pub window_count: ::libc::c_int,
    pub local_flags: [::libc::c_char; 50usize],
    pub modtime: timespec,
    pub modtime_size: off_t,
    pub auto_save_modified: modiff_count,
    pub display_error_modiff: modiff_count,
    pub auto_save_failure_time: time_t,
    pub last_window_start: isize,
    pub newline_cache: *mut region_cache,
    pub width_run_cache: *mut region_cache,
    pub bidi_paragraph_cache: *mut region_cache,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub overlays_before: *mut Lisp_Overlay,
    pub overlays_after: *mut Lisp_Overlay,
    pub overlay_center: isize,
    pub undo_list_: Lisp_Object,
}
#[test]
fn bindgen_test_layout_buffer() {
    assert_eq!(
        ::std::mem::size_of::<buffer>(),
        992usize,
        concat!("Size of: ", stringify!(buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).name_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(name_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).filename_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(filename_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).directory_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(directory_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).backed_up_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(backed_up_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).save_length_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(save_length_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).auto_save_file_name_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(auto_save_file_name_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).read_only_ as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(read_only_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).mark_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(mark_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).local_var_alist_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(local_var_alist_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).major_mode_ as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(major_mode_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).local_minor_modes_ as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(local_minor_modes_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).mode_name_ as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(mode_name_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).mode_line_format_ as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(mode_line_format_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).header_line_format_ as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(header_line_format_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).tab_line_format_ as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(tab_line_format_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).keymap_ as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(keymap_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).abbrev_table_ as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(abbrev_table_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).syntax_table_ as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(syntax_table_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).category_table_ as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(category_table_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).case_fold_search_ as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(case_fold_search_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).tab_width_ as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(tab_width_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).fill_column_ as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(fill_column_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).left_margin_ as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(left_margin_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).auto_fill_function_ as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(auto_fill_function_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).downcase_table_ as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(downcase_table_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).upcase_table_ as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(upcase_table_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).case_canon_table_ as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(case_canon_table_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).case_eqv_table_ as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(case_eqv_table_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).truncate_lines_ as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(truncate_lines_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).word_wrap_ as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(word_wrap_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).ctl_arrow_ as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(ctl_arrow_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).bidi_display_reordering_ as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(bidi_display_reordering_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<buffer>())).bidi_paragraph_direction_ as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(bidi_paragraph_direction_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<buffer>())).bidi_paragraph_separate_re_ as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(bidi_paragraph_separate_re_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).bidi_paragraph_start_re_ as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(bidi_paragraph_start_re_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).selective_display_ as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(selective_display_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<buffer>())).selective_display_ellipses_ as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(selective_display_ellipses_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).overwrite_mode_ as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(overwrite_mode_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).abbrev_mode_ as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(abbrev_mode_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).display_table_ as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(display_table_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).mark_active_ as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(mark_active_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<buffer>())).enable_multibyte_characters_ as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(enable_multibyte_characters_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<buffer>())).buffer_file_coding_system_ as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(buffer_file_coding_system_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).file_format_ as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(file_format_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).auto_save_file_format_ as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(auto_save_file_format_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).cache_long_scans_ as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(cache_long_scans_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).width_table_ as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(width_table_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).pt_marker_ as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(pt_marker_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).begv_marker_ as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(begv_marker_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).zv_marker_ as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(zv_marker_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).point_before_scroll_ as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(point_before_scroll_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).file_truename_ as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(file_truename_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).invisibility_spec_ as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(invisibility_spec_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).last_selected_window_ as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(last_selected_window_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).display_count_ as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(display_count_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).left_margin_cols_ as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(left_margin_cols_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).right_margin_cols_ as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(right_margin_cols_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).left_fringe_width_ as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(left_fringe_width_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).right_fringe_width_ as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(right_fringe_width_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).fringes_outside_margins_ as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(fringes_outside_margins_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).scroll_bar_width_ as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(scroll_bar_width_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).scroll_bar_height_ as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(scroll_bar_height_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<buffer>())).vertical_scroll_bar_type_ as *const _ as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(vertical_scroll_bar_type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<buffer>())).horizontal_scroll_bar_type_ as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(horizontal_scroll_bar_type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).indicate_empty_lines_ as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(indicate_empty_lines_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<buffer>())).indicate_buffer_boundaries_ as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(indicate_buffer_boundaries_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).fringe_indicator_alist_ as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(fringe_indicator_alist_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).fringe_cursor_alist_ as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(fringe_cursor_alist_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).display_time_ as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(display_time_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).scroll_up_aggressively_ as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(scroll_up_aggressively_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<buffer>())).scroll_down_aggressively_ as *const _ as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(scroll_down_aggressively_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).cursor_type_ as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(cursor_type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).extra_line_spacing_ as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(extra_line_spacing_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<buffer>())).cursor_in_non_selected_windows_ as *const _ as usize
        },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(cursor_in_non_selected_windows_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).own_text as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(own_text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).text as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).pt as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(pt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).pt_byte as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(pt_byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).begv as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(begv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).begv_byte as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(begv_byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).zv as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(zv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).zv_byte as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(zv_byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).base_buffer as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(base_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).indirections as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(indirections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).window_count as *const _ as usize },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(window_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).local_flags as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(local_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).modtime as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(modtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).modtime_size as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(modtime_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).auto_save_modified as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(auto_save_modified)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).display_error_modiff as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(display_error_modiff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).auto_save_failure_time as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(auto_save_failure_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).last_window_start as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(last_window_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).newline_cache as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(newline_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).width_run_cache as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(width_run_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).bidi_paragraph_cache as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(bidi_paragraph_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).overlays_before as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(overlays_before)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).overlays_after as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(overlays_after)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).overlay_center as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(overlay_center)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffer>())).undo_list_ as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(buffer),
            "::",
            stringify!(undo_list_)
        )
    );
}
impl Default for buffer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl buffer {
    #[inline]
    pub fn prevent_redisplay_optimizations_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_prevent_redisplay_optimizations_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clip_changed(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_clip_changed(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inhibit_buffer_hooks(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inhibit_buffer_hooks(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        prevent_redisplay_optimizations_p: bool_bf,
        clip_changed: bool_bf,
        inhibit_buffer_hooks: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let prevent_redisplay_optimizations_p: u8 =
                unsafe { ::std::mem::transmute(prevent_redisplay_optimizations_p) };
            prevent_redisplay_optimizations_p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let clip_changed: u8 = unsafe { ::std::mem::transmute(clip_changed) };
            clip_changed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let inhibit_buffer_hooks: u8 = unsafe { ::std::mem::transmute(inhibit_buffer_hooks) };
            inhibit_buffer_hooks as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn BUFFERP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_BUFFER(x: Lisp_Object);
}
extern "C" {
    pub fn XBUFFER(a: Lisp_Object) -> *mut buffer;
}
extern "C" {
    pub fn bset_bidi_paragraph_direction(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_cache_long_scans(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_case_canon_table(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_case_eqv_table(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_directory(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_display_count(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_left_margin_cols(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_right_margin_cols(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_display_time(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_downcase_table(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_enable_multibyte_characters(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_filename(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_keymap(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_last_selected_window(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_local_var_alist(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_mark_active(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_point_before_scroll(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_read_only(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_truncate_lines(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_undo_list(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_upcase_table(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn bset_width_table(b: *mut buffer, val: Lisp_Object);
}
extern "C" {
    pub fn BUFFER_CEILING_OF(bytepos: isize) -> isize;
}
extern "C" {
    pub fn BUFFER_FLOOR_OF(bytepos: isize) -> isize;
}
extern "C" {
    pub fn BUF_BEGV(buf: *mut buffer) -> isize;
}
extern "C" {
    pub fn BUF_BEGV_BYTE(buf: *mut buffer) -> isize;
}
extern "C" {
    pub fn BUF_PT(buf: *mut buffer) -> isize;
}
extern "C" {
    pub fn BUF_PT_BYTE(buf: *mut buffer) -> isize;
}
extern "C" {
    pub fn BUF_ZV(buf: *mut buffer) -> isize;
}
extern "C" {
    pub fn BUF_ZV_BYTE(buf: *mut buffer) -> isize;
}
extern "C" {
    pub fn BUF_BEG(buf: *mut buffer) -> isize;
}
extern "C" {
    pub fn BUF_BEG_BYTE(buf: *mut buffer) -> isize;
}
extern "C" {
    pub fn BUF_GPT_ADDR(buf: *mut buffer) -> *mut ::libc::c_uchar;
}
extern "C" {
    pub fn BUF_Z_ADDR(buf: *mut buffer) -> *mut ::libc::c_uchar;
}
extern "C" {
    pub fn BUF_GAP_END_ADDR(buf: *mut buffer) -> *mut ::libc::c_uchar;
}
extern "C" {
    pub fn BUF_COMPUTE_UNCHANGED(buf: *mut buffer, start: isize, end: isize);
}
extern "C" {
    pub fn SET_BUF_BEGV(buf: *mut buffer, charpos: isize);
}
extern "C" {
    pub fn SET_BUF_ZV(buf: *mut buffer, charpos: isize);
}
extern "C" {
    pub fn SET_BUF_BEGV_BOTH(buf: *mut buffer, charpos: isize, byte: isize);
}
extern "C" {
    pub fn SET_BUF_ZV_BOTH(buf: *mut buffer, charpos: isize, byte: isize);
}
extern "C" {
    pub fn SET_BUF_PT_BOTH(buf: *mut buffer, charpos: isize, byte: isize);
}
extern "C" {
    pub fn BYTE_POS_ADDR(n: isize) -> *mut ::libc::c_uchar;
}
extern "C" {
    pub fn CHAR_POS_ADDR(n: isize) -> *mut ::libc::c_uchar;
}
extern "C" {
    pub fn CHAR_TO_BYTE(charpos: isize) -> isize;
}
extern "C" {
    pub fn BYTE_TO_CHAR(bytepos: isize) -> isize;
}
extern "C" {
    pub fn PTR_BYTE_POS(ptr: *const ::libc::c_uchar) -> isize;
}
pub mod _bindgen_ty_41 {
    pub type Type = u32;
    pub const BUFFER_LISP_SIZE: Type = 74;
}
pub mod _bindgen_ty_42 {
    pub type Type = u32;
    pub const BUFFER_REST_SIZE: Type = 49;
}
extern "C" {
    pub fn BUFFER_PVEC_INIT(b: *mut buffer);
}
extern "C" {
    pub fn BUFFER_LIVE_P(b: *mut buffer) -> bool;
}
extern "C" {
    pub fn BUFFER_HIDDEN_P(b: *mut buffer) -> bool;
}
extern "C" {
    pub fn BUFFER_CHECK_INDIRECTION(b: *mut buffer);
}
extern "C" {
    #[link_name = "\u{1}buffer_defaults"]
    pub static mut buffer_defaults: buffer;
}
extern "C" {
    #[link_name = "\u{1}buffer_local_flags"]
    pub static mut buffer_local_flags: buffer;
}
extern "C" {
    #[link_name = "\u{1}buffer_local_symbols"]
    pub static mut buffer_local_symbols: buffer;
}
extern "C" {
    #[link_name = "\u{1}interval_insert_behind_hooks"]
    pub static mut interval_insert_behind_hooks: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}interval_insert_in_front_hooks"]
    pub static mut interval_insert_in_front_hooks: Lisp_Object;
}
extern "C" {
    pub fn fix_position(arg1: Lisp_Object) -> EMACS_INT;
}
extern "C" {
    pub fn delete_all_overlays(arg1: *mut buffer);
}
extern "C" {
    pub fn reset_buffer(arg1: *mut buffer);
}
extern "C" {
    pub fn compact_buffer(arg1: *mut buffer);
}
extern "C" {
    pub fn evaporate_overlays(arg1: isize);
}
extern "C" {
    pub fn overlays_at(
        arg1: EMACS_INT,
        arg2: bool,
        arg3: *mut *mut Lisp_Object,
        arg4: *mut isize,
        arg5: *mut isize,
        arg6: *mut isize,
        arg7: bool,
    ) -> isize;
}
extern "C" {
    pub fn sort_overlays(arg1: *mut Lisp_Object, arg2: isize, arg3: *mut window) -> isize;
}
extern "C" {
    pub fn recenter_overlay_lists(arg1: *mut buffer, arg2: isize);
}
extern "C" {
    pub fn overlay_strings(
        arg1: isize,
        arg2: *mut window,
        arg3: *mut *mut ::libc::c_uchar,
    ) -> isize;
}
extern "C" {
    pub fn validate_region(arg1: *mut Lisp_Object, arg2: *mut Lisp_Object);
}
extern "C" {
    pub fn set_buffer_internal_1(arg1: *mut buffer);
}
extern "C" {
    pub fn set_buffer_internal_2(arg1: *mut buffer);
}
extern "C" {
    pub fn set_buffer_temp(arg1: *mut buffer);
}
extern "C" {
    pub fn buffer_local_value(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn record_buffer(arg1: Lisp_Object);
}
extern "C" {
    pub fn fix_overlays_before(arg1: *mut buffer, arg2: isize, arg3: isize);
}
extern "C" {
    pub fn mmap_set_vars(arg1: bool);
}
extern "C" {
    pub fn restore_buffer(arg1: Lisp_Object);
}
extern "C" {
    pub fn set_buffer_if_live(arg1: Lisp_Object);
}
extern "C" {
    pub fn decode_buffer(b: Lisp_Object) -> *mut buffer;
}
extern "C" {
    pub fn set_buffer_internal(b: *mut buffer);
}
extern "C" {
    pub fn record_unwind_current_buffer();
}
extern "C" {
    #[link_name = "\u{1}Vbuffer_alist"]
    pub static mut Vbuffer_alist: Lisp_Object;
}
extern "C" {
    pub fn buffer_intervals(b: *mut buffer) -> INTERVAL;
}
extern "C" {
    pub fn set_buffer_intervals(b: *mut buffer, i: INTERVAL);
}
extern "C" {
    pub fn buffer_has_overlays() -> bool;
}
extern "C" {
    pub fn FETCH_MULTIBYTE_CHAR(pos: isize) -> ::libc::c_int;
}
extern "C" {
    pub fn BUF_FETCH_MULTIBYTE_CHAR(buf: *mut buffer, pos: isize) -> ::libc::c_int;
}
extern "C" {
    pub fn FETCH_CHAR_AS_MULTIBYTE(pos: isize) -> ::libc::c_int;
}
extern "C" {
    pub fn FETCH_CHAR(pos: isize) -> ::libc::c_int;
}
extern "C" {
    pub fn BUF_BYTE_ADDRESS(buf: *mut buffer, pos: isize) -> *mut ::libc::c_uchar;
}
extern "C" {
    pub fn BUF_CHAR_ADDRESS(buf: *mut buffer, pos: isize) -> *mut ::libc::c_uchar;
}
extern "C" {
    pub fn BUF_PTR_BYTE_POS(buf: *mut buffer, ptr: *mut ::libc::c_uchar) -> isize;
}
extern "C" {
    pub fn BUF_FETCH_BYTE(buf: *mut buffer, n: isize) -> ::libc::c_uchar;
}
extern "C" {
    pub fn BUF_FETCH_CHAR_AS_MULTIBYTE(buf: *mut buffer, pos: isize) -> ::libc::c_int;
}
extern "C" {
    pub fn buffer_window_count(b: *mut buffer) -> ::libc::c_int;
}
extern "C" {
    pub fn OVERLAY_POSITION(p: Lisp_Object) -> isize;
}
extern "C" {
    pub fn valid_per_buffer_idx(arg1: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn PER_BUFFER_VALUE_P(b: *mut buffer, idx: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn SET_PER_BUFFER_VALUE_P(b: *mut buffer, idx: ::libc::c_int, val: bool);
}
extern "C" {
    pub fn PER_BUFFER_IDX(offset: isize) -> ::libc::c_int;
}
extern "C" {
    pub fn per_buffer_default(offset: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn set_per_buffer_default(offset: ::libc::c_int, value: Lisp_Object);
}
extern "C" {
    pub fn per_buffer_value(b: *mut buffer, offset: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn set_per_buffer_value(b: *mut buffer, offset: ::libc::c_int, value: Lisp_Object);
}
extern "C" {
    pub fn downcase(c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn upcase(c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn uppercasep(c: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn lowercasep(c: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn sanitize_tab_width(width: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    pub fn SANE_TAB_WIDTH(buf: *mut buffer) -> ::libc::c_int;
}
extern "C" {
    pub fn sanitize_char_width(width: EMACS_INT) -> ::libc::c_int;
}
extern "C" {
    pub fn CHARACTER_WIDTH(c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn fetch_char_advance(charidx: *mut isize, byteidx: *mut isize) -> ::libc::c_int;
}
extern "C" {
    pub fn fetch_char_advance_no_check(charidx: *mut isize, byteidx: *mut isize) -> ::libc::c_int;
}
extern "C" {
    pub fn buf_next_char_len(buf: *mut buffer, pos_byte: isize) -> ::libc::c_int;
}
extern "C" {
    pub fn next_char_len(pos_byte: isize) -> ::libc::c_int;
}
extern "C" {
    pub fn buf_prev_char_len(buf: *mut buffer, pos_byte: isize) -> ::libc::c_int;
}
extern "C" {
    pub fn prev_char_len(pos_byte: isize) -> ::libc::c_int;
}
extern "C" {
    pub fn inc_both(charpos: *mut isize, bytepos: *mut isize);
}
extern "C" {
    pub fn dec_both(charpos: *mut isize, bytepos: *mut isize);
}
extern "C" {
    pub fn CATEGORY_MEMBER(category: EMACS_INT, category_set: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHAR_HAS_CATEGORY(ch: ::libc::c_int, category: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn word_boundary_p(arg1: ::libc::c_int, arg2: ::libc::c_int) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ccl_program {
    pub idx: isize,
    pub size: ::libc::c_int,
    pub prog: *mut Lisp_Object,
    pub ic: ::libc::c_int,
    pub eof_ic: ::libc::c_int,
    pub reg: [::libc::c_int; 8usize],
    pub status: ::libc::c_int,
    pub buf_magnification: ::libc::c_int,
    pub stack_idx: ::libc::c_int,
    pub consumed: ::libc::c_int,
    pub produced: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_ccl_program() {
    assert_eq!(
        ::std::mem::size_of::<ccl_program>(),
        88usize,
        concat!("Size of: ", stringify!(ccl_program))
    );
    assert_eq!(
        ::std::mem::align_of::<ccl_program>(),
        8usize,
        concat!("Alignment of ", stringify!(ccl_program))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccl_program>())).idx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ccl_program),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccl_program>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ccl_program),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccl_program>())).prog as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ccl_program),
            "::",
            stringify!(prog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccl_program>())).ic as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ccl_program),
            "::",
            stringify!(ic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccl_program>())).eof_ic as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ccl_program),
            "::",
            stringify!(eof_ic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccl_program>())).reg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ccl_program),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccl_program>())).status as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ccl_program),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccl_program>())).buf_magnification as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ccl_program),
            "::",
            stringify!(buf_magnification)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccl_program>())).stack_idx as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ccl_program),
            "::",
            stringify!(stack_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccl_program>())).consumed as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ccl_program),
            "::",
            stringify!(consumed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccl_program>())).produced as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ccl_program),
            "::",
            stringify!(produced)
        )
    );
}
impl Default for ccl_program {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ccl_program {
    #[inline]
    pub fn last_block(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_last_block(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quit_silently(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_quit_silently(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        last_block: bool_bf,
        quit_silently: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let last_block: u8 = unsafe { ::std::mem::transmute(last_block) };
            last_block as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let quit_silently: u8 = unsafe { ::std::mem::transmute(quit_silently) };
            quit_silently as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ccl_spec {
    pub ccl: ccl_program,
}
#[test]
fn bindgen_test_layout_ccl_spec() {
    assert_eq!(
        ::std::mem::size_of::<ccl_spec>(),
        88usize,
        concat!("Size of: ", stringify!(ccl_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<ccl_spec>(),
        8usize,
        concat!("Alignment of ", stringify!(ccl_spec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ccl_spec>())).ccl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ccl_spec),
            "::",
            stringify!(ccl)
        )
    );
}
impl Default for ccl_spec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn setup_ccl_program(arg1: *mut ccl_program, arg2: Lisp_Object) -> bool;
}
extern "C" {
    pub fn ccl_driver(
        arg1: *mut ccl_program,
        arg2: *mut ::libc::c_int,
        arg3: *mut ::libc::c_int,
        arg4: ::libc::c_int,
        arg5: ::libc::c_int,
        arg6: Lisp_Object,
    );
}
pub mod define_charset_arg_index {
    pub type Type = u32;
    pub const charset_arg_name: Type = 0;
    pub const charset_arg_dimension: Type = 1;
    pub const charset_arg_code_space: Type = 2;
    pub const charset_arg_min_code: Type = 3;
    pub const charset_arg_max_code: Type = 4;
    pub const charset_arg_iso_final: Type = 5;
    pub const charset_arg_iso_revision: Type = 6;
    pub const charset_arg_emacs_mule_id: Type = 7;
    pub const charset_arg_ascii_compatible_p: Type = 8;
    pub const charset_arg_supplementary_p: Type = 9;
    pub const charset_arg_invalid_code: Type = 10;
    pub const charset_arg_code_offset: Type = 11;
    pub const charset_arg_map: Type = 12;
    pub const charset_arg_subset: Type = 13;
    pub const charset_arg_superset: Type = 14;
    pub const charset_arg_unify_map: Type = 15;
    pub const charset_arg_plist: Type = 16;
    pub const charset_arg_max: Type = 17;
}
pub mod charset_attr_index {
    pub type Type = u32;
    pub const charset_id: Type = 0;
    pub const charset_name: Type = 1;
    pub const charset_plist: Type = 2;
    pub const charset_map: Type = 3;
    pub const charset_decoder: Type = 4;
    pub const charset_encoder: Type = 5;
    pub const charset_subset: Type = 6;
    pub const charset_superset: Type = 7;
    pub const charset_unify_map: Type = 8;
    pub const charset_deunifier: Type = 9;
    pub const charset_attr_max: Type = 10;
}
pub mod charset_method {
    pub type Type = u32;
    pub const CHARSET_METHOD_OFFSET: Type = 0;
    pub const CHARSET_METHOD_MAP: Type = 1;
    pub const CHARSET_METHOD_SUBSET: Type = 2;
    pub const CHARSET_METHOD_SUPERSET: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct charset {
    pub id: ::libc::c_int,
    pub hash_index: isize,
    pub dimension: ::libc::c_int,
    pub code_space: [::libc::c_int; 15usize],
    pub code_space_mask: *mut ::libc::c_uchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub iso_final: ::libc::c_int,
    pub iso_revision: ::libc::c_int,
    pub emacs_mule_id: ::libc::c_int,
    pub method: charset_method::Type,
    pub min_code: ::libc::c_uint,
    pub max_code: ::libc::c_uint,
    pub char_index_offset: ::libc::c_uint,
    pub min_char: ::libc::c_int,
    pub max_char: ::libc::c_int,
    pub invalid_code: ::libc::c_uint,
    pub fast_map: [::libc::c_uchar; 190usize],
    pub code_offset: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_charset() {
    assert_eq!(
        ::std::mem::size_of::<charset>(),
        328usize,
        concat!("Size of: ", stringify!(charset))
    );
    assert_eq!(
        ::std::mem::align_of::<charset>(),
        8usize,
        concat!("Alignment of ", stringify!(charset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).hash_index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(hash_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).dimension as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(dimension)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).code_space as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(code_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).code_space_mask as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(code_space_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).iso_final as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(iso_final)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).iso_revision as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(iso_revision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).emacs_mule_id as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(emacs_mule_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).method as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).min_code as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(min_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).max_code as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(max_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).char_index_offset as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(char_index_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).min_char as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(min_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).max_char as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(max_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).invalid_code as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(invalid_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).fast_map as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(fast_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<charset>())).code_offset as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(charset),
            "::",
            stringify!(code_offset)
        )
    );
}
impl Default for charset {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl charset {
    #[inline]
    pub fn code_linear_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_code_linear_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn iso_chars_96(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_iso_chars_96(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ascii_compatible_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ascii_compatible_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supplementary_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supplementary_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn compact_codes_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_compact_codes_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unified_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unified_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        code_linear_p: bool_bf,
        iso_chars_96: bool_bf,
        ascii_compatible_p: bool_bf,
        supplementary_p: bool_bf,
        compact_codes_p: bool_bf,
        unified_p: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let code_linear_p: u8 = unsafe { ::std::mem::transmute(code_linear_p) };
            code_linear_p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let iso_chars_96: u8 = unsafe { ::std::mem::transmute(iso_chars_96) };
            iso_chars_96 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ascii_compatible_p: u8 = unsafe { ::std::mem::transmute(ascii_compatible_p) };
            ascii_compatible_p as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let supplementary_p: u8 = unsafe { ::std::mem::transmute(supplementary_p) };
            supplementary_p as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let compact_codes_p: u8 = unsafe { ::std::mem::transmute(compact_codes_p) };
            compact_codes_p as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let unified_p: u8 = unsafe { ::std::mem::transmute(unified_p) };
            unified_p as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}Vcharset_hash_table"]
    pub static mut Vcharset_hash_table: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}charset_table"]
    pub static mut charset_table: *mut charset;
}
extern "C" {
    #[link_name = "\u{1}charset_table_size"]
    pub static mut charset_table_size: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}Vcharset_ordered_list"]
    pub static mut Vcharset_ordered_list: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}Vcharset_non_preferred_head"]
    pub static mut Vcharset_non_preferred_head: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}charset_ordered_list_tick"]
    pub static mut charset_ordered_list_tick: EMACS_UINT;
}
extern "C" {
    #[link_name = "\u{1}Viso_2022_charset_list"]
    pub static mut Viso_2022_charset_list: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}Vemacs_mule_charset_list"]
    pub static mut Vemacs_mule_charset_list: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}emacs_mule_charset"]
    pub static mut emacs_mule_charset: [::libc::c_int; 256usize];
}
extern "C" {
    pub fn set_charset_attr(charset: *mut charset, idx: charset_attr_index::Type, val: Lisp_Object);
}
extern "C" {
    #[link_name = "\u{1}charset_work"]
    pub static mut charset_work: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}charset_map_loaded"]
    pub static mut charset_map_loaded: bool;
}
extern "C" {
    #[link_name = "\u{1}iso_charset_table"]
    pub static mut iso_charset_table: [[[::libc::c_int; 128usize]; 2usize]; 3usize];
}
extern "C" {
    #[link_name = "\u{1}charset_ascii"]
    pub static mut charset_ascii: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}charset_eight_bit"]
    pub static mut charset_eight_bit: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}charset_unicode"]
    pub static mut charset_unicode: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}charset_jisx0201_roman"]
    pub static mut charset_jisx0201_roman: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}charset_jisx0208_1978"]
    pub static mut charset_jisx0208_1978: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}charset_jisx0208"]
    pub static mut charset_jisx0208: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}charset_ksc5601"]
    pub static mut charset_ksc5601: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}charset_unibyte"]
    pub static mut charset_unibyte: ::libc::c_int;
}
extern "C" {
    pub fn char_charset(
        arg1: ::libc::c_int,
        arg2: Lisp_Object,
        arg3: *mut ::libc::c_uint,
    ) -> *mut charset;
}
extern "C" {
    pub fn charset_attributes(arg1: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn decode_char(arg1: *mut charset, arg2: ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    pub fn encode_char(arg1: *mut charset, arg2: ::libc::c_int) -> ::libc::c_uint;
}
extern "C" {
    pub fn string_xstring_p(arg1: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    pub fn map_charset_chars(
        arg1: ::std::option::Option<unsafe extern "C" fn(arg1: Lisp_Object, arg2: Lisp_Object)>,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: *mut charset,
        arg5: ::libc::c_uint,
        arg6: ::libc::c_uint,
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct parmcap {
    pub mincost: ::libc::c_int,
    pub maxcost: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_parmcap() {
    assert_eq!(
        ::std::mem::size_of::<parmcap>(),
        8usize,
        concat!("Size of: ", stringify!(parmcap))
    );
    assert_eq!(
        ::std::mem::align_of::<parmcap>(),
        4usize,
        concat!("Alignment of ", stringify!(parmcap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<parmcap>())).mincost as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(parmcap),
            "::",
            stringify!(mincost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<parmcap>())).maxcost as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(parmcap),
            "::",
            stringify!(maxcost)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cm {
    pub cm_curY: ::libc::c_int,
    pub cm_curX: ::libc::c_int,
    pub cm_up: *const ::libc::c_char,
    pub cm_down: *const ::libc::c_char,
    pub cm_left: *const ::libc::c_char,
    pub cm_right: *const ::libc::c_char,
    pub cm_home: *const ::libc::c_char,
    pub cm_cr: *const ::libc::c_char,
    pub cm_ll: *const ::libc::c_char,
    pub cm_tab: *const ::libc::c_char,
    pub cm_backtab: *const ::libc::c_char,
    pub cm_abs: *mut ::libc::c_char,
    pub cm_habs: *const ::libc::c_char,
    pub cm_vabs: *const ::libc::c_char,
    pub cm_multiup: *const ::libc::c_char,
    pub cm_multidown: *const ::libc::c_char,
    pub cm_multileft: *const ::libc::c_char,
    pub cm_multiright: *const ::libc::c_char,
    pub cm_cols: ::libc::c_int,
    pub cm_rows: ::libc::c_int,
    pub cm_tabwidth: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub cc_up: ::libc::c_int,
    pub cc_down: ::libc::c_int,
    pub cc_left: ::libc::c_int,
    pub cc_right: ::libc::c_int,
    pub cc_home: ::libc::c_int,
    pub cc_cr: ::libc::c_int,
    pub cc_ll: ::libc::c_int,
    pub cc_tab: ::libc::c_int,
    pub cc_backtab: ::libc::c_int,
    pub cc_abs: ::libc::c_int,
    pub cc_habs: ::libc::c_int,
    pub cc_vabs: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_cm() {
    assert_eq!(
        ::std::mem::size_of::<cm>(),
        200usize,
        concat!("Size of: ", stringify!(cm))
    );
    assert_eq!(
        ::std::mem::align_of::<cm>(),
        8usize,
        concat!("Alignment of ", stringify!(cm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_curY as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_curY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_curX as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_curX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_up as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cm), "::", stringify!(cm_up))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_down as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_down)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_left as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_right as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_home as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_home)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_cr as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(cm), "::", stringify!(cm_cr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_ll as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(cm), "::", stringify!(cm_ll))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_tab as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_tab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_backtab as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_backtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_abs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_abs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_habs as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_habs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_vabs as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_vabs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_multiup as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_multiup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_multidown as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_multidown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_multileft as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_multileft)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_multiright as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_multiright)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_cols as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_rows as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cm_tabwidth as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cm_tabwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cc_up as *const _ as usize },
        152usize,
        concat!("Offset of field: ", stringify!(cm), "::", stringify!(cc_up))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cc_down as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cc_down)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cc_left as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cc_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cc_right as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cc_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cc_home as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cc_home)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cc_cr as *const _ as usize },
        172usize,
        concat!("Offset of field: ", stringify!(cm), "::", stringify!(cc_cr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cc_ll as *const _ as usize },
        176usize,
        concat!("Offset of field: ", stringify!(cm), "::", stringify!(cc_ll))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cc_tab as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cc_tab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cc_backtab as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cc_backtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cc_abs as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cc_abs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cc_habs as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cc_habs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cm>())).cc_vabs as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(cm),
            "::",
            stringify!(cc_vabs)
        )
    );
}
impl Default for cm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl cm {
    #[inline]
    pub fn cm_autowrap(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cm_autowrap(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cm_magicwrap(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cm_magicwrap(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cm_usetabs(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cm_usetabs(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cm_losewrap(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cm_losewrap(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cm_autolf(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cm_autolf(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cm_autowrap: bool_bf,
        cm_magicwrap: bool_bf,
        cm_usetabs: bool_bf,
        cm_losewrap: bool_bf,
        cm_autolf: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cm_autowrap: u8 = unsafe { ::std::mem::transmute(cm_autowrap) };
            cm_autowrap as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cm_magicwrap: u8 = unsafe { ::std::mem::transmute(cm_magicwrap) };
            cm_magicwrap as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cm_usetabs: u8 = unsafe { ::std::mem::transmute(cm_usetabs) };
            cm_usetabs as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cm_losewrap: u8 = unsafe { ::std::mem::transmute(cm_losewrap) };
            cm_losewrap as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cm_autolf: u8 = unsafe { ::std::mem::transmute(cm_autolf) };
            cm_autolf as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}cost"]
    pub static mut cost: ::libc::c_int;
}
extern "C" {
    pub fn evalcost(c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}current_tty"]
    pub static mut current_tty: *mut tty_display_info;
}
extern "C" {
    pub fn cmcheckmagic(arg1: *mut tty_display_info);
}
extern "C" {
    pub fn cmputc(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn cmcostinit(arg1: *mut tty_display_info);
}
extern "C" {
    pub fn cmgoto(arg1: *mut tty_display_info, arg2: ::libc::c_int, arg3: ::libc::c_int);
}
extern "C" {
    pub fn Wcm_clear(arg1: *mut tty_display_info);
}
extern "C" {
    pub fn Wcm_init(arg1: *mut tty_display_info) -> ::libc::c_int;
}
pub mod define_coding_system_arg_index {
    pub type Type = u32;
    pub const coding_arg_name: Type = 0;
    pub const coding_arg_mnemonic: Type = 1;
    pub const coding_arg_coding_type: Type = 2;
    pub const coding_arg_charset_list: Type = 3;
    pub const coding_arg_ascii_compatible_p: Type = 4;
    pub const coding_arg_decode_translation_table: Type = 5;
    pub const coding_arg_encode_translation_table: Type = 6;
    pub const coding_arg_post_read_conversion: Type = 7;
    pub const coding_arg_pre_write_conversion: Type = 8;
    pub const coding_arg_default_char: Type = 9;
    pub const coding_arg_for_unibyte: Type = 10;
    pub const coding_arg_plist: Type = 11;
    pub const coding_arg_eol_type: Type = 12;
    pub const coding_arg_max: Type = 13;
}
pub mod define_coding_iso2022_arg_index {
    pub type Type = u32;
    pub const coding_arg_iso2022_initial: Type = 13;
    pub const coding_arg_iso2022_reg_usage: Type = 14;
    pub const coding_arg_iso2022_request: Type = 15;
    pub const coding_arg_iso2022_flags: Type = 16;
    pub const coding_arg_iso2022_max: Type = 17;
}
pub mod define_coding_utf8_arg_index {
    pub type Type = u32;
    pub const coding_arg_utf8_bom: Type = 13;
    pub const coding_arg_utf8_max: Type = 14;
}
pub mod define_coding_utf16_arg_index {
    pub type Type = u32;
    pub const coding_arg_utf16_bom: Type = 13;
    pub const coding_arg_utf16_endian: Type = 14;
    pub const coding_arg_utf16_max: Type = 15;
}
pub mod define_coding_ccl_arg_index {
    pub type Type = u32;
    pub const coding_arg_ccl_decoder: Type = 13;
    pub const coding_arg_ccl_encoder: Type = 14;
    pub const coding_arg_ccl_valids: Type = 15;
    pub const coding_arg_ccl_max: Type = 16;
}
pub mod define_coding_undecided_arg_index {
    pub type Type = u32;
    pub const coding_arg_undecided_inhibit_null_byte_detection: Type = 13;
    pub const coding_arg_undecided_inhibit_iso_escape_detection: Type = 14;
    pub const coding_arg_undecided_prefer_utf_8: Type = 15;
    pub const coding_arg_undecided_max: Type = 16;
}
extern "C" {
    #[link_name = "\u{1}Vcoding_system_hash_table"]
    pub static mut Vcoding_system_hash_table: Lisp_Object;
}
pub mod coding_attr_index {
    pub type Type = u32;
    pub const coding_attr_base_name: Type = 0;
    pub const coding_attr_docstring: Type = 1;
    pub const coding_attr_mnemonic: Type = 2;
    pub const coding_attr_type: Type = 3;
    pub const coding_attr_charset_list: Type = 4;
    pub const coding_attr_ascii_compat: Type = 5;
    pub const coding_attr_decode_tbl: Type = 6;
    pub const coding_attr_encode_tbl: Type = 7;
    pub const coding_attr_trans_tbl: Type = 8;
    pub const coding_attr_post_read: Type = 9;
    pub const coding_attr_pre_write: Type = 10;
    pub const coding_attr_default_char: Type = 11;
    pub const coding_attr_for_unibyte: Type = 12;
    pub const coding_attr_plist: Type = 13;
    pub const coding_attr_category: Type = 14;
    pub const coding_attr_safe_charsets: Type = 15;
    pub const coding_attr_charset_valids: Type = 16;
    pub const coding_attr_ccl_decoder: Type = 17;
    pub const coding_attr_ccl_encoder: Type = 18;
    pub const coding_attr_ccl_valids: Type = 19;
    pub const coding_attr_iso_initial: Type = 20;
    pub const coding_attr_iso_usage: Type = 21;
    pub const coding_attr_iso_request: Type = 22;
    pub const coding_attr_iso_flags: Type = 23;
    pub const coding_attr_utf_bom: Type = 24;
    pub const coding_attr_utf_16_endian: Type = 25;
    pub const coding_attr_emacs_mule_full: Type = 26;
    pub const coding_attr_undecided_inhibit_null_byte_detection: Type = 27;
    pub const coding_attr_undecided_inhibit_iso_escape_detection: Type = 28;
    pub const coding_attr_undecided_prefer_utf_8: Type = 29;
    pub const coding_attr_last_index: Type = 30;
}
pub mod coding_result_code {
    #[doc = " GENERAL section"]
    pub type Type = u32;
    pub const CODING_RESULT_SUCCESS: Type = 0;
    pub const CODING_RESULT_INSUFFICIENT_SRC: Type = 1;
    pub const CODING_RESULT_INSUFFICIENT_DST: Type = 2;
    pub const CODING_RESULT_INVALID_SRC: Type = 3;
    pub const CODING_RESULT_INTERRUPT: Type = 4;
}
pub mod font_property_index {
    pub type Type = u32;
    pub const FONT_TYPE_INDEX: Type = 0;
    pub const FONT_FOUNDRY_INDEX: Type = 1;
    pub const FONT_FAMILY_INDEX: Type = 2;
    pub const FONT_ADSTYLE_INDEX: Type = 3;
    pub const FONT_REGISTRY_INDEX: Type = 4;
    pub const FONT_WEIGHT_INDEX: Type = 5;
    pub const FONT_SLANT_INDEX: Type = 6;
    pub const FONT_WIDTH_INDEX: Type = 7;
    pub const FONT_SIZE_INDEX: Type = 8;
    pub const FONT_DPI_INDEX: Type = 9;
    pub const FONT_SPACING_INDEX: Type = 10;
    pub const FONT_AVGWIDTH_INDEX: Type = 11;
    pub const FONT_EXTRA_INDEX: Type = 12;
    pub const FONT_SPEC_MAX: Type = 13;
    pub const FONT_OBJLIST_INDEX: Type = 13;
    pub const FONT_ENTITY_MAX: Type = 14;
    pub const FONT_NAME_INDEX: Type = 14;
    pub const FONT_FULLNAME_INDEX: Type = 15;
    pub const FONT_FILE_INDEX: Type = 16;
    pub const FONT_OBJECT_MAX: Type = 17;
}
#[repr(C)]
pub struct font_spec {
    pub header: vectorlike_header,
    pub props: [Lisp_Object; 13usize],
}
#[test]
fn bindgen_test_layout_font_spec() {
    assert_eq!(
        ::std::mem::size_of::<font_spec>(),
        112usize,
        concat!("Size of: ", stringify!(font_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<font_spec>(),
        8usize,
        concat!("Alignment of ", stringify!(font_spec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_spec>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(font_spec),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_spec>())).props as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(font_spec),
            "::",
            stringify!(props)
        )
    );
}
impl Default for font_spec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct font_entity {
    pub header: vectorlike_header,
    pub props: [Lisp_Object; 14usize],
}
#[test]
fn bindgen_test_layout_font_entity() {
    assert_eq!(
        ::std::mem::size_of::<font_entity>(),
        120usize,
        concat!("Size of: ", stringify!(font_entity))
    );
    assert_eq!(
        ::std::mem::align_of::<font_entity>(),
        8usize,
        concat!("Alignment of ", stringify!(font_entity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_entity>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(font_entity),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_entity>())).props as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(font_entity),
            "::",
            stringify!(props)
        )
    );
}
impl Default for font_entity {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct font {
    pub header: vectorlike_header,
    pub props: [Lisp_Object; 17usize],
    pub min_width: ::libc::c_int,
    pub max_width: ::libc::c_int,
    pub pixel_size: ::libc::c_int,
    pub height: ::libc::c_int,
    pub space_width: ::libc::c_int,
    pub average_width: ::libc::c_int,
    pub ascent: ::libc::c_int,
    pub descent: ::libc::c_int,
    pub underline_thickness: ::libc::c_int,
    pub underline_position: ::libc::c_int,
    pub vertical_centering: bool,
    pub baseline_offset: ::libc::c_int,
    pub relative_compose: ::libc::c_int,
    pub default_ascent: ::libc::c_int,
    pub encoding_charset: ::libc::c_int,
    pub repertory_charset: ::libc::c_int,
    pub driver: *const font_driver,
}
#[test]
fn bindgen_test_layout_font() {
    assert_eq!(
        ::std::mem::size_of::<font>(),
        216usize,
        concat!("Size of: ", stringify!(font))
    );
    assert_eq!(
        ::std::mem::align_of::<font>(),
        8usize,
        concat!("Alignment of ", stringify!(font))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).props as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).min_width as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).max_width as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).pixel_size as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(pixel_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).height as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).space_width as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(space_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).average_width as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(average_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).ascent as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).descent as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).underline_thickness as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(underline_thickness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).underline_position as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(underline_position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).vertical_centering as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(vertical_centering)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).baseline_offset as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(baseline_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).relative_compose as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(relative_compose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).default_ascent as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(default_ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).encoding_charset as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(encoding_charset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).repertory_charset as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(repertory_charset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font>())).driver as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(font),
            "::",
            stringify!(driver)
        )
    );
}
impl Default for font {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod font_spacing {
    pub type Type = u32;
    pub const FONT_SPACING_PROPORTIONAL: Type = 0;
    pub const FONT_SPACING_DUAL: Type = 90;
    pub const FONT_SPACING_MONO: Type = 100;
    pub const FONT_SPACING_CHARCELL: Type = 110;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct font_metrics {
    pub lbearing: ::libc::c_short,
    pub rbearing: ::libc::c_short,
    pub width: ::libc::c_short,
    pub ascent: ::libc::c_short,
    pub descent: ::libc::c_short,
}
#[test]
fn bindgen_test_layout_font_metrics() {
    assert_eq!(
        ::std::mem::size_of::<font_metrics>(),
        10usize,
        concat!("Size of: ", stringify!(font_metrics))
    );
    assert_eq!(
        ::std::mem::align_of::<font_metrics>(),
        2usize,
        concat!("Alignment of ", stringify!(font_metrics))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_metrics>())).lbearing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(font_metrics),
            "::",
            stringify!(lbearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_metrics>())).rbearing as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(font_metrics),
            "::",
            stringify!(rbearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_metrics>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(font_metrics),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_metrics>())).ascent as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(font_metrics),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_metrics>())).descent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(font_metrics),
            "::",
            stringify!(descent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct font_bitmap {
    pub bits_per_pixel: ::libc::c_int,
    pub rows: ::libc::c_int,
    pub width: ::libc::c_int,
    pub pitch: ::libc::c_int,
    pub buffer: *mut ::libc::c_uchar,
    pub left: ::libc::c_int,
    pub top: ::libc::c_int,
    pub advance: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_font_bitmap() {
    assert_eq!(
        ::std::mem::size_of::<font_bitmap>(),
        40usize,
        concat!("Size of: ", stringify!(font_bitmap))
    );
    assert_eq!(
        ::std::mem::align_of::<font_bitmap>(),
        8usize,
        concat!("Alignment of ", stringify!(font_bitmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_bitmap>())).bits_per_pixel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(font_bitmap),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_bitmap>())).rows as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(font_bitmap),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_bitmap>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(font_bitmap),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_bitmap>())).pitch as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(font_bitmap),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_bitmap>())).buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(font_bitmap),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_bitmap>())).left as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(font_bitmap),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_bitmap>())).top as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(font_bitmap),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_bitmap>())).advance as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(font_bitmap),
            "::",
            stringify!(advance)
        )
    );
}
impl Default for font_bitmap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn FONTP(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn FONT_SPEC_P(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn GC_FONT_SPEC_P(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn FONT_ENTITY_P(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn GC_FONT_ENTITY_P(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn FONT_OBJECT_P(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn GC_FONT_OBJECT_P(x: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_FONT(x: Lisp_Object);
}
extern "C" {
    pub fn CHECK_FONT_SPEC(x: Lisp_Object);
}
extern "C" {
    pub fn CHECK_FONT_ENTITY(x: Lisp_Object);
}
extern "C" {
    pub fn CHECK_FONT_OBJECT(x: Lisp_Object);
}
extern "C" {
    pub fn XFONT_SPEC(p: Lisp_Object) -> *mut font_spec;
}
extern "C" {
    pub fn GC_XFONT_SPEC(p: Lisp_Object) -> *mut font_spec;
}
extern "C" {
    pub fn XFONT_ENTITY(p: Lisp_Object) -> *mut font_entity;
}
extern "C" {
    pub fn GC_XFONT_ENTITY(p: Lisp_Object) -> *mut font_entity;
}
extern "C" {
    pub fn XFONT_OBJECT(p: Lisp_Object) -> *mut font;
}
extern "C" {
    pub fn GC_XFONT_OBJECT(p: Lisp_Object) -> *mut font;
}
extern "C" {
    pub fn CHECK_FONT_GET_OBJECT(x: Lisp_Object) -> *mut font;
}
#[repr(C)]
pub struct font_driver {
    pub type_: Lisp_Object,
    pub case_sensitive: bool,
    pub get_cache: ::std::option::Option<unsafe extern "C" fn(f: *mut frame) -> Lisp_Object>,
    pub list: ::std::option::Option<
        unsafe extern "C" fn(frame: *mut frame, font_spec: Lisp_Object) -> Lisp_Object,
    >,
    pub match_: ::std::option::Option<
        unsafe extern "C" fn(f: *mut frame, font_spec: Lisp_Object) -> Lisp_Object,
    >,
    pub list_family: ::std::option::Option<unsafe extern "C" fn(f: *mut frame) -> Lisp_Object>,
    pub free_entity: ::std::option::Option<unsafe extern "C" fn(font_entity: Lisp_Object)>,
    pub open_font: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut frame,
            font_entity: Lisp_Object,
            pixel_size: ::libc::c_int,
        ) -> Lisp_Object,
    >,
    pub close_font: ::std::option::Option<unsafe extern "C" fn(font: *mut font)>,
    pub prepare_face: ::std::option::Option<unsafe extern "C" fn(f: *mut frame, face: *mut face)>,
    pub done_face: ::std::option::Option<unsafe extern "C" fn(f: *mut frame, face: *mut face)>,
    pub has_char: ::std::option::Option<
        unsafe extern "C" fn(font: Lisp_Object, c: ::libc::c_int) -> ::libc::c_int,
    >,
    pub encode_char: ::std::option::Option<
        unsafe extern "C" fn(font: *mut font, c: ::libc::c_int) -> ::libc::c_uint,
    >,
    pub text_extents: ::std::option::Option<
        unsafe extern "C" fn(
            font: *mut font,
            code: *const ::libc::c_uint,
            nglyphs: ::libc::c_int,
            metrics: *mut font_metrics,
        ),
    >,
    pub draw: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut glyph_string,
            from: ::libc::c_int,
            to: ::libc::c_int,
            x: ::libc::c_int,
            y: ::libc::c_int,
            with_background: bool,
        ) -> ::libc::c_int,
    >,
    pub get_bitmap: ::std::option::Option<
        unsafe extern "C" fn(
            font: *mut font,
            code: ::libc::c_uint,
            bitmap: *mut font_bitmap,
            bits_per_pixel: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub free_bitmap:
        ::std::option::Option<unsafe extern "C" fn(font: *mut font, bitmap: *mut font_bitmap)>,
    pub anchor_point: ::std::option::Option<
        unsafe extern "C" fn(
            font: *mut font,
            code: ::libc::c_uint,
            index: ::libc::c_int,
            x: *mut ::libc::c_int,
            y: *mut ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub otf_capability: ::std::option::Option<unsafe extern "C" fn(font: *mut font) -> Lisp_Object>,
    pub otf_drive: ::std::option::Option<
        unsafe extern "C" fn(
            font: *mut font,
            features: Lisp_Object,
            gstring_in: Lisp_Object,
            from: ::libc::c_int,
            to: ::libc::c_int,
            gstring_out: Lisp_Object,
            idx: ::libc::c_int,
            alternate_subst: bool,
        ) -> ::libc::c_int,
    >,
    pub start_for_frame:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame) -> ::libc::c_int>,
    pub end_for_frame: ::std::option::Option<unsafe extern "C" fn(f: *mut frame) -> ::libc::c_int>,
    pub shape: ::std::option::Option<
        unsafe extern "C" fn(lgstring: Lisp_Object, direction: Lisp_Object) -> Lisp_Object,
    >,
    pub check: ::std::option::Option<
        unsafe extern "C" fn(f: *mut frame, font: *mut font) -> ::libc::c_int,
    >,
    pub get_variation_glyphs: ::std::option::Option<
        unsafe extern "C" fn(
            font: *mut font,
            c: ::libc::c_int,
            variations: *mut ::libc::c_uint,
        ) -> ::libc::c_int,
    >,
    pub filter_properties:
        ::std::option::Option<unsafe extern "C" fn(font: Lisp_Object, properties: Lisp_Object)>,
    pub cached_font_ok: ::std::option::Option<
        unsafe extern "C" fn(f: *mut frame, font_object: Lisp_Object, entity: Lisp_Object) -> bool,
    >,
    pub combining_capability:
        ::std::option::Option<unsafe extern "C" fn(font: *mut font) -> Lisp_Object>,
    pub drop_xrender_surfaces: ::std::option::Option<unsafe extern "C" fn(f: *mut frame)>,
}
#[test]
fn bindgen_test_layout_font_driver() {
    assert_eq!(
        ::std::mem::size_of::<font_driver>(),
        232usize,
        concat!("Size of: ", stringify!(font_driver))
    );
    assert_eq!(
        ::std::mem::align_of::<font_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(font_driver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).case_sensitive as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(case_sensitive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).get_cache as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(get_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).match_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).list_family as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(list_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).free_entity as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(free_entity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).open_font as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(open_font)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).close_font as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(close_font)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).prepare_face as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(prepare_face)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).done_face as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(done_face)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).has_char as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(has_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).encode_char as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(encode_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).text_extents as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(text_extents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).draw as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(draw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).get_bitmap as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(get_bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).free_bitmap as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(free_bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).anchor_point as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(anchor_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).otf_capability as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(otf_capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).otf_drive as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(otf_drive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).start_for_frame as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(start_for_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).end_for_frame as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(end_for_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).shape as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).check as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<font_driver>())).get_variation_glyphs as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(get_variation_glyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).filter_properties as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(filter_properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver>())).cached_font_ok as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(cached_font_ok)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<font_driver>())).combining_capability as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(combining_capability)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<font_driver>())).drop_xrender_surfaces as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver),
            "::",
            stringify!(drop_xrender_surfaces)
        )
    );
}
impl Default for font_driver {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct font_driver_list {
    pub on: bool,
    pub driver: *const font_driver,
    pub next: *mut font_driver_list,
}
#[test]
fn bindgen_test_layout_font_driver_list() {
    assert_eq!(
        ::std::mem::size_of::<font_driver_list>(),
        24usize,
        concat!("Size of: ", stringify!(font_driver_list))
    );
    assert_eq!(
        ::std::mem::align_of::<font_driver_list>(),
        8usize,
        concat!("Alignment of ", stringify!(font_driver_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver_list>())).on as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver_list),
            "::",
            stringify!(on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver_list>())).driver as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver_list),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<font_driver_list>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(font_driver_list),
            "::",
            stringify!(next)
        )
    );
}
impl Default for font_driver_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn copy_font_spec(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn merge_font_spec(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn font_make_entity() -> Lisp_Object;
}
extern "C" {
    pub fn font_make_object(
        arg1: ::libc::c_int,
        arg2: Lisp_Object,
        arg3: ::libc::c_int,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn find_font_encoding(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn font_registry_charsets(
        arg1: Lisp_Object,
        arg2: *mut *mut charset,
        arg3: *mut *mut charset,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn font_style_to_value(
        prop: font_property_index::Type,
        name: Lisp_Object,
        noerror: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn font_style_symbolic(
        font: Lisp_Object,
        prop: font_property_index::Type,
        for_face: bool,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn font_match_p(spec: Lisp_Object, font: Lisp_Object) -> bool;
}
extern "C" {
    pub fn font_is_ignored(name: *const ::libc::c_char, namelen: isize) -> bool;
}
extern "C" {
    pub fn font_list_entities(arg1: *mut frame, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn font_get_name(font_object: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn font_spec_from_name(font_name: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn font_get_frame(font_object: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn font_has_char(arg1: *mut frame, arg2: Lisp_Object, arg3: ::libc::c_int)
        -> ::libc::c_int;
}
extern "C" {
    pub fn font_clear_prop(attrs: *mut Lisp_Object, prop: font_property_index::Type);
}
extern "C" {
    pub fn font_find_for_lface(
        f: *mut frame,
        lface: *mut Lisp_Object,
        spec: Lisp_Object,
        c: ::libc::c_int,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn font_open_for_lface(
        f: *mut frame,
        entity: Lisp_Object,
        lface: *mut Lisp_Object,
        spec: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn font_load_for_lface(
        f: *mut frame,
        lface: *mut Lisp_Object,
        spec: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn font_prepare_for_face(f: *mut frame, face: *mut face);
}
extern "C" {
    pub fn font_done_for_face(f: *mut frame, face: *mut face);
}
extern "C" {
    pub fn clear_font_cache(arg1: *mut frame);
}
extern "C" {
    pub fn font_open_by_spec(f: *mut frame, spec: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn font_open_by_name(f: *mut frame, name: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn font_intern_prop(
        str: *const ::libc::c_char,
        len: isize,
        force_symbol: bool,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn font_update_sort_order(order: *mut ::libc::c_int);
}
extern "C" {
    pub fn font_parse_family_registry(
        family: Lisp_Object,
        registry: Lisp_Object,
        spec: Lisp_Object,
    );
}
extern "C" {
    pub fn font_parse_xlfd(
        name: *mut ::libc::c_char,
        len: isize,
        font: Lisp_Object,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn font_unparse_xlfd(
        font: Lisp_Object,
        pixel_size: ::libc::c_int,
        name: *mut ::libc::c_char,
        bytes: ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn register_font_driver(arg1: *const font_driver, arg2: *mut frame);
}
extern "C" {
    pub fn free_font_driver_list(f: *mut frame);
}
extern "C" {
    pub fn valid_font_driver(d: *const font_driver) -> bool;
}
extern "C" {
    pub fn font_update_drivers(f: *mut frame, list: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn font_range(
        arg1: isize,
        arg2: isize,
        arg3: *mut isize,
        arg4: *mut window,
        arg5: *mut face,
        arg6: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn font_fill_lglyph_metrics(arg1: Lisp_Object, arg2: *mut font, arg3: ::libc::c_uint);
}
extern "C" {
    pub fn font_put_extra(font: Lisp_Object, prop: Lisp_Object, val: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn font_filter_properties(
        font: Lisp_Object,
        alist: Lisp_Object,
        boolean_properties: *const *const ::libc::c_char,
        non_boolean_properties: *const *const ::libc::c_char,
    );
}
extern "C" {
    pub fn font_drop_xrender_surfaces(f: *mut frame);
}
extern "C" {
    pub fn font_add_log(arg1: *const ::libc::c_char, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn font_deferred_log(arg1: *const ::libc::c_char, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn font_data_structures_may_be_ill_formed() -> bool;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Emacs_Color {
    pub pixel: ::libc::c_ulong,
    pub red: ::libc::c_ushort,
    pub green: ::libc::c_ushort,
    pub blue: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_Emacs_Color() {
    assert_eq!(
        ::std::mem::size_of::<Emacs_Color>(),
        16usize,
        concat!("Size of: ", stringify!(Emacs_Color))
    );
    assert_eq!(
        ::std::mem::align_of::<Emacs_Color>(),
        8usize,
        concat!("Alignment of ", stringify!(Emacs_Color))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Emacs_Color>())).pixel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Emacs_Color),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Emacs_Color>())).red as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Emacs_Color),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Emacs_Color>())).green as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Emacs_Color),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Emacs_Color>())).blue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Emacs_Color),
            "::",
            stringify!(blue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Emacs_Rectangle {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub width: ::libc::c_uint,
    pub height: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_Emacs_Rectangle() {
    assert_eq!(
        ::std::mem::size_of::<Emacs_Rectangle>(),
        16usize,
        concat!("Size of: ", stringify!(Emacs_Rectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<Emacs_Rectangle>(),
        4usize,
        concat!("Alignment of ", stringify!(Emacs_Rectangle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Emacs_Rectangle>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Emacs_Rectangle),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Emacs_Rectangle>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Emacs_Rectangle),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Emacs_Rectangle>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Emacs_Rectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Emacs_Rectangle>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Emacs_Rectangle),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Emacs_GC {
    pub foreground: ::libc::c_ulong,
    pub background: ::libc::c_ulong,
}
#[test]
fn bindgen_test_layout_Emacs_GC() {
    assert_eq!(
        ::std::mem::size_of::<Emacs_GC>(),
        16usize,
        concat!("Size of: ", stringify!(Emacs_GC))
    );
    assert_eq!(
        ::std::mem::align_of::<Emacs_GC>(),
        8usize,
        concat!("Alignment of ", stringify!(Emacs_GC))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Emacs_GC>())).foreground as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Emacs_GC),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Emacs_GC>())).background as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Emacs_GC),
            "::",
            stringify!(background)
        )
    );
}
extern "C" {
    pub fn c_strcasecmp(s1: *const ::libc::c_char, s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn c_strncasecmp(
        s1: *const ::libc::c_char,
        s2: *const ::libc::c_char,
        n: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn xstrcasecmp(a: *const ::libc::c_char, b: *const ::libc::c_char) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XGCValues {
    pub foreground: ::libc::c_ulong,
    pub background: ::libc::c_ulong,
    pub font: *mut font,
}
#[test]
fn bindgen_test_layout__XGCValues() {
    assert_eq!(
        ::std::mem::size_of::<_XGCValues>(),
        24usize,
        concat!("Size of: ", stringify!(_XGCValues))
    );
    assert_eq!(
        ::std::mem::align_of::<_XGCValues>(),
        8usize,
        concat!("Alignment of ", stringify!(_XGCValues))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XGCValues>())).foreground as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XGCValues),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XGCValues>())).background as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XGCValues),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XGCValues>())).font as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XGCValues),
            "::",
            stringify!(font)
        )
    );
}
impl Default for _XGCValues {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type XGCValues = _XGCValues;
pub type Pixmap = *mut ::libc::c_void;
pub type XrmDatabase = *mut ::libc::c_char;
pub type GC = *mut Emacs_GC;
pub type Color = ::libc::c_int;
pub type Window = ::libc::c_int;
pub type Display = ::libc::c_int;
pub type Emacs_Cursor = *mut ::libc::c_void;
pub type RGB_PIXEL_COLOR = ::libc::c_int;
pub type Emacs_Pixmap = *mut ::libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WRImage {
    pub data: *mut ::libc::c_uchar,
    pub info: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__WRImage() {
    assert_eq!(
        ::std::mem::size_of::<_WRImage>(),
        16usize,
        concat!("Size of: ", stringify!(_WRImage))
    );
    assert_eq!(
        ::std::mem::align_of::<_WRImage>(),
        8usize,
        concat!("Alignment of ", stringify!(_WRImage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WRImage>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WRImage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WRImage>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_WRImage),
            "::",
            stringify!(info)
        )
    );
}
impl Default for _WRImage {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type WRImage = _WRImage;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XRectangle {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub width: ::libc::c_uint,
    pub height: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_XRectangle() {
    assert_eq!(
        ::std::mem::size_of::<XRectangle>(),
        16usize,
        concat!("Size of: ", stringify!(XRectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<XRectangle>(),
        4usize,
        concat!("Alignment of ", stringify!(XRectangle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XRectangle>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XRectangle>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XRectangle>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XRectangle>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(height)
        )
    );
}
pub type Display_Info = wr_display_info;
pub type XImagePtr = *mut WRImage;
pub type XImagePtr_or_DC = XImagePtr;
pub type Emacs_Pix_Container = Emacs_Pixmap;
pub type Emacs_Pix_Context = Emacs_Pixmap;
extern "C" {
    pub fn free_face_fontset(arg1: *mut frame, arg2: *mut face);
}
extern "C" {
    pub fn face_for_char(
        arg1: *mut frame,
        arg2: *mut face,
        arg3: ::libc::c_int,
        arg4: isize,
        arg5: Lisp_Object,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn font_for_char(
        arg1: *mut face,
        arg2: ::libc::c_int,
        arg3: isize,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn make_fontset_for_ascii_face(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: *mut face,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fontset_from_font(arg1: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    pub fn fs_query_fontset(arg1: Lisp_Object, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn list_fontsets(arg1: *mut frame, arg2: Lisp_Object, arg3: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn fontset_name(arg1: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn fontset_ascii(arg1: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn face_for_font(arg1: *mut frame, arg2: Lisp_Object, arg3: *mut face) -> ::libc::c_int;
}
pub mod text_cursor_kinds {
    pub type Type = i32;
    pub const DEFAULT_CURSOR: Type = -2;
    pub const NO_CURSOR: Type = -1;
    pub const FILLED_BOX_CURSOR: Type = 0;
    pub const HOLLOW_BOX_CURSOR: Type = 1;
    pub const BAR_CURSOR: Type = 2;
    pub const HBAR_CURSOR: Type = 3;
}
pub mod window_part {
    pub type Type = u32;
    pub const ON_NOTHING: Type = 0;
    pub const ON_TEXT: Type = 1;
    pub const ON_MODE_LINE: Type = 2;
    pub const ON_VERTICAL_BORDER: Type = 3;
    pub const ON_HEADER_LINE: Type = 4;
    pub const ON_TAB_LINE: Type = 5;
    pub const ON_LEFT_FRINGE: Type = 6;
    pub const ON_RIGHT_FRINGE: Type = 7;
    pub const ON_LEFT_MARGIN: Type = 8;
    pub const ON_RIGHT_MARGIN: Type = 9;
    pub const ON_VERTICAL_SCROLL_BAR: Type = 10;
    pub const ON_HORIZONTAL_SCROLL_BAR: Type = 11;
    pub const ON_RIGHT_DIVIDER: Type = 12;
    pub const ON_BOTTOM_DIVIDER: Type = 13;
}
#[doc = "Text positions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct text_pos {
    pub charpos: isize,
    pub bytepos: isize,
}
#[test]
fn bindgen_test_layout_text_pos() {
    assert_eq!(
        ::std::mem::size_of::<text_pos>(),
        16usize,
        concat!("Size of: ", stringify!(text_pos))
    );
    assert_eq!(
        ::std::mem::align_of::<text_pos>(),
        8usize,
        concat!("Alignment of ", stringify!(text_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<text_pos>())).charpos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(text_pos),
            "::",
            stringify!(charpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<text_pos>())).bytepos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(text_pos),
            "::",
            stringify!(bytepos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct display_pos {
    pub pos: text_pos,
    pub overlay_string_index: isize,
    pub string_pos: text_pos,
    pub dpvec_index: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_display_pos() {
    assert_eq!(
        ::std::mem::size_of::<display_pos>(),
        48usize,
        concat!("Size of: ", stringify!(display_pos))
    );
    assert_eq!(
        ::std::mem::align_of::<display_pos>(),
        8usize,
        concat!("Alignment of ", stringify!(display_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<display_pos>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(display_pos),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<display_pos>())).overlay_string_index as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(display_pos),
            "::",
            stringify!(overlay_string_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<display_pos>())).string_pos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(display_pos),
            "::",
            stringify!(string_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<display_pos>())).dpvec_index as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(display_pos),
            "::",
            stringify!(dpvec_index)
        )
    );
}
#[doc = "Glyphs"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GLYPH {
    pub ch: ::libc::c_int,
    pub face_id: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_GLYPH() {
    assert_eq!(
        ::std::mem::size_of::<GLYPH>(),
        8usize,
        concat!("Size of: ", stringify!(GLYPH))
    );
    assert_eq!(
        ::std::mem::align_of::<GLYPH>(),
        4usize,
        concat!("Alignment of ", stringify!(GLYPH))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLYPH>())).ch as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(GLYPH), "::", stringify!(ch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLYPH>())).face_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GLYPH),
            "::",
            stringify!(face_id)
        )
    );
}
extern "C" {
    pub fn GLYPH_CHAR(glyph: GLYPH) -> ::libc::c_int;
}
extern "C" {
    pub fn GLYPH_FACE(glyph: GLYPH) -> ::libc::c_int;
}
extern "C" {
    pub fn GLYPH_CODE_CHAR(gc: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    pub fn GLYPH_CODE_FACE(gc: Lisp_Object) -> ::libc::c_int;
}
pub mod _bindgen_ty_43 {
    pub type Type = u32;
    pub const GLYPH_MODE_LINE_FACE: Type = 1;
}
pub mod glyph_type {
    pub type Type = u32;
    pub const CHAR_GLYPH: Type = 0;
    pub const COMPOSITE_GLYPH: Type = 1;
    pub const GLYPHLESS_GLYPH: Type = 2;
    pub const IMAGE_GLYPH: Type = 3;
    pub const STRETCH_GLYPH: Type = 4;
    pub const XWIDGET_GLYPH: Type = 5;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct glyph_slice {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u16>,
}
#[test]
fn bindgen_test_layout_glyph_slice() {
    assert_eq!(
        ::std::mem::size_of::<glyph_slice>(),
        8usize,
        concat!("Size of: ", stringify!(glyph_slice))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph_slice>(),
        4usize,
        concat!("Alignment of ", stringify!(glyph_slice))
    );
}
impl glyph_slice {
    #[inline]
    pub fn x(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_x(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn y(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_y(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn width(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_width(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn height(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_height(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        x: ::libc::c_uint,
        y: ::libc::c_uint,
        width: ::libc::c_uint,
        height: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let x: u32 = unsafe { ::std::mem::transmute(x) };
            x as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let y: u32 = unsafe { ::std::mem::transmute(y) };
            y as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let width: u32 = unsafe { ::std::mem::transmute(width) };
            width as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let height: u32 = unsafe { ::std::mem::transmute(height) };
            height as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct glyph {
    pub charpos: isize,
    pub object: Lisp_Object,
    pub pixel_width: ::libc::c_short,
    pub ascent: ::libc::c_short,
    pub descent: ::libc::c_short,
    pub voffset: ::libc::c_short,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
    pub slice: glyph__bindgen_ty_1,
    pub u: glyph__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union glyph__bindgen_ty_1 {
    pub img: glyph_slice,
    pub cmp: glyph__bindgen_ty_1__bindgen_ty_1,
    pub glyphless: glyph__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct glyph__bindgen_ty_1__bindgen_ty_1 {
    pub from: ::libc::c_int,
    pub to: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_glyph__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<glyph__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(glyph__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(glyph__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<glyph__bindgen_ty_1__bindgen_ty_1>())).from as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<glyph__bindgen_ty_1__bindgen_ty_1>())).to as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(to)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct glyph__bindgen_ty_1__bindgen_ty_2 {
    pub upper_xoff: ::libc::c_short,
    pub upper_yoff: ::libc::c_short,
    pub lower_xoff: ::libc::c_short,
    pub lower_yoff: ::libc::c_short,
}
#[test]
fn bindgen_test_layout_glyph__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<glyph__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(glyph__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(glyph__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<glyph__bindgen_ty_1__bindgen_ty_2>())).upper_xoff as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(upper_xoff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<glyph__bindgen_ty_1__bindgen_ty_2>())).upper_yoff as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(upper_yoff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<glyph__bindgen_ty_1__bindgen_ty_2>())).lower_xoff as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(lower_xoff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<glyph__bindgen_ty_1__bindgen_ty_2>())).lower_yoff as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(lower_yoff)
        )
    );
}
#[test]
fn bindgen_test_layout_glyph__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<glyph__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(glyph__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(glyph__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph__bindgen_ty_1>())).img as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_1),
            "::",
            stringify!(img)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph__bindgen_ty_1>())).cmp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_1),
            "::",
            stringify!(cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph__bindgen_ty_1>())).glyphless as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_1),
            "::",
            stringify!(glyphless)
        )
    );
}
impl Default for glyph__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union glyph__bindgen_ty_2 {
    pub ch: ::libc::c_uint,
    pub cmp: glyph__bindgen_ty_2__bindgen_ty_1,
    pub img_id: ::libc::c_int,
    pub stretch: glyph__bindgen_ty_2__bindgen_ty_2,
    pub glyphless: glyph__bindgen_ty_2__bindgen_ty_3,
    pub val: ::libc::c_uint,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct glyph__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_glyph__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<glyph__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(glyph__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(glyph__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl glyph__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn automatic(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_automatic(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn id(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_id(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        automatic: bool_bf,
        id: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let automatic: u8 = unsafe { ::std::mem::transmute(automatic) };
            automatic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let id: u32 = unsafe { ::std::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct glyph__bindgen_ty_2__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_glyph__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<glyph__bindgen_ty_2__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(glyph__bindgen_ty_2__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph__bindgen_ty_2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(glyph__bindgen_ty_2__bindgen_ty_2)
        )
    );
}
impl glyph__bindgen_ty_2__bindgen_ty_2 {
    #[inline]
    pub fn height(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_height(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn ascent(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ascent(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        height: ::libc::c_uint,
        ascent: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let height: u32 = unsafe { ::std::mem::transmute(height) };
            height as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let ascent: u32 = unsafe { ::std::mem::transmute(ascent) };
            ascent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct glyph__bindgen_ty_2__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_glyph__bindgen_ty_2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<glyph__bindgen_ty_2__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(glyph__bindgen_ty_2__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph__bindgen_ty_2__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(glyph__bindgen_ty_2__bindgen_ty_3)
        )
    );
}
impl glyph__bindgen_ty_2__bindgen_ty_3 {
    #[inline]
    pub fn method(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_method(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn for_no_font(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_for_no_font(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn len(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ch(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_ch(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        method: ::libc::c_uint,
        for_no_font: bool_bf,
        len: ::libc::c_uint,
        ch: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let method: u32 = unsafe { ::std::mem::transmute(method) };
            method as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let for_no_font: u8 = unsafe { ::std::mem::transmute(for_no_font) };
            for_no_font as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let len: u32 = unsafe { ::std::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let ch: u32 = unsafe { ::std::mem::transmute(ch) };
            ch as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_glyph__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<glyph__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(glyph__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(glyph__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph__bindgen_ty_2>())).ch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_2),
            "::",
            stringify!(ch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph__bindgen_ty_2>())).cmp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_2),
            "::",
            stringify!(cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph__bindgen_ty_2>())).img_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_2),
            "::",
            stringify!(img_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph__bindgen_ty_2>())).stretch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_2),
            "::",
            stringify!(stretch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph__bindgen_ty_2>())).glyphless as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_2),
            "::",
            stringify!(glyphless)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph__bindgen_ty_2>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph__bindgen_ty_2),
            "::",
            stringify!(val)
        )
    );
}
impl Default for glyph__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_glyph() {
    assert_eq!(
        ::std::mem::size_of::<glyph>(),
        48usize,
        concat!("Size of: ", stringify!(glyph))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph>(),
        8usize,
        concat!("Alignment of ", stringify!(glyph))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph>())).charpos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph),
            "::",
            stringify!(charpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph>())).object as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph>())).pixel_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph),
            "::",
            stringify!(pixel_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph>())).ascent as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph>())).descent as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph>())).voffset as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph),
            "::",
            stringify!(voffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph>())).slice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph),
            "::",
            stringify!(slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph>())).u as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(glyph), "::", stringify!(u))
    );
}
impl Default for glyph {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl glyph {
    #[inline]
    pub fn type_(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn multibyte_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_multibyte_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn left_box_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_left_box_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn right_box_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_right_box_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overlaps_vertically_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_overlaps_vertically_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn padding_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_padding_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glyph_not_available_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_glyph_not_available_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avoid_cursor_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_avoid_cursor_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resolved_level(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_resolved_level(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn bidi_type(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_bidi_type(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn face_id(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_face_id(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn font_type(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_font_type(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::libc::c_uint,
        multibyte_p: bool_bf,
        left_box_line_p: bool_bf,
        right_box_line_p: bool_bf,
        overlaps_vertically_p: bool_bf,
        padding_p: bool_bf,
        glyph_not_available_p: bool_bf,
        avoid_cursor_p: bool_bf,
        resolved_level: ::libc::c_uint,
        bidi_type: ::libc::c_uint,
        face_id: ::libc::c_uint,
        font_type: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let multibyte_p: u8 = unsafe { ::std::mem::transmute(multibyte_p) };
            multibyte_p as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let left_box_line_p: u8 = unsafe { ::std::mem::transmute(left_box_line_p) };
            left_box_line_p as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let right_box_line_p: u8 = unsafe { ::std::mem::transmute(right_box_line_p) };
            right_box_line_p as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let overlaps_vertically_p: u8 = unsafe { ::std::mem::transmute(overlaps_vertically_p) };
            overlaps_vertically_p as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let padding_p: u8 = unsafe { ::std::mem::transmute(padding_p) };
            padding_p as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let glyph_not_available_p: u8 = unsafe { ::std::mem::transmute(glyph_not_available_p) };
            glyph_not_available_p as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let avoid_cursor_p: u8 = unsafe { ::std::mem::transmute(avoid_cursor_p) };
            avoid_cursor_p as u64
        });
        __bindgen_bitfield_unit.set(10usize, 7u8, {
            let resolved_level: u32 = unsafe { ::std::mem::transmute(resolved_level) };
            resolved_level as u64
        });
        __bindgen_bitfield_unit.set(17usize, 3u8, {
            let bidi_type: u32 = unsafe { ::std::mem::transmute(bidi_type) };
            bidi_type as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let face_id: u32 = unsafe { ::std::mem::transmute(face_id) };
            face_id as u64
        });
        __bindgen_bitfield_unit.set(52usize, 3u8, {
            let font_type: u32 = unsafe { ::std::mem::transmute(font_type) };
            font_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct glyph_pool {
    pub glyphs: *mut glyph,
    pub nglyphs: isize,
    pub nrows: ::libc::c_int,
    pub ncolumns: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_glyph_pool() {
    assert_eq!(
        ::std::mem::size_of::<glyph_pool>(),
        24usize,
        concat!("Size of: ", stringify!(glyph_pool))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph_pool>(),
        8usize,
        concat!("Alignment of ", stringify!(glyph_pool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_pool>())).glyphs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_pool),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_pool>())).nglyphs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_pool),
            "::",
            stringify!(nglyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_pool>())).nrows as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_pool),
            "::",
            stringify!(nrows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_pool>())).ncolumns as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_pool),
            "::",
            stringify!(ncolumns)
        )
    );
}
impl Default for glyph_pool {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "Glyph Matrix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct glyph_matrix {
    pub pool: *mut glyph_pool,
    pub rows: *mut glyph_row,
    pub rows_allocated: isize,
    pub nrows: ::libc::c_int,
    pub matrix_x: ::libc::c_int,
    pub matrix_y: ::libc::c_int,
    pub matrix_w: ::libc::c_int,
    pub matrix_h: ::libc::c_int,
    pub window_pixel_left: ::libc::c_int,
    pub window_pixel_top: ::libc::c_int,
    pub window_height: ::libc::c_int,
    pub window_width: ::libc::c_int,
    pub window_vscroll: ::libc::c_int,
    pub left_margin_glyphs: ::libc::c_int,
    pub right_margin_glyphs: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub buffer: *mut buffer,
    pub begv: isize,
    pub zv: isize,
}
#[test]
fn bindgen_test_layout_glyph_matrix() {
    assert_eq!(
        ::std::mem::size_of::<glyph_matrix>(),
        104usize,
        concat!("Size of: ", stringify!(glyph_matrix))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph_matrix>(),
        8usize,
        concat!("Alignment of ", stringify!(glyph_matrix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).pool as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).rows as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).rows_allocated as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(rows_allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).nrows as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(nrows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).matrix_x as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(matrix_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).matrix_y as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(matrix_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).matrix_w as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(matrix_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).matrix_h as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(matrix_h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).window_pixel_left as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(window_pixel_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).window_pixel_top as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(window_pixel_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).window_height as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(window_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).window_width as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(window_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).window_vscroll as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(window_vscroll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).left_margin_glyphs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(left_margin_glyphs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<glyph_matrix>())).right_margin_glyphs as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(right_margin_glyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).buffer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).begv as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(begv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_matrix>())).zv as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_matrix),
            "::",
            stringify!(zv)
        )
    );
}
impl Default for glyph_matrix {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl glyph_matrix {
    #[inline]
    pub fn no_scrolling_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_scrolling_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tab_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tab_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn header_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_header_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        no_scrolling_p: bool_bf,
        tab_line_p: bool_bf,
        header_line_p: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let no_scrolling_p: u8 = unsafe { ::std::mem::transmute(no_scrolling_p) };
            no_scrolling_p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tab_line_p: u8 = unsafe { ::std::mem::transmute(tab_line_p) };
            tab_line_p as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let header_line_p: u8 = unsafe { ::std::mem::transmute(header_line_p) };
            header_line_p as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod glyph_row_area {
    #[doc = "Glyph Rows"]
    pub type Type = i32;
    pub const ANY_AREA: Type = -1;
    pub const LEFT_MARGIN_AREA: Type = 0;
    pub const TEXT_AREA: Type = 1;
    pub const RIGHT_MARGIN_AREA: Type = 2;
    pub const LAST_AREA: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct glyph_row {
    pub glyphs: [*mut glyph; 4usize],
    pub used: [::libc::c_short; 4usize],
    pub hash: ::libc::c_uint,
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub pixel_width: ::libc::c_int,
    pub ascent: ::libc::c_int,
    pub height: ::libc::c_int,
    pub phys_ascent: ::libc::c_int,
    pub phys_height: ::libc::c_int,
    pub visible_height: ::libc::c_int,
    pub extra_line_spacing: ::libc::c_int,
    pub start: display_pos,
    pub end: display_pos,
    pub minpos: text_pos,
    pub maxpos: text_pos,
    pub overlay_arrow_bitmap: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize], u32>,
    pub continuation_lines_width: ::libc::c_int,
    pub clip: *const Emacs_Rectangle,
}
#[test]
fn bindgen_test_layout_glyph_row() {
    assert_eq!(
        ::std::mem::size_of::<glyph_row>(),
        256usize,
        concat!("Size of: ", stringify!(glyph_row))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph_row>(),
        8usize,
        concat!("Alignment of ", stringify!(glyph_row))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).glyphs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).used as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).hash as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).x as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).y as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).pixel_width as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(pixel_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).ascent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).phys_ascent as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(phys_ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).phys_height as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(phys_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).visible_height as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(visible_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).extra_line_spacing as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(extra_line_spacing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).start as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).end as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).minpos as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(minpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).maxpos as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(maxpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).overlay_arrow_bitmap as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(overlay_arrow_bitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<glyph_row>())).continuation_lines_width as *const _ as usize
        },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(continuation_lines_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_row>())).clip as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_row),
            "::",
            stringify!(clip)
        )
    );
}
impl Default for glyph_row {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl glyph_row {
    #[inline]
    pub fn left_user_fringe_bitmap(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_left_user_fringe_bitmap(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn right_user_fringe_bitmap(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_right_user_fringe_bitmap(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn left_fringe_bitmap(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_left_fringe_bitmap(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn right_fringe_bitmap(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_right_fringe_bitmap(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn left_user_fringe_face_id(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_left_user_fringe_face_id(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn right_user_fringe_face_id(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_right_user_fringe_face_id(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn left_fringe_face_id(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(128usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_left_fringe_face_id(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(128usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn right_fringe_face_id(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(160usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_right_fringe_face_id(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(160usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn left_fringe_offset(&self) -> ::libc::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(180usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_left_fringe_offset(&mut self, val: ::libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(180usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn right_fringe_offset(&self) -> ::libc::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(192usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_right_fringe_offset(&mut self, val: ::libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(192usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn fringe_bitmap_periodic_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(200usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fringe_bitmap_periodic_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(200usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redraw_fringe_bitmaps_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(201usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redraw_fringe_bitmaps_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(201usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enabled_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(202usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enabled_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(202usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn truncated_on_left_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(203usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_truncated_on_left_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(203usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn truncated_on_right_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(204usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_truncated_on_right_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(204usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn continued_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(205usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_continued_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(205usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn displays_text_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(206usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_displays_text_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(206usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ends_at_zv_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(207usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ends_at_zv_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(207usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fill_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(208usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fill_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(208usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn indicate_empty_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(209usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_indicate_empty_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(209usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn contains_overlapping_glyphs_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(210usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_contains_overlapping_glyphs_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(210usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn full_width_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(211usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_full_width_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(211usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mode_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(212usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mode_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(212usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tab_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(213usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tab_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(213usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overlapped_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(214usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_overlapped_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(214usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ends_in_middle_of_char_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(215usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ends_in_middle_of_char_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(215usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn starts_in_middle_of_char_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(216usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_starts_in_middle_of_char_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(216usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overlapping_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(217usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_overlapping_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(217usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mouse_face_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(218usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mouse_face_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(218usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ends_in_newline_from_string_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(219usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ends_in_newline_from_string_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(219usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exact_window_width_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(220usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exact_window_width_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(220usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cursor_in_fringe_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(221usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cursor_in_fringe_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(221usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ends_in_ellipsis_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(222usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ends_in_ellipsis_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(222usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn indicate_bob_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(223usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_indicate_bob_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(223usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn indicate_top_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(224usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_indicate_top_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(224usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn indicate_eob_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(225usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_indicate_eob_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(225usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn indicate_bottom_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(226usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_indicate_bottom_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(226usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reversed_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(227usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reversed_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(227usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        left_user_fringe_bitmap: ::libc::c_uint,
        right_user_fringe_bitmap: ::libc::c_uint,
        left_fringe_bitmap: ::libc::c_uint,
        right_fringe_bitmap: ::libc::c_uint,
        left_user_fringe_face_id: ::libc::c_uint,
        right_user_fringe_face_id: ::libc::c_uint,
        left_fringe_face_id: ::libc::c_uint,
        right_fringe_face_id: ::libc::c_uint,
        left_fringe_offset: ::libc::c_int,
        right_fringe_offset: ::libc::c_int,
        fringe_bitmap_periodic_p: bool_bf,
        redraw_fringe_bitmaps_p: bool_bf,
        enabled_p: bool_bf,
        truncated_on_left_p: bool_bf,
        truncated_on_right_p: bool_bf,
        continued_p: bool_bf,
        displays_text_p: bool_bf,
        ends_at_zv_p: bool_bf,
        fill_line_p: bool_bf,
        indicate_empty_line_p: bool_bf,
        contains_overlapping_glyphs_p: bool_bf,
        full_width_p: bool_bf,
        mode_line_p: bool_bf,
        tab_line_p: bool_bf,
        overlapped_p: bool_bf,
        ends_in_middle_of_char_p: bool_bf,
        starts_in_middle_of_char_p: bool_bf,
        overlapping_p: bool_bf,
        mouse_face_p: bool_bf,
        ends_in_newline_from_string_p: bool_bf,
        exact_window_width_line_p: bool_bf,
        cursor_in_fringe_p: bool_bf,
        ends_in_ellipsis_p: bool_bf,
        indicate_bob_p: bool_bf,
        indicate_top_line_p: bool_bf,
        indicate_eob_p: bool_bf,
        indicate_bottom_line_p: bool_bf,
        reversed_p: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 32usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let left_user_fringe_bitmap: u32 =
                unsafe { ::std::mem::transmute(left_user_fringe_bitmap) };
            left_user_fringe_bitmap as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let right_user_fringe_bitmap: u32 =
                unsafe { ::std::mem::transmute(right_user_fringe_bitmap) };
            right_user_fringe_bitmap as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let left_fringe_bitmap: u32 = unsafe { ::std::mem::transmute(left_fringe_bitmap) };
            left_fringe_bitmap as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let right_fringe_bitmap: u32 = unsafe { ::std::mem::transmute(right_fringe_bitmap) };
            right_fringe_bitmap as u64
        });
        __bindgen_bitfield_unit.set(64usize, 20u8, {
            let left_user_fringe_face_id: u32 =
                unsafe { ::std::mem::transmute(left_user_fringe_face_id) };
            left_user_fringe_face_id as u64
        });
        __bindgen_bitfield_unit.set(96usize, 20u8, {
            let right_user_fringe_face_id: u32 =
                unsafe { ::std::mem::transmute(right_user_fringe_face_id) };
            right_user_fringe_face_id as u64
        });
        __bindgen_bitfield_unit.set(128usize, 20u8, {
            let left_fringe_face_id: u32 = unsafe { ::std::mem::transmute(left_fringe_face_id) };
            left_fringe_face_id as u64
        });
        __bindgen_bitfield_unit.set(160usize, 20u8, {
            let right_fringe_face_id: u32 = unsafe { ::std::mem::transmute(right_fringe_face_id) };
            right_fringe_face_id as u64
        });
        __bindgen_bitfield_unit.set(180usize, 8u8, {
            let left_fringe_offset: u32 = unsafe { ::std::mem::transmute(left_fringe_offset) };
            left_fringe_offset as u64
        });
        __bindgen_bitfield_unit.set(192usize, 8u8, {
            let right_fringe_offset: u32 = unsafe { ::std::mem::transmute(right_fringe_offset) };
            right_fringe_offset as u64
        });
        __bindgen_bitfield_unit.set(200usize, 1u8, {
            let fringe_bitmap_periodic_p: u8 =
                unsafe { ::std::mem::transmute(fringe_bitmap_periodic_p) };
            fringe_bitmap_periodic_p as u64
        });
        __bindgen_bitfield_unit.set(201usize, 1u8, {
            let redraw_fringe_bitmaps_p: u8 =
                unsafe { ::std::mem::transmute(redraw_fringe_bitmaps_p) };
            redraw_fringe_bitmaps_p as u64
        });
        __bindgen_bitfield_unit.set(202usize, 1u8, {
            let enabled_p: u8 = unsafe { ::std::mem::transmute(enabled_p) };
            enabled_p as u64
        });
        __bindgen_bitfield_unit.set(203usize, 1u8, {
            let truncated_on_left_p: u8 = unsafe { ::std::mem::transmute(truncated_on_left_p) };
            truncated_on_left_p as u64
        });
        __bindgen_bitfield_unit.set(204usize, 1u8, {
            let truncated_on_right_p: u8 = unsafe { ::std::mem::transmute(truncated_on_right_p) };
            truncated_on_right_p as u64
        });
        __bindgen_bitfield_unit.set(205usize, 1u8, {
            let continued_p: u8 = unsafe { ::std::mem::transmute(continued_p) };
            continued_p as u64
        });
        __bindgen_bitfield_unit.set(206usize, 1u8, {
            let displays_text_p: u8 = unsafe { ::std::mem::transmute(displays_text_p) };
            displays_text_p as u64
        });
        __bindgen_bitfield_unit.set(207usize, 1u8, {
            let ends_at_zv_p: u8 = unsafe { ::std::mem::transmute(ends_at_zv_p) };
            ends_at_zv_p as u64
        });
        __bindgen_bitfield_unit.set(208usize, 1u8, {
            let fill_line_p: u8 = unsafe { ::std::mem::transmute(fill_line_p) };
            fill_line_p as u64
        });
        __bindgen_bitfield_unit.set(209usize, 1u8, {
            let indicate_empty_line_p: u8 = unsafe { ::std::mem::transmute(indicate_empty_line_p) };
            indicate_empty_line_p as u64
        });
        __bindgen_bitfield_unit.set(210usize, 1u8, {
            let contains_overlapping_glyphs_p: u8 =
                unsafe { ::std::mem::transmute(contains_overlapping_glyphs_p) };
            contains_overlapping_glyphs_p as u64
        });
        __bindgen_bitfield_unit.set(211usize, 1u8, {
            let full_width_p: u8 = unsafe { ::std::mem::transmute(full_width_p) };
            full_width_p as u64
        });
        __bindgen_bitfield_unit.set(212usize, 1u8, {
            let mode_line_p: u8 = unsafe { ::std::mem::transmute(mode_line_p) };
            mode_line_p as u64
        });
        __bindgen_bitfield_unit.set(213usize, 1u8, {
            let tab_line_p: u8 = unsafe { ::std::mem::transmute(tab_line_p) };
            tab_line_p as u64
        });
        __bindgen_bitfield_unit.set(214usize, 1u8, {
            let overlapped_p: u8 = unsafe { ::std::mem::transmute(overlapped_p) };
            overlapped_p as u64
        });
        __bindgen_bitfield_unit.set(215usize, 1u8, {
            let ends_in_middle_of_char_p: u8 =
                unsafe { ::std::mem::transmute(ends_in_middle_of_char_p) };
            ends_in_middle_of_char_p as u64
        });
        __bindgen_bitfield_unit.set(216usize, 1u8, {
            let starts_in_middle_of_char_p: u8 =
                unsafe { ::std::mem::transmute(starts_in_middle_of_char_p) };
            starts_in_middle_of_char_p as u64
        });
        __bindgen_bitfield_unit.set(217usize, 1u8, {
            let overlapping_p: u8 = unsafe { ::std::mem::transmute(overlapping_p) };
            overlapping_p as u64
        });
        __bindgen_bitfield_unit.set(218usize, 1u8, {
            let mouse_face_p: u8 = unsafe { ::std::mem::transmute(mouse_face_p) };
            mouse_face_p as u64
        });
        __bindgen_bitfield_unit.set(219usize, 1u8, {
            let ends_in_newline_from_string_p: u8 =
                unsafe { ::std::mem::transmute(ends_in_newline_from_string_p) };
            ends_in_newline_from_string_p as u64
        });
        __bindgen_bitfield_unit.set(220usize, 1u8, {
            let exact_window_width_line_p: u8 =
                unsafe { ::std::mem::transmute(exact_window_width_line_p) };
            exact_window_width_line_p as u64
        });
        __bindgen_bitfield_unit.set(221usize, 1u8, {
            let cursor_in_fringe_p: u8 = unsafe { ::std::mem::transmute(cursor_in_fringe_p) };
            cursor_in_fringe_p as u64
        });
        __bindgen_bitfield_unit.set(222usize, 1u8, {
            let ends_in_ellipsis_p: u8 = unsafe { ::std::mem::transmute(ends_in_ellipsis_p) };
            ends_in_ellipsis_p as u64
        });
        __bindgen_bitfield_unit.set(223usize, 1u8, {
            let indicate_bob_p: u8 = unsafe { ::std::mem::transmute(indicate_bob_p) };
            indicate_bob_p as u64
        });
        __bindgen_bitfield_unit.set(224usize, 1u8, {
            let indicate_top_line_p: u8 = unsafe { ::std::mem::transmute(indicate_top_line_p) };
            indicate_top_line_p as u64
        });
        __bindgen_bitfield_unit.set(225usize, 1u8, {
            let indicate_eob_p: u8 = unsafe { ::std::mem::transmute(indicate_eob_p) };
            indicate_eob_p as u64
        });
        __bindgen_bitfield_unit.set(226usize, 1u8, {
            let indicate_bottom_line_p: u8 =
                unsafe { ::std::mem::transmute(indicate_bottom_line_p) };
            indicate_bottom_line_p as u64
        });
        __bindgen_bitfield_unit.set(227usize, 1u8, {
            let reversed_p: u8 = unsafe { ::std::mem::transmute(reversed_p) };
            reversed_p as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}space_glyph"]
    pub static mut space_glyph: glyph;
}
extern "C" {
    #[link_name = "\u{1}display_completed"]
    pub static mut display_completed: bool;
}
pub mod draw_glyphs_face {
    #[doc = "Glyph Strings"]
    pub type Type = u32;
    pub const DRAW_NORMAL_TEXT: Type = 0;
    pub const DRAW_INVERSE_VIDEO: Type = 1;
    pub const DRAW_CURSOR: Type = 2;
    pub const DRAW_MOUSE_FACE: Type = 3;
    pub const DRAW_IMAGE_RAISED: Type = 4;
    pub const DRAW_IMAGE_SUNKEN: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct glyph_string {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub ybase: ::libc::c_int,
    pub width: ::libc::c_int,
    pub background_width: ::libc::c_int,
    pub height: ::libc::c_int,
    pub left_overhang: ::libc::c_int,
    pub right_overhang: ::libc::c_int,
    pub f: *mut frame,
    pub w: *mut window,
    pub row: *mut glyph_row,
    pub area: glyph_row_area::Type,
    pub char2b: *mut ::libc::c_uint,
    pub nchars: ::libc::c_int,
    pub hl: draw_glyphs_face::Type,
    pub face: *mut face,
    pub font: *mut font,
    pub cmp: *mut composition,
    pub cmp_id: isize,
    pub cmp_from: ::libc::c_int,
    pub cmp_to: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub gc: *mut Emacs_GC,
    pub first_glyph: *mut glyph,
    pub img: *mut image,
    pub xwidget: *mut xwidget,
    pub slice: glyph_slice,
    pub clip_head: *mut glyph_string,
    pub clip_tail: *mut glyph_string,
    pub clip: [Emacs_Rectangle; 2usize],
    pub num_clips: ::libc::c_int,
    pub underline_position: ::libc::c_int,
    pub underline_thickness: ::libc::c_int,
    pub next: *mut glyph_string,
    pub prev: *mut glyph_string,
}
#[test]
fn bindgen_test_layout_glyph_string() {
    assert_eq!(
        ::std::mem::size_of::<glyph_string>(),
        248usize,
        concat!("Size of: ", stringify!(glyph_string))
    );
    assert_eq!(
        ::std::mem::align_of::<glyph_string>(),
        8usize,
        concat!("Alignment of ", stringify!(glyph_string))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).ybase as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(ybase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).background_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(background_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).left_overhang as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(left_overhang)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).right_overhang as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(right_overhang)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).f as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).w as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).row as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(row)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).area as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).char2b as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(char2b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).nchars as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).hl as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(hl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).face as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(face)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).font as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).cmp as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).cmp_id as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(cmp_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).cmp_from as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(cmp_from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).cmp_to as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(cmp_to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).gc as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).first_glyph as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(first_glyph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).img as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(img)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).xwidget as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(xwidget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).slice as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).clip_head as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(clip_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).clip_tail as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(clip_tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).clip as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(clip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).num_clips as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(num_clips)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).underline_position as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(underline_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<glyph_string>())).underline_thickness as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(underline_thickness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).next as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyph_string>())).prev as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(glyph_string),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for glyph_string {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl glyph_string {
    #[inline]
    pub fn extends_to_end_of_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extends_to_end_of_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn background_filled_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_background_filled_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn font_not_found_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_font_not_found_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stippled_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_stippled_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_overlaps(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_for_overlaps(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn padding_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_padding_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        extends_to_end_of_line_p: bool_bf,
        background_filled_p: bool_bf,
        font_not_found_p: bool_bf,
        stippled_p: bool_bf,
        for_overlaps: ::libc::c_uint,
        padding_p: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let extends_to_end_of_line_p: u8 =
                unsafe { ::std::mem::transmute(extends_to_end_of_line_p) };
            extends_to_end_of_line_p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let background_filled_p: u8 = unsafe { ::std::mem::transmute(background_filled_p) };
            background_filled_p as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let font_not_found_p: u8 = unsafe { ::std::mem::transmute(font_not_found_p) };
            font_not_found_p as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let stippled_p: u8 = unsafe { ::std::mem::transmute(stippled_p) };
            stippled_p as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let for_overlaps: u32 = unsafe { ::std::mem::transmute(for_overlaps) };
            for_overlaps as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let padding_p: u8 = unsafe { ::std::mem::transmute(padding_p) };
            padding_p as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod lface_attribute_index {
    #[doc = "Faces"]
    pub type Type = u32;
    pub const LFACE_FAMILY_INDEX: Type = 1;
    pub const LFACE_FOUNDRY_INDEX: Type = 2;
    pub const LFACE_SWIDTH_INDEX: Type = 3;
    pub const LFACE_HEIGHT_INDEX: Type = 4;
    pub const LFACE_WEIGHT_INDEX: Type = 5;
    pub const LFACE_SLANT_INDEX: Type = 6;
    pub const LFACE_UNDERLINE_INDEX: Type = 7;
    pub const LFACE_INVERSE_INDEX: Type = 8;
    pub const LFACE_FOREGROUND_INDEX: Type = 9;
    pub const LFACE_BACKGROUND_INDEX: Type = 10;
    pub const LFACE_STIPPLE_INDEX: Type = 11;
    pub const LFACE_OVERLINE_INDEX: Type = 12;
    pub const LFACE_STRIKE_THROUGH_INDEX: Type = 13;
    pub const LFACE_BOX_INDEX: Type = 14;
    pub const LFACE_FONT_INDEX: Type = 15;
    pub const LFACE_INHERIT_INDEX: Type = 16;
    pub const LFACE_FONTSET_INDEX: Type = 17;
    pub const LFACE_DISTANT_FOREGROUND_INDEX: Type = 18;
    pub const LFACE_EXTEND_INDEX: Type = 19;
    pub const LFACE_VECTOR_SIZE: Type = 20;
}
pub mod face_box_type {
    pub type Type = u32;
    pub const FACE_NO_BOX: Type = 0;
    pub const FACE_SIMPLE_BOX: Type = 1;
    pub const FACE_RAISED_BOX: Type = 2;
    pub const FACE_SUNKEN_BOX: Type = 3;
}
pub mod face_underline_type {
    pub type Type = u32;
    pub const FACE_NO_UNDERLINE: Type = 0;
    pub const FACE_UNDER_LINE: Type = 1;
    pub const FACE_UNDER_WAVE: Type = 2;
}
#[repr(C)]
pub struct face {
    pub lface: [Lisp_Object; 20usize],
    pub id: ::libc::c_int,
    pub gc: *mut Emacs_GC,
    pub stipple: isize,
    pub foreground: ::libc::c_ulong,
    pub background: ::libc::c_ulong,
    pub underline_color: ::libc::c_ulong,
    pub overline_color: ::libc::c_ulong,
    pub strike_through_color: ::libc::c_ulong,
    pub box_color: ::libc::c_ulong,
    pub font: *mut font,
    pub fontset: ::libc::c_int,
    pub box_vertical_line_width: ::libc::c_int,
    pub box_horizontal_line_width: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub hash: usize,
    pub next: *mut face,
    pub prev: *mut face,
    pub ascii_face: *mut face,
}
#[test]
fn bindgen_test_layout_face() {
    assert_eq!(
        ::std::mem::size_of::<face>(),
        288usize,
        concat!("Size of: ", stringify!(face))
    );
    assert_eq!(
        ::std::mem::align_of::<face>(),
        8usize,
        concat!("Alignment of ", stringify!(face))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).lface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(lface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).id as *const _ as usize },
        160usize,
        concat!("Offset of field: ", stringify!(face), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).gc as *const _ as usize },
        168usize,
        concat!("Offset of field: ", stringify!(face), "::", stringify!(gc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).stipple as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(stipple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).foreground as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).background as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).underline_color as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(underline_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).overline_color as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(overline_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).strike_through_color as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(strike_through_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).box_color as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(box_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).font as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).fontset as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(fontset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).box_vertical_line_width as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(box_vertical_line_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).box_horizontal_line_width as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(box_horizontal_line_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).hash as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).next as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).prev as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face>())).ascii_face as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(face),
            "::",
            stringify!(ascii_face)
        )
    );
}
impl Default for face {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl face {
    #[inline]
    pub fn box_(&self) -> face_box_type::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_box(&mut self, val: face_box_type::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn underline(&self) -> face_underline_type::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_underline(&mut self, val: face_underline_type::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn use_box_color_for_shadows_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_box_color_for_shadows_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overline_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_overline_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn strike_through_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_strike_through_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn foreground_defaulted_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_foreground_defaulted_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn background_defaulted_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_background_defaulted_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn underline_defaulted_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_underline_defaulted_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overline_color_defaulted_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_overline_color_defaulted_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn strike_through_color_defaulted_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_strike_through_color_defaulted_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn box_color_defaulted_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_box_color_defaulted_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tty_bold_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tty_bold_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tty_italic_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tty_italic_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tty_underline_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tty_underline_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tty_reverse_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tty_reverse_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tty_strike_through_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tty_strike_through_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn colors_copied_bitwise_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_colors_copied_bitwise_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overstrike(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_overstrike(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        box_: face_box_type::Type,
        underline: face_underline_type::Type,
        use_box_color_for_shadows_p: bool_bf,
        overline_p: bool_bf,
        strike_through_p: bool_bf,
        foreground_defaulted_p: bool_bf,
        background_defaulted_p: bool_bf,
        underline_defaulted_p: bool_bf,
        overline_color_defaulted_p: bool_bf,
        strike_through_color_defaulted_p: bool_bf,
        box_color_defaulted_p: bool_bf,
        tty_bold_p: bool_bf,
        tty_italic_p: bool_bf,
        tty_underline_p: bool_bf,
        tty_reverse_p: bool_bf,
        tty_strike_through_p: bool_bf,
        colors_copied_bitwise_p: bool_bf,
        overstrike: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let box_: u32 = unsafe { ::std::mem::transmute(box_) };
            box_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let underline: u32 = unsafe { ::std::mem::transmute(underline) };
            underline as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let use_box_color_for_shadows_p: u8 =
                unsafe { ::std::mem::transmute(use_box_color_for_shadows_p) };
            use_box_color_for_shadows_p as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let overline_p: u8 = unsafe { ::std::mem::transmute(overline_p) };
            overline_p as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let strike_through_p: u8 = unsafe { ::std::mem::transmute(strike_through_p) };
            strike_through_p as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let foreground_defaulted_p: u8 =
                unsafe { ::std::mem::transmute(foreground_defaulted_p) };
            foreground_defaulted_p as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let background_defaulted_p: u8 =
                unsafe { ::std::mem::transmute(background_defaulted_p) };
            background_defaulted_p as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let underline_defaulted_p: u8 = unsafe { ::std::mem::transmute(underline_defaulted_p) };
            underline_defaulted_p as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let overline_color_defaulted_p: u8 =
                unsafe { ::std::mem::transmute(overline_color_defaulted_p) };
            overline_color_defaulted_p as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let strike_through_color_defaulted_p: u8 =
                unsafe { ::std::mem::transmute(strike_through_color_defaulted_p) };
            strike_through_color_defaulted_p as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let box_color_defaulted_p: u8 = unsafe { ::std::mem::transmute(box_color_defaulted_p) };
            box_color_defaulted_p as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tty_bold_p: u8 = unsafe { ::std::mem::transmute(tty_bold_p) };
            tty_bold_p as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tty_italic_p: u8 = unsafe { ::std::mem::transmute(tty_italic_p) };
            tty_italic_p as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tty_underline_p: u8 = unsafe { ::std::mem::transmute(tty_underline_p) };
            tty_underline_p as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let tty_reverse_p: u8 = unsafe { ::std::mem::transmute(tty_reverse_p) };
            tty_reverse_p as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let tty_strike_through_p: u8 = unsafe { ::std::mem::transmute(tty_strike_through_p) };
            tty_strike_through_p as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let colors_copied_bitwise_p: u8 =
                unsafe { ::std::mem::transmute(colors_copied_bitwise_p) };
            colors_copied_bitwise_p as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let overstrike: u8 = unsafe { ::std::mem::transmute(overstrike) };
            overstrike as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn face_tty_specified_color(color: ::libc::c_ulong) -> bool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum face_id {
    DEFAULT_FACE_ID = 0,
    MODE_LINE_FACE_ID = 1,
    MODE_LINE_INACTIVE_FACE_ID = 2,
    TOOL_BAR_FACE_ID = 3,
    FRINGE_FACE_ID = 4,
    HEADER_LINE_FACE_ID = 5,
    SCROLL_BAR_FACE_ID = 6,
    BORDER_FACE_ID = 7,
    CURSOR_FACE_ID = 8,
    MOUSE_FACE_ID = 9,
    MENU_FACE_ID = 10,
    VERTICAL_BORDER_FACE_ID = 11,
    WINDOW_DIVIDER_FACE_ID = 12,
    WINDOW_DIVIDER_FIRST_PIXEL_FACE_ID = 13,
    WINDOW_DIVIDER_LAST_PIXEL_FACE_ID = 14,
    INTERNAL_BORDER_FACE_ID = 15,
    CHILD_FRAME_BORDER_FACE_ID = 16,
    TAB_BAR_FACE_ID = 17,
    TAB_LINE_FACE_ID = 18,
    BASIC_FACE_ID_SENTINEL = 19,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct face_cache {
    pub buckets: *mut *mut face,
    pub f: *mut frame,
    pub faces_by_id: *mut *mut face,
    pub size: isize,
    pub used: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_face_cache() {
    assert_eq!(
        ::std::mem::size_of::<face_cache>(),
        40usize,
        concat!("Size of: ", stringify!(face_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<face_cache>(),
        8usize,
        concat!("Alignment of ", stringify!(face_cache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face_cache>())).buckets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(face_cache),
            "::",
            stringify!(buckets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face_cache>())).f as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(face_cache),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face_cache>())).faces_by_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(face_cache),
            "::",
            stringify!(faces_by_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face_cache>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(face_cache),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<face_cache>())).used as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(face_cache),
            "::",
            stringify!(used)
        )
    );
}
impl Default for face_cache {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl face_cache {
    #[inline]
    pub fn menu_face_changed_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_menu_face_changed_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(menu_face_changed_p: bool_bf) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let menu_face_changed_p: u8 = unsafe { ::std::mem::transmute(menu_face_changed_p) };
            menu_face_changed_p as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn FACE_SUITABLE_FOR_ASCII_CHAR_P(face: *mut face) -> bool;
}
extern "C" {
    pub fn FACE_FOR_CHAR(
        f: *mut frame,
        face: *mut face,
        character: ::libc::c_int,
        pos: isize,
        object: Lisp_Object,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn GLYPH_CHAR_VALID_P(g: GLYPH) -> bool;
}
extern "C" {
    pub fn GLYPH_CODE_P(gc: Lisp_Object) -> bool;
}
pub mod bidi_type_t {
    pub type Type = u32;
    pub const UNKNOWN_BT: Type = 0;
    pub const STRONG_L: Type = 1;
    pub const STRONG_R: Type = 2;
    pub const WEAK_EN: Type = 3;
    pub const WEAK_AN: Type = 4;
    pub const WEAK_BN: Type = 5;
    pub const NEUTRAL_B: Type = 6;
    pub const STRONG_AL: Type = 7;
    pub const LRE: Type = 8;
    pub const LRO: Type = 9;
    pub const RLE: Type = 10;
    pub const RLO: Type = 11;
    pub const PDF: Type = 12;
    pub const LRI: Type = 13;
    pub const RLI: Type = 14;
    pub const FSI: Type = 15;
    pub const PDI: Type = 16;
    pub const WEAK_ES: Type = 17;
    pub const WEAK_ET: Type = 18;
    pub const WEAK_CS: Type = 19;
    pub const WEAK_NSM: Type = 20;
    pub const NEUTRAL_S: Type = 21;
    pub const NEUTRAL_WS: Type = 22;
    pub const NEUTRAL_ON: Type = 23;
}
pub mod bidi_bracket_type_t {
    pub type Type = u32;
    pub const BIDI_BRACKET_NONE: Type = 1;
    pub const BIDI_BRACKET_OPEN: Type = 2;
    pub const BIDI_BRACKET_CLOSE: Type = 3;
}
pub mod bidi_dir_t {
    pub type Type = u32;
    pub const NEUTRAL_DIR: Type = 0;
    pub const L2R: Type = 1;
    pub const R2L: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bidi_saved_info {
    pub charpos: isize,
    pub type_: bidi_type_t::Type,
    pub orig_type: bidi_type_t::Type,
}
#[test]
fn bindgen_test_layout_bidi_saved_info() {
    assert_eq!(
        ::std::mem::size_of::<bidi_saved_info>(),
        16usize,
        concat!("Size of: ", stringify!(bidi_saved_info))
    );
    assert_eq!(
        ::std::mem::align_of::<bidi_saved_info>(),
        8usize,
        concat!("Alignment of ", stringify!(bidi_saved_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_saved_info>())).charpos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_saved_info),
            "::",
            stringify!(charpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_saved_info>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_saved_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_saved_info>())).orig_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_saved_info),
            "::",
            stringify!(orig_type)
        )
    );
}
impl Default for bidi_saved_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bidi_stack {
    pub next_for_neutral_pos: isize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub level: ::libc::c_uchar,
    pub flags: ::libc::c_uchar,
}
#[test]
fn bindgen_test_layout_bidi_stack() {
    assert_eq!(
        ::std::mem::size_of::<bidi_stack>(),
        16usize,
        concat!("Size of: ", stringify!(bidi_stack))
    );
    assert_eq!(
        ::std::mem::align_of::<bidi_stack>(),
        8usize,
        concat!("Alignment of ", stringify!(bidi_stack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_stack>())).next_for_neutral_pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_stack),
            "::",
            stringify!(next_for_neutral_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_stack>())).level as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_stack),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_stack>())).flags as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_stack),
            "::",
            stringify!(flags)
        )
    );
}
impl bidi_stack {
    #[inline]
    pub fn next_for_neutral_type(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_next_for_neutral_type(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn last_strong_type(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_last_strong_type(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn prev_for_neutral_type(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_prev_for_neutral_type(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        next_for_neutral_type: ::libc::c_uint,
        last_strong_type: ::libc::c_uint,
        prev_for_neutral_type: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let next_for_neutral_type: u32 =
                unsafe { ::std::mem::transmute(next_for_neutral_type) };
            next_for_neutral_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let last_strong_type: u32 = unsafe { ::std::mem::transmute(last_strong_type) };
            last_strong_type as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let prev_for_neutral_type: u32 =
                unsafe { ::std::mem::transmute(prev_for_neutral_type) };
            prev_for_neutral_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct bidi_string_data {
    pub lstring: Lisp_Object,
    pub s: *const ::libc::c_uchar,
    pub schars: isize,
    pub bufpos: isize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_bidi_string_data() {
    assert_eq!(
        ::std::mem::size_of::<bidi_string_data>(),
        40usize,
        concat!("Size of: ", stringify!(bidi_string_data))
    );
    assert_eq!(
        ::std::mem::align_of::<bidi_string_data>(),
        8usize,
        concat!("Alignment of ", stringify!(bidi_string_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_string_data>())).lstring as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_string_data),
            "::",
            stringify!(lstring)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_string_data>())).s as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_string_data),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_string_data>())).schars as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_string_data),
            "::",
            stringify!(schars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_string_data>())).bufpos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_string_data),
            "::",
            stringify!(bufpos)
        )
    );
}
impl Default for bidi_string_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl bidi_string_data {
    #[inline]
    pub fn from_disp_str(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_from_disp_str(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unibyte(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unibyte(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        from_disp_str: bool_bf,
        unibyte: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let from_disp_str: u8 = unsafe { ::std::mem::transmute(from_disp_str) };
            from_disp_str as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let unibyte: u8 = unsafe { ::std::mem::transmute(unibyte) };
            unibyte as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct bidi_it {
    pub bytepos: isize,
    pub charpos: isize,
    pub ch: ::libc::c_int,
    pub nchars: isize,
    pub ch_len: isize,
    pub type_: bidi_type_t::Type,
    pub type_after_wn: bidi_type_t::Type,
    pub orig_type: bidi_type_t::Type,
    pub resolved_level: ::libc::c_schar,
    pub isolate_level: ::libc::c_schar,
    pub invalid_levels: isize,
    pub invalid_isolates: isize,
    pub prev: bidi_saved_info,
    pub last_strong: bidi_saved_info,
    pub next_for_neutral: bidi_saved_info,
    pub prev_for_neutral: bidi_saved_info,
    pub next_for_ws: bidi_saved_info,
    pub bracket_pairing_pos: isize,
    pub bracket_enclosed_type: bidi_type_t::Type,
    pub next_en_pos: isize,
    pub next_en_type: bidi_type_t::Type,
    pub sos: bidi_dir_t::Type,
    pub scan_dir: ::libc::c_int,
    pub disp_pos: isize,
    pub disp_prop: ::libc::c_int,
    pub stack_idx: ::libc::c_int,
    pub level_stack: [bidi_stack; 128usize],
    pub string: bidi_string_data,
    pub w: *mut window,
    pub paragraph_dir: bidi_dir_t::Type,
    pub separator_limit: isize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_bidi_it() {
    assert_eq!(
        ::std::mem::size_of::<bidi_it>(),
        2328usize,
        concat!("Size of: ", stringify!(bidi_it))
    );
    assert_eq!(
        ::std::mem::align_of::<bidi_it>(),
        8usize,
        concat!("Alignment of ", stringify!(bidi_it))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).bytepos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(bytepos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).charpos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(charpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).ch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(ch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).nchars as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).ch_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(ch_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).type_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).type_after_wn as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(type_after_wn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).orig_type as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(orig_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).resolved_level as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(resolved_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).isolate_level as *const _ as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(isolate_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).invalid_levels as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(invalid_levels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).invalid_isolates as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(invalid_isolates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).prev as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).last_strong as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(last_strong)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).next_for_neutral as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(next_for_neutral)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).prev_for_neutral as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(prev_for_neutral)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).next_for_ws as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(next_for_ws)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).bracket_pairing_pos as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(bracket_pairing_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).bracket_enclosed_type as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(bracket_enclosed_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).next_en_pos as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(next_en_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).next_en_type as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(next_en_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).sos as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(sos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).scan_dir as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(scan_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).disp_pos as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(disp_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).disp_prop as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(disp_prop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).stack_idx as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(stack_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).level_stack as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(level_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).string as *const _ as usize },
        2256usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).w as *const _ as usize },
        2296usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).paragraph_dir as *const _ as usize },
        2304usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(paragraph_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bidi_it>())).separator_limit as *const _ as usize },
        2312usize,
        concat!(
            "Offset of field: ",
            stringify!(bidi_it),
            "::",
            stringify!(separator_limit)
        )
    );
}
impl Default for bidi_it {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl bidi_it {
    #[inline]
    pub fn first_elt(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_first_elt(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_paragraph(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_new_paragraph(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_window_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frame_window_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        first_elt: bool_bf,
        new_paragraph: bool_bf,
        frame_window_p: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let first_elt: u8 = unsafe { ::std::mem::transmute(first_elt) };
            first_elt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let new_paragraph: u8 = unsafe { ::std::mem::transmute(new_paragraph) };
            new_paragraph as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frame_window_p: u8 = unsafe { ::std::mem::transmute(frame_window_p) };
            frame_window_p as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Fringes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct draw_fringe_bitmap_params {
    pub which: ::libc::c_int,
    pub bits: *mut ::libc::c_ushort,
    pub wd: ::libc::c_int,
    pub h: ::libc::c_int,
    pub dh: ::libc::c_int,
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub bx: ::libc::c_int,
    pub nx: ::libc::c_int,
    pub by: ::libc::c_int,
    pub ny: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub face: *mut face,
}
#[test]
fn bindgen_test_layout_draw_fringe_bitmap_params() {
    assert_eq!(
        ::std::mem::size_of::<draw_fringe_bitmap_params>(),
        64usize,
        concat!("Size of: ", stringify!(draw_fringe_bitmap_params))
    );
    assert_eq!(
        ::std::mem::align_of::<draw_fringe_bitmap_params>(),
        8usize,
        concat!("Alignment of ", stringify!(draw_fringe_bitmap_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<draw_fringe_bitmap_params>())).which as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(draw_fringe_bitmap_params),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<draw_fringe_bitmap_params>())).bits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(draw_fringe_bitmap_params),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<draw_fringe_bitmap_params>())).wd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(draw_fringe_bitmap_params),
            "::",
            stringify!(wd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<draw_fringe_bitmap_params>())).h as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(draw_fringe_bitmap_params),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<draw_fringe_bitmap_params>())).dh as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(draw_fringe_bitmap_params),
            "::",
            stringify!(dh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<draw_fringe_bitmap_params>())).x as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(draw_fringe_bitmap_params),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<draw_fringe_bitmap_params>())).y as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(draw_fringe_bitmap_params),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<draw_fringe_bitmap_params>())).bx as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(draw_fringe_bitmap_params),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<draw_fringe_bitmap_params>())).nx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(draw_fringe_bitmap_params),
            "::",
            stringify!(nx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<draw_fringe_bitmap_params>())).by as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(draw_fringe_bitmap_params),
            "::",
            stringify!(by)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<draw_fringe_bitmap_params>())).ny as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(draw_fringe_bitmap_params),
            "::",
            stringify!(ny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<draw_fringe_bitmap_params>())).face as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(draw_fringe_bitmap_params),
            "::",
            stringify!(face)
        )
    );
}
impl Default for draw_fringe_bitmap_params {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl draw_fringe_bitmap_params {
    #[inline]
    pub fn cursor_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cursor_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overlay_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_overlay_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cursor_p: bool_bf,
        overlay_p: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cursor_p: u8 = unsafe { ::std::mem::transmute(cursor_p) };
            cursor_p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let overlay_p: u8 = unsafe { ::std::mem::transmute(overlay_p) };
            overlay_p as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod display_element_type {
    #[doc = "Display Iterator"]
    pub type Type = u32;
    pub const IT_CHARACTER: Type = 0;
    pub const IT_COMPOSITION: Type = 1;
    pub const IT_GLYPHLESS: Type = 2;
    pub const IT_IMAGE: Type = 3;
    pub const IT_STRETCH: Type = 4;
    pub const IT_EOB: Type = 5;
    pub const IT_TRUNCATION: Type = 6;
    pub const IT_CONTINUATION: Type = 7;
    pub const IT_XWIDGET: Type = 8;
}
pub mod prop_idx {
    pub type Type = u32;
    pub const FONTIFIED_PROP_IDX: Type = 0;
    pub const FACE_PROP_IDX: Type = 1;
    pub const INVISIBLE_PROP_IDX: Type = 2;
    pub const DISPLAY_PROP_IDX: Type = 3;
    pub const COMPOSITION_PROP_IDX: Type = 4;
    pub const OVERLAY_PROP_IDX: Type = 5;
    pub const LAST_PROP_IDX: Type = 6;
}
pub mod line_wrap_method {
    pub type Type = u32;
    pub const TRUNCATE: Type = 0;
    pub const WORD_WRAP: Type = 1;
    pub const WINDOW_WRAP: Type = 2;
}
pub mod glyphless_display_method {
    pub type Type = u32;
    pub const GLYPHLESS_DISPLAY_THIN_SPACE: Type = 0;
    pub const GLYPHLESS_DISPLAY_EMPTY_BOX: Type = 1;
    pub const GLYPHLESS_DISPLAY_ACRONYM: Type = 2;
    pub const GLYPHLESS_DISPLAY_HEX_CODE: Type = 3;
}
#[repr(C)]
pub struct it_slice {
    pub x: Lisp_Object,
    pub y: Lisp_Object,
    pub width: Lisp_Object,
    pub height: Lisp_Object,
}
#[test]
fn bindgen_test_layout_it_slice() {
    assert_eq!(
        ::std::mem::size_of::<it_slice>(),
        32usize,
        concat!("Size of: ", stringify!(it_slice))
    );
    assert_eq!(
        ::std::mem::align_of::<it_slice>(),
        8usize,
        concat!("Alignment of ", stringify!(it_slice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it_slice>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(it_slice),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it_slice>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(it_slice),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it_slice>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(it_slice),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it_slice>())).height as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(it_slice),
            "::",
            stringify!(height)
        )
    );
}
impl Default for it_slice {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod it_method {
    pub type Type = u32;
    pub const GET_FROM_BUFFER: Type = 0;
    pub const GET_FROM_DISPLAY_VECTOR: Type = 1;
    pub const GET_FROM_STRING: Type = 2;
    pub const GET_FROM_C_STRING: Type = 3;
    pub const GET_FROM_IMAGE: Type = 4;
    pub const GET_FROM_STRETCH: Type = 5;
    pub const GET_FROM_XWIDGET: Type = 6;
    pub const NUM_IT_METHODS: Type = 7;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct composition_it {
    pub stop_pos: isize,
    pub id: isize,
    pub ch: ::libc::c_int,
    pub rule_idx: EMACS_INT,
    pub lookback: isize,
    pub nglyphs: ::libc::c_int,
    pub reversed_p: bool,
    #[doc = " The following members contain information about the current"]
    #[doc = "grapheme cluster."]
    pub charpos: isize,
    pub nchars: ::libc::c_int,
    pub nbytes: ::libc::c_int,
    pub from: ::libc::c_int,
    pub to: ::libc::c_int,
    pub width: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_composition_it() {
    assert_eq!(
        ::std::mem::size_of::<composition_it>(),
        80usize,
        concat!("Size of: ", stringify!(composition_it))
    );
    assert_eq!(
        ::std::mem::align_of::<composition_it>(),
        8usize,
        concat!("Alignment of ", stringify!(composition_it))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).stop_pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(stop_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).ch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(ch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).rule_idx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(rule_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).lookback as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(lookback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).nglyphs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(nglyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).reversed_p as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(reversed_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).charpos as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(charpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).nchars as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).nbytes as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(nbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).from as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).to as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_it>())).width as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_it),
            "::",
            stringify!(width)
        )
    );
}
#[repr(C)]
pub struct it {
    pub window: Lisp_Object,
    pub w: *mut window,
    pub f: *mut frame,
    pub method: it_method::Type,
    pub stop_charpos: isize,
    pub prev_stop: isize,
    pub base_level_stop: isize,
    pub end_charpos: isize,
    pub s: *const ::libc::c_uchar,
    pub string_nchars: isize,
    pub redisplay_end_trigger_charpos: isize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub dp: *mut Lisp_Char_Table,
    pub dpvec: *mut Lisp_Object,
    pub dpend: *mut Lisp_Object,
    pub dpvec_char_len: ::libc::c_int,
    pub dpvec_face_id: ::libc::c_int,
    pub saved_face_id: ::libc::c_int,
    pub ctl_chars: [Lisp_Object; 16usize],
    pub start: display_pos,
    pub current: display_pos,
    pub n_overlay_strings: isize,
    pub overlay_strings_charpos: isize,
    pub overlay_strings: [Lisp_Object; 16usize],
    pub string_overlays: [Lisp_Object; 16usize],
    pub string: Lisp_Object,
    pub from_overlay: Lisp_Object,
    pub stack: [it_iterator_stack_entry; 5usize],
    pub sp: ::libc::c_int,
    pub selective: isize,
    pub what: display_element_type::Type,
    pub face_id: ::libc::c_int,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub line_wrap: line_wrap_method::Type,
    pub base_face_id: ::libc::c_int,
    pub c: ::libc::c_int,
    pub len: ::libc::c_int,
    pub cmp_it: composition_it,
    pub char_to_display: ::libc::c_int,
    pub glyphless_method: glyphless_display_method::Type,
    pub image_id: isize,
    pub xwidget: *mut xwidget,
    pub slice: it_slice,
    pub space_width: Lisp_Object,
    pub voffset: ::libc::c_short,
    pub tab_width: ::libc::c_short,
    pub font_height: Lisp_Object,
    pub object: Lisp_Object,
    pub position: text_pos,
    pub truncation_pixel_width: ::libc::c_short,
    pub continuation_pixel_width: ::libc::c_short,
    pub first_visible_x: ::libc::c_int,
    pub last_visible_x: ::libc::c_int,
    pub last_visible_y: ::libc::c_int,
    pub extra_line_spacing: ::libc::c_int,
    pub max_extra_line_spacing: ::libc::c_int,
    pub override_ascent: ::libc::c_int,
    pub override_descent: ::libc::c_int,
    pub override_boff: ::libc::c_int,
    pub glyph_row: *mut glyph_row,
    pub area: glyph_row_area::Type,
    pub nglyphs: ::libc::c_int,
    pub pixel_width: ::libc::c_int,
    pub ascent: ::libc::c_int,
    pub descent: ::libc::c_int,
    pub max_ascent: ::libc::c_int,
    pub max_descent: ::libc::c_int,
    pub phys_ascent: ::libc::c_int,
    pub phys_descent: ::libc::c_int,
    pub max_phys_ascent: ::libc::c_int,
    pub max_phys_descent: ::libc::c_int,
    pub current_x: ::libc::c_int,
    pub continuation_lines_width: ::libc::c_int,
    pub eol_pos: text_pos,
    pub current_y: ::libc::c_int,
    pub first_vpos: ::libc::c_int,
    pub vpos: ::libc::c_int,
    pub hpos: ::libc::c_int,
    pub lnum: isize,
    pub lnum_bytepos: isize,
    pub lnum_width: ::libc::c_int,
    pub lnum_pixel_width: ::libc::c_int,
    pub pt_lnum: isize,
    pub tab_offset: ::libc::c_int,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 12usize], u32>,
    pub bidi_it: bidi_it,
    pub paragraph_embedding: bidi_dir_t::Type,
}
#[repr(C)]
pub struct it_iterator_stack_entry {
    pub string: Lisp_Object,
    pub string_nchars: ::libc::c_int,
    pub end_charpos: isize,
    pub stop_charpos: isize,
    pub prev_stop: isize,
    pub base_level_stop: isize,
    pub cmp_it: composition_it,
    pub face_id: ::libc::c_int,
    pub u: it_iterator_stack_entry__bindgen_ty_1,
    pub position: text_pos,
    pub current: display_pos,
    pub from_overlay: Lisp_Object,
    pub area: glyph_row_area::Type,
    pub method: it_method::Type,
    pub paragraph_embedding: bidi_dir_t::Type,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub line_wrap: line_wrap_method::Type,
    pub voffset: ::libc::c_short,
    pub space_width: Lisp_Object,
    pub font_height: Lisp_Object,
}
#[repr(C)]
#[repr(align(8))]
pub struct it_iterator_stack_entry__bindgen_ty_1 {
    pub image: __BindgenUnionField<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1>,
    pub stretch: __BindgenUnionField<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_2>,
    pub xwidget: __BindgenUnionField<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_3>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
pub struct it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1 {
    pub object: Lisp_Object,
    pub slice: it_slice,
    pub image_id: isize,
}
#[test]
fn bindgen_test_layout_it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1>())).object
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1>())).slice
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(slice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1>())).image_id
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(image_id)
        )
    );
}
impl Default for it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_2 {
    pub object: Lisp_Object,
}
#[test]
fn bindgen_test_layout_it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_2>())).object
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(object)
        )
    );
}
impl Default for it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_3 {
    pub object: Lisp_Object,
}
#[test]
fn bindgen_test_layout_it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_3>())).object
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(object)
        )
    );
}
impl Default for it_iterator_stack_entry__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_it_iterator_stack_entry__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<it_iterator_stack_entry__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<it_iterator_stack_entry__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry__bindgen_ty_1>())).image as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry__bindgen_ty_1>())).stretch as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1),
            "::",
            stringify!(stretch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry__bindgen_ty_1>())).xwidget as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry__bindgen_ty_1),
            "::",
            stringify!(xwidget)
        )
    );
}
impl Default for it_iterator_stack_entry__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_it_iterator_stack_entry() {
    assert_eq!(
        ::std::mem::size_of::<it_iterator_stack_entry>(),
        296usize,
        concat!("Size of: ", stringify!(it_iterator_stack_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<it_iterator_stack_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(it_iterator_stack_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it_iterator_stack_entry>())).string as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry>())).string_nchars as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(string_nchars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry>())).end_charpos as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(end_charpos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry>())).stop_charpos as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(stop_charpos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry>())).prev_stop as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(prev_stop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry>())).base_level_stop as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(base_level_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it_iterator_stack_entry>())).cmp_it as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(cmp_it)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it_iterator_stack_entry>())).face_id as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(face_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it_iterator_stack_entry>())).u as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry>())).position as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it_iterator_stack_entry>())).current as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry>())).from_overlay as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(from_overlay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it_iterator_stack_entry>())).area as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it_iterator_stack_entry>())).method as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry>())).paragraph_embedding as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(paragraph_embedding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry>())).line_wrap as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(line_wrap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it_iterator_stack_entry>())).voffset as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(voffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry>())).space_width as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(space_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it_iterator_stack_entry>())).font_height as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(it_iterator_stack_entry),
            "::",
            stringify!(font_height)
        )
    );
}
impl Default for it_iterator_stack_entry {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl it_iterator_stack_entry {
    #[inline]
    pub fn multibyte_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_multibyte_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn string_from_display_prop_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_string_from_display_prop_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn string_from_prefix_prop_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_string_from_prefix_prop_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn display_ellipsis_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_display_ellipsis_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avoid_cursor_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_avoid_cursor_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bidi_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bidi_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn from_disp_prop_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_from_disp_prop_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        multibyte_p: bool_bf,
        string_from_display_prop_p: bool_bf,
        string_from_prefix_prop_p: bool_bf,
        display_ellipsis_p: bool_bf,
        avoid_cursor_p: bool_bf,
        bidi_p: bool_bf,
        from_disp_prop_p: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let multibyte_p: u8 = unsafe { ::std::mem::transmute(multibyte_p) };
            multibyte_p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let string_from_display_prop_p: u8 =
                unsafe { ::std::mem::transmute(string_from_display_prop_p) };
            string_from_display_prop_p as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let string_from_prefix_prop_p: u8 =
                unsafe { ::std::mem::transmute(string_from_prefix_prop_p) };
            string_from_prefix_prop_p as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let display_ellipsis_p: u8 = unsafe { ::std::mem::transmute(display_ellipsis_p) };
            display_ellipsis_p as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let avoid_cursor_p: u8 = unsafe { ::std::mem::transmute(avoid_cursor_p) };
            avoid_cursor_p as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bidi_p: u8 = unsafe { ::std::mem::transmute(bidi_p) };
            bidi_p as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let from_disp_prop_p: u8 = unsafe { ::std::mem::transmute(from_disp_prop_p) };
            from_disp_prop_p as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_it() {
    assert_eq!(
        ::std::mem::size_of::<it>(),
        4880usize,
        concat!("Size of: ", stringify!(it))
    );
    assert_eq!(
        ::std::mem::align_of::<it>(),
        8usize,
        concat!("Alignment of ", stringify!(it))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).window as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).w as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).f as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).method as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).stop_charpos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(stop_charpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).prev_stop as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(prev_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).base_level_stop as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(base_level_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).end_charpos as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(end_charpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).s as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).string_nchars as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(string_nchars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<it>())).redisplay_end_trigger_charpos as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(redisplay_end_trigger_charpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).dp as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(dp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).dpvec as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(dpvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).dpend as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(dpend))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).dpvec_char_len as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(dpvec_char_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).dpvec_face_id as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(dpvec_face_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).saved_face_id as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(saved_face_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).ctl_chars as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(ctl_chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).start as *const _ as usize },
        264usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(start))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).current as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).n_overlay_strings as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(n_overlay_strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).overlay_strings_charpos as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(overlay_strings_charpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).overlay_strings as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(overlay_strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).string_overlays as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(string_overlays)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).string as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).from_overlay as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(from_overlay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).stack as *const _ as usize },
        648usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(stack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).sp as *const _ as usize },
        2128usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(sp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).selective as *const _ as usize },
        2136usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(selective)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).what as *const _ as usize },
        2144usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(what))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).face_id as *const _ as usize },
        2148usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(face_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).line_wrap as *const _ as usize },
        2156usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(line_wrap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).base_face_id as *const _ as usize },
        2160usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(base_face_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).c as *const _ as usize },
        2164usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(c))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).len as *const _ as usize },
        2168usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).cmp_it as *const _ as usize },
        2176usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(cmp_it)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).char_to_display as *const _ as usize },
        2256usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(char_to_display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).glyphless_method as *const _ as usize },
        2260usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(glyphless_method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).image_id as *const _ as usize },
        2264usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(image_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).xwidget as *const _ as usize },
        2272usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(xwidget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).slice as *const _ as usize },
        2280usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(slice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).space_width as *const _ as usize },
        2312usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(space_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).voffset as *const _ as usize },
        2320usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(voffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).tab_width as *const _ as usize },
        2322usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(tab_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).font_height as *const _ as usize },
        2328usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(font_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).object as *const _ as usize },
        2336usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).position as *const _ as usize },
        2344usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).truncation_pixel_width as *const _ as usize },
        2360usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(truncation_pixel_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).continuation_pixel_width as *const _ as usize },
        2362usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(continuation_pixel_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).first_visible_x as *const _ as usize },
        2364usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(first_visible_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).last_visible_x as *const _ as usize },
        2368usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(last_visible_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).last_visible_y as *const _ as usize },
        2372usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(last_visible_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).extra_line_spacing as *const _ as usize },
        2376usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(extra_line_spacing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).max_extra_line_spacing as *const _ as usize },
        2380usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(max_extra_line_spacing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).override_ascent as *const _ as usize },
        2384usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(override_ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).override_descent as *const _ as usize },
        2388usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(override_descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).override_boff as *const _ as usize },
        2392usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(override_boff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).glyph_row as *const _ as usize },
        2400usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(glyph_row)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).area as *const _ as usize },
        2408usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(area))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).nglyphs as *const _ as usize },
        2412usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(nglyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).pixel_width as *const _ as usize },
        2416usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(pixel_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).ascent as *const _ as usize },
        2420usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).descent as *const _ as usize },
        2424usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).max_ascent as *const _ as usize },
        2428usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(max_ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).max_descent as *const _ as usize },
        2432usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(max_descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).phys_ascent as *const _ as usize },
        2436usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(phys_ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).phys_descent as *const _ as usize },
        2440usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(phys_descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).max_phys_ascent as *const _ as usize },
        2444usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(max_phys_ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).max_phys_descent as *const _ as usize },
        2448usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(max_phys_descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).current_x as *const _ as usize },
        2452usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(current_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).continuation_lines_width as *const _ as usize },
        2456usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(continuation_lines_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).eol_pos as *const _ as usize },
        2464usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(eol_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).current_y as *const _ as usize },
        2480usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(current_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).first_vpos as *const _ as usize },
        2484usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(first_vpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).vpos as *const _ as usize },
        2488usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(vpos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).hpos as *const _ as usize },
        2492usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(hpos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).lnum as *const _ as usize },
        2496usize,
        concat!("Offset of field: ", stringify!(it), "::", stringify!(lnum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).lnum_bytepos as *const _ as usize },
        2504usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(lnum_bytepos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).lnum_width as *const _ as usize },
        2512usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(lnum_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).lnum_pixel_width as *const _ as usize },
        2516usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(lnum_pixel_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).pt_lnum as *const _ as usize },
        2520usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(pt_lnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).tab_offset as *const _ as usize },
        2528usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(tab_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).bidi_it as *const _ as usize },
        2544usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(bidi_it)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<it>())).paragraph_embedding as *const _ as usize },
        4872usize,
        concat!(
            "Offset of field: ",
            stringify!(it),
            "::",
            stringify!(paragraph_embedding)
        )
    );
}
impl Default for it {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl it {
    #[inline]
    pub fn multibyte_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_multibyte_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tab_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tab_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn header_line_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_header_line_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn string_from_display_prop_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_string_from_display_prop_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn string_from_prefix_prop_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_string_from_prefix_prop_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn from_disp_prop_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_from_disp_prop_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ellipsis_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ellipsis_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avoid_cursor_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_avoid_cursor_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        multibyte_p: bool_bf,
        tab_line_p: bool_bf,
        header_line_p: bool_bf,
        string_from_display_prop_p: bool_bf,
        string_from_prefix_prop_p: bool_bf,
        from_disp_prop_p: bool_bf,
        ellipsis_p: bool_bf,
        avoid_cursor_p: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let multibyte_p: u8 = unsafe { ::std::mem::transmute(multibyte_p) };
            multibyte_p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tab_line_p: u8 = unsafe { ::std::mem::transmute(tab_line_p) };
            tab_line_p as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let header_line_p: u8 = unsafe { ::std::mem::transmute(header_line_p) };
            header_line_p as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let string_from_display_prop_p: u8 =
                unsafe { ::std::mem::transmute(string_from_display_prop_p) };
            string_from_display_prop_p as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let string_from_prefix_prop_p: u8 =
                unsafe { ::std::mem::transmute(string_from_prefix_prop_p) };
            string_from_prefix_prop_p as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let from_disp_prop_p: u8 = unsafe { ::std::mem::transmute(from_disp_prop_p) };
            from_disp_prop_p as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ellipsis_p: u8 = unsafe { ::std::mem::transmute(ellipsis_p) };
            ellipsis_p as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let avoid_cursor_p: u8 = unsafe { ::std::mem::transmute(avoid_cursor_p) };
            avoid_cursor_p as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn selective_display_ellipsis_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_selective_display_ellipsis_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ctl_arrow_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ctl_arrow_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn face_box_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_face_box_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start_of_box_run_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_start_of_box_run_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn end_of_box_run_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_end_of_box_run_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overlay_strings_at_end_processed_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_overlay_strings_at_end_processed_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_overlay_strings_at_pos_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_overlay_strings_at_pos_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glyph_not_available_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_glyph_not_available_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn starts_in_middle_of_char_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_starts_in_middle_of_char_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn face_before_selective_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_face_before_selective_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn constrain_row_ascent_descent_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_constrain_row_ascent_descent_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn line_number_produced_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_line_number_produced_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        selective_display_ellipsis_p: bool_bf,
        ctl_arrow_p: bool_bf,
        face_box_p: bool_bf,
        start_of_box_run_p: bool_bf,
        end_of_box_run_p: bool_bf,
        overlay_strings_at_end_processed_p: bool_bf,
        ignore_overlay_strings_at_pos_p: bool_bf,
        glyph_not_available_p: bool_bf,
        starts_in_middle_of_char_p: bool_bf,
        face_before_selective_p: bool_bf,
        constrain_row_ascent_descent_p: bool_bf,
        line_number_produced_p: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let selective_display_ellipsis_p: u8 =
                unsafe { ::std::mem::transmute(selective_display_ellipsis_p) };
            selective_display_ellipsis_p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ctl_arrow_p: u8 = unsafe { ::std::mem::transmute(ctl_arrow_p) };
            ctl_arrow_p as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let face_box_p: u8 = unsafe { ::std::mem::transmute(face_box_p) };
            face_box_p as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let start_of_box_run_p: u8 = unsafe { ::std::mem::transmute(start_of_box_run_p) };
            start_of_box_run_p as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let end_of_box_run_p: u8 = unsafe { ::std::mem::transmute(end_of_box_run_p) };
            end_of_box_run_p as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let overlay_strings_at_end_processed_p: u8 =
                unsafe { ::std::mem::transmute(overlay_strings_at_end_processed_p) };
            overlay_strings_at_end_processed_p as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ignore_overlay_strings_at_pos_p: u8 =
                unsafe { ::std::mem::transmute(ignore_overlay_strings_at_pos_p) };
            ignore_overlay_strings_at_pos_p as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let glyph_not_available_p: u8 = unsafe { ::std::mem::transmute(glyph_not_available_p) };
            glyph_not_available_p as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let starts_in_middle_of_char_p: u8 =
                unsafe { ::std::mem::transmute(starts_in_middle_of_char_p) };
            starts_in_middle_of_char_p as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let face_before_selective_p: u8 =
                unsafe { ::std::mem::transmute(face_before_selective_p) };
            face_before_selective_p as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let constrain_row_ascent_descent_p: u8 =
                unsafe { ::std::mem::transmute(constrain_row_ascent_descent_p) };
            constrain_row_ascent_descent_p as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let line_number_produced_p: u8 =
                unsafe { ::std::mem::transmute(line_number_produced_p) };
            line_number_produced_p as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn left_user_fringe_bitmap(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_left_user_fringe_bitmap(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn right_user_fringe_bitmap(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_right_user_fringe_bitmap(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn left_user_fringe_face_id(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_left_user_fringe_face_id(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn right_user_fringe_face_id(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(64usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_right_user_fringe_face_id(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_3.set(64usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn bidi_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(84usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bidi_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(84usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        left_user_fringe_bitmap: ::libc::c_uint,
        right_user_fringe_bitmap: ::libc::c_uint,
        left_user_fringe_face_id: ::libc::c_uint,
        right_user_fringe_face_id: ::libc::c_uint,
        bidi_p: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 12usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let left_user_fringe_bitmap: u32 =
                unsafe { ::std::mem::transmute(left_user_fringe_bitmap) };
            left_user_fringe_bitmap as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let right_user_fringe_bitmap: u32 =
                unsafe { ::std::mem::transmute(right_user_fringe_bitmap) };
            right_user_fringe_bitmap as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let left_user_fringe_face_id: u32 =
                unsafe { ::std::mem::transmute(left_user_fringe_face_id) };
            left_user_fringe_face_id as u64
        });
        __bindgen_bitfield_unit.set(64usize, 20u8, {
            let right_user_fringe_face_id: u32 =
                unsafe { ::std::mem::transmute(right_user_fringe_face_id) };
            right_user_fringe_face_id as u64
        });
        __bindgen_bitfield_unit.set(84usize, 1u8, {
            let bidi_p: u8 = unsafe { ::std::mem::transmute(bidi_p) };
            bidi_p as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod move_operation_enum {
    pub type Type = u32;
    pub const MOVE_TO_X: Type = 1;
    pub const MOVE_TO_Y: Type = 2;
    pub const MOVE_TO_VPOS: Type = 4;
    pub const MOVE_TO_POS: Type = 8;
}
#[doc = "Mouse Highlight"]
#[repr(C)]
pub struct Mouse_HLInfo {
    pub mouse_face_beg_row: ::libc::c_int,
    pub mouse_face_beg_col: ::libc::c_int,
    pub mouse_face_beg_x: ::libc::c_int,
    pub mouse_face_end_row: ::libc::c_int,
    pub mouse_face_end_col: ::libc::c_int,
    pub mouse_face_end_x: ::libc::c_int,
    pub mouse_face_window: Lisp_Object,
    pub mouse_face_face_id: ::libc::c_int,
    pub mouse_face_overlay: Lisp_Object,
    pub mouse_face_mouse_frame: *mut frame,
    pub mouse_face_mouse_x: ::libc::c_int,
    pub mouse_face_mouse_y: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_Mouse_HLInfo() {
    assert_eq!(
        ::std::mem::size_of::<Mouse_HLInfo>(),
        72usize,
        concat!("Size of: ", stringify!(Mouse_HLInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<Mouse_HLInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(Mouse_HLInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mouse_HLInfo>())).mouse_face_beg_row as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Mouse_HLInfo),
            "::",
            stringify!(mouse_face_beg_row)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mouse_HLInfo>())).mouse_face_beg_col as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Mouse_HLInfo),
            "::",
            stringify!(mouse_face_beg_col)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mouse_HLInfo>())).mouse_face_beg_x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Mouse_HLInfo),
            "::",
            stringify!(mouse_face_beg_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mouse_HLInfo>())).mouse_face_end_row as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Mouse_HLInfo),
            "::",
            stringify!(mouse_face_end_row)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mouse_HLInfo>())).mouse_face_end_col as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Mouse_HLInfo),
            "::",
            stringify!(mouse_face_end_col)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mouse_HLInfo>())).mouse_face_end_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Mouse_HLInfo),
            "::",
            stringify!(mouse_face_end_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mouse_HLInfo>())).mouse_face_window as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Mouse_HLInfo),
            "::",
            stringify!(mouse_face_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mouse_HLInfo>())).mouse_face_face_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Mouse_HLInfo),
            "::",
            stringify!(mouse_face_face_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mouse_HLInfo>())).mouse_face_overlay as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Mouse_HLInfo),
            "::",
            stringify!(mouse_face_overlay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Mouse_HLInfo>())).mouse_face_mouse_frame as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Mouse_HLInfo),
            "::",
            stringify!(mouse_face_mouse_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mouse_HLInfo>())).mouse_face_mouse_x as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Mouse_HLInfo),
            "::",
            stringify!(mouse_face_mouse_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mouse_HLInfo>())).mouse_face_mouse_y as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Mouse_HLInfo),
            "::",
            stringify!(mouse_face_mouse_y)
        )
    );
}
impl Default for Mouse_HLInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl Mouse_HLInfo {
    #[inline]
    pub fn mouse_face_past_end(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mouse_face_past_end(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mouse_face_defer(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mouse_face_defer(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mouse_face_hidden(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mouse_face_hidden(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mouse_face_past_end: bool_bf,
        mouse_face_defer: bool_bf,
        mouse_face_hidden: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mouse_face_past_end: u8 = unsafe { ::std::mem::transmute(mouse_face_past_end) };
            mouse_face_past_end as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mouse_face_defer: u8 = unsafe { ::std::mem::transmute(mouse_face_defer) };
            mouse_face_defer as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mouse_face_hidden: u8 = unsafe { ::std::mem::transmute(mouse_face_hidden) };
            mouse_face_hidden as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn reset_mouse_highlight(hlinfo: *mut Mouse_HLInfo);
}
#[doc = "Window-based redisplay interface"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct run {
    pub desired_y: ::libc::c_int,
    pub current_y: ::libc::c_int,
    pub desired_vpos: ::libc::c_int,
    pub current_vpos: ::libc::c_int,
    pub height: ::libc::c_int,
    pub nrows: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_run() {
    assert_eq!(
        ::std::mem::size_of::<run>(),
        24usize,
        concat!("Size of: ", stringify!(run))
    );
    assert_eq!(
        ::std::mem::align_of::<run>(),
        4usize,
        concat!("Alignment of ", stringify!(run))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<run>())).desired_y as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(run),
            "::",
            stringify!(desired_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<run>())).current_y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(run),
            "::",
            stringify!(current_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<run>())).desired_vpos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(run),
            "::",
            stringify!(desired_vpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<run>())).current_vpos as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(run),
            "::",
            stringify!(current_vpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<run>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(run),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<run>())).nrows as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(run),
            "::",
            stringify!(nrows)
        )
    );
}
pub type frame_parm_handler = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct redisplay_interface {
    pub frame_parm_handlers: *mut frame_parm_handler,
    pub produce_glyphs: ::std::option::Option<unsafe extern "C" fn(it: *mut it)>,
    pub write_glyphs: ::std::option::Option<
        unsafe extern "C" fn(
            w: *mut window,
            row: *mut glyph_row,
            string: *mut glyph,
            area: glyph_row_area::Type,
            len: ::libc::c_int,
        ),
    >,
    pub insert_glyphs: ::std::option::Option<
        unsafe extern "C" fn(
            w: *mut window,
            row: *mut glyph_row,
            start: *mut glyph,
            area: glyph_row_area::Type,
            len: ::libc::c_int,
        ),
    >,
    pub clear_end_of_line: ::std::option::Option<
        unsafe extern "C" fn(
            w: *mut window,
            row: *mut glyph_row,
            area: glyph_row_area::Type,
            x: ::libc::c_int,
        ),
    >,
    pub scroll_run_hook: ::std::option::Option<unsafe extern "C" fn(w: *mut window, run: *mut run)>,
    pub after_update_window_line_hook:
        ::std::option::Option<unsafe extern "C" fn(w: *mut window, desired_row: *mut glyph_row)>,
    pub update_window_begin_hook: ::std::option::Option<unsafe extern "C" fn(w: *mut window)>,
    pub update_window_end_hook: ::std::option::Option<
        unsafe extern "C" fn(w: *mut window, cursor_on_p: bool, mouse_face_overwritten_p: bool),
    >,
    pub flush_display: ::std::option::Option<unsafe extern "C" fn(f: *mut frame)>,
    pub clear_window_mouse_face: ::std::option::Option<unsafe extern "C" fn(w: *mut window)>,
    pub get_glyph_overhangs: ::std::option::Option<
        unsafe extern "C" fn(
            glyph: *mut glyph,
            f: *mut frame,
            left: *mut ::libc::c_int,
            right: *mut ::libc::c_int,
        ),
    >,
    pub fix_overlapping_area: ::std::option::Option<
        unsafe extern "C" fn(
            w: *mut window,
            row: *mut glyph_row,
            area: glyph_row_area::Type,
            arg1: ::libc::c_int,
        ),
    >,
    pub draw_fringe_bitmap: ::std::option::Option<
        unsafe extern "C" fn(
            w: *mut window,
            row: *mut glyph_row,
            p: *mut draw_fringe_bitmap_params,
        ),
    >,
    pub define_fringe_bitmap: ::std::option::Option<
        unsafe extern "C" fn(
            which: ::libc::c_int,
            bits: *mut ::libc::c_ushort,
            h: ::libc::c_int,
            wd: ::libc::c_int,
        ),
    >,
    pub destroy_fringe_bitmap: ::std::option::Option<unsafe extern "C" fn(which: ::libc::c_int)>,
    pub compute_glyph_string_overhangs:
        ::std::option::Option<unsafe extern "C" fn(s: *mut glyph_string)>,
    pub draw_glyph_string: ::std::option::Option<unsafe extern "C" fn(s: *mut glyph_string)>,
    pub define_frame_cursor:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, cursor: Emacs_Cursor)>,
    pub clear_frame_area: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut frame,
            x: ::libc::c_int,
            y: ::libc::c_int,
            width: ::libc::c_int,
            height: ::libc::c_int,
        ),
    >,
    pub clear_under_internal_border: ::std::option::Option<unsafe extern "C" fn(f: *mut frame)>,
    pub draw_window_cursor: ::std::option::Option<
        unsafe extern "C" fn(
            w: *mut window,
            glyph_row: *mut glyph_row,
            x: ::libc::c_int,
            y: ::libc::c_int,
            cursor_type: text_cursor_kinds::Type,
            cursor_width: ::libc::c_int,
            on_p: bool,
            active_p: bool,
        ),
    >,
    pub draw_vertical_window_border: ::std::option::Option<
        unsafe extern "C" fn(
            w: *mut window,
            x: ::libc::c_int,
            y_0: ::libc::c_int,
            y_1: ::libc::c_int,
        ),
    >,
    pub draw_window_divider: ::std::option::Option<
        unsafe extern "C" fn(
            w: *mut window,
            x_0: ::libc::c_int,
            x_1: ::libc::c_int,
            y_0: ::libc::c_int,
            y_1: ::libc::c_int,
        ),
    >,
    pub shift_glyphs_for_insert: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut frame,
            x: ::libc::c_int,
            y: ::libc::c_int,
            width: ::libc::c_int,
            height: ::libc::c_int,
            shift_by: ::libc::c_int,
        ),
    >,
    pub show_hourglass: ::std::option::Option<unsafe extern "C" fn(f: *mut frame)>,
    pub hide_hourglass: ::std::option::Option<unsafe extern "C" fn(f: *mut frame)>,
    pub default_font_parameter:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, parms: Lisp_Object)>,
}
#[test]
fn bindgen_test_layout_redisplay_interface() {
    assert_eq!(
        ::std::mem::size_of::<redisplay_interface>(),
        224usize,
        concat!("Size of: ", stringify!(redisplay_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<redisplay_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(redisplay_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).frame_parm_handlers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(frame_parm_handlers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).produce_glyphs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(produce_glyphs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).write_glyphs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(write_glyphs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).insert_glyphs as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(insert_glyphs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).clear_end_of_line as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(clear_end_of_line)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).scroll_run_hook as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(scroll_run_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).after_update_window_line_hook
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(after_update_window_line_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).update_window_begin_hook as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(update_window_begin_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).update_window_end_hook as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(update_window_end_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).flush_display as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(flush_display)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).clear_window_mouse_face as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(clear_window_mouse_face)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).get_glyph_overhangs as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(get_glyph_overhangs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).fix_overlapping_area as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(fix_overlapping_area)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).draw_fringe_bitmap as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(draw_fringe_bitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).define_fringe_bitmap as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(define_fringe_bitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).destroy_fringe_bitmap as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(destroy_fringe_bitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).compute_glyph_string_overhangs
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(compute_glyph_string_overhangs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).draw_glyph_string as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(draw_glyph_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).define_frame_cursor as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(define_frame_cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).clear_frame_area as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(clear_frame_area)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).clear_under_internal_border as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(clear_under_internal_border)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).draw_window_cursor as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(draw_window_cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).draw_vertical_window_border as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(draw_vertical_window_border)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).draw_window_divider as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(draw_window_divider)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).shift_glyphs_for_insert as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(shift_glyphs_for_insert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).show_hourglass as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(show_hourglass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).hide_hourglass as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(hide_hourglass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<redisplay_interface>())).default_font_parameter as *const _
                as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(redisplay_interface),
            "::",
            stringify!(default_font_parameter)
        )
    );
}
impl Default for redisplay_interface {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct image {
    pub timestamp: timespec,
    pub pixmap: Emacs_Pixmap,
    pub mask: Emacs_Pixmap,
    pub colors: *mut ::libc::c_ulong,
    pub ncolors: ::libc::c_int,
    pub background: ::libc::c_ulong,
    pub face_foreground: ::libc::c_ulong,
    pub face_background: ::libc::c_ulong,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub width: ::libc::c_int,
    pub height: ::libc::c_int,
    pub corners: [::libc::c_int; 4usize],
    pub ascent: ::libc::c_int,
    pub spec: Lisp_Object,
    pub dependencies: Lisp_Object,
    pub relief: ::libc::c_int,
    pub hmargin: ::libc::c_int,
    pub vmargin: ::libc::c_int,
    pub type_: *mut image_type,
    pub load_failed_p: bool,
    pub lisp_data: Lisp_Object,
    pub hash: EMACS_UINT,
    pub id: isize,
    pub next: *mut image,
    pub prev: *mut image,
}
#[test]
fn bindgen_test_layout_image() {
    assert_eq!(
        ::std::mem::size_of::<image>(),
        192usize,
        concat!("Size of: ", stringify!(image))
    );
    assert_eq!(
        ::std::mem::align_of::<image>(),
        8usize,
        concat!("Alignment of ", stringify!(image))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).timestamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).pixmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(pixmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).colors as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).ncolors as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).background as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).face_foreground as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(face_foreground)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).face_background as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(face_background)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).width as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).height as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).corners as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(corners)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).ascent as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).spec as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).dependencies as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(dependencies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).relief as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(relief)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).hmargin as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(hmargin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).vmargin as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(vmargin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).type_ as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).load_failed_p as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(load_failed_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).lisp_data as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(lisp_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).hash as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).id as *const _ as usize },
        168usize,
        concat!("Offset of field: ", stringify!(image), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).next as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image>())).prev as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(image),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for image {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl image {
    #[inline]
    pub fn background_transparent(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_background_transparent(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn background_valid(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_background_valid(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn background_transparent_valid(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_background_transparent_valid(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        background_transparent: bool_bf,
        background_valid: bool_bf,
        background_transparent_valid: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let background_transparent: u8 =
                unsafe { ::std::mem::transmute(background_transparent) };
            background_transparent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let background_valid: u8 = unsafe { ::std::mem::transmute(background_valid) };
            background_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let background_transparent_valid: u8 =
                unsafe { ::std::mem::transmute(background_transparent_valid) };
            background_transparent_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_cache {
    pub buckets: *mut *mut image,
    pub images: *mut *mut image,
    pub size: isize,
    pub used: isize,
    pub refcount: isize,
}
#[test]
fn bindgen_test_layout_image_cache() {
    assert_eq!(
        ::std::mem::size_of::<image_cache>(),
        40usize,
        concat!("Size of: ", stringify!(image_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<image_cache>(),
        8usize,
        concat!("Alignment of ", stringify!(image_cache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_cache>())).buckets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(image_cache),
            "::",
            stringify!(buckets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_cache>())).images as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(image_cache),
            "::",
            stringify!(images)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_cache>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(image_cache),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_cache>())).used as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(image_cache),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<image_cache>())).refcount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(image_cache),
            "::",
            stringify!(refcount)
        )
    );
}
impl Default for image_cache {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod tab_bar_item_idx {
    #[doc = "Tab-bars"]
    pub type Type = u32;
    pub const TAB_BAR_ITEM_KEY: Type = 0;
    pub const TAB_BAR_ITEM_ENABLED_P: Type = 1;
    pub const TAB_BAR_ITEM_SELECTED_P: Type = 2;
    pub const TAB_BAR_ITEM_CAPTION: Type = 3;
    pub const TAB_BAR_ITEM_BINDING: Type = 4;
    pub const TAB_BAR_ITEM_HELP: Type = 5;
    pub const TAB_BAR_ITEM_NSLOTS: Type = 6;
}
pub mod tool_bar_item_idx {
    #[doc = "Tool-bars"]
    pub type Type = u32;
    pub const TOOL_BAR_ITEM_KEY: Type = 0;
    pub const TOOL_BAR_ITEM_ENABLED_P: Type = 1;
    pub const TOOL_BAR_ITEM_SELECTED_P: Type = 2;
    pub const TOOL_BAR_ITEM_CAPTION: Type = 3;
    pub const TOOL_BAR_ITEM_IMAGES: Type = 4;
    pub const TOOL_BAR_ITEM_BINDING: Type = 5;
    pub const TOOL_BAR_ITEM_TYPE: Type = 6;
    pub const TOOL_BAR_ITEM_HELP: Type = 7;
    pub const TOOL_BAR_ITEM_RTL_IMAGE: Type = 8;
    pub const TOOL_BAR_ITEM_LABEL: Type = 9;
    pub const TOOL_BAR_ITEM_VERT_ONLY: Type = 10;
    pub const TOOL_BAR_ITEM_NSLOTS: Type = 11;
}
pub mod tool_bar_item_image {
    pub type Type = u32;
    pub const TOOL_BAR_IMAGE_ENABLED_SELECTED: Type = 0;
    pub const TOOL_BAR_IMAGE_ENABLED_DESELECTED: Type = 1;
    pub const TOOL_BAR_IMAGE_DISABLED_SELECTED: Type = 2;
    pub const TOOL_BAR_IMAGE_DISABLED_DESELECTED: Type = 3;
}
extern "C" {
    #[doc = "Function Prototypes"]
    pub fn bidi_init_it(arg1: isize, arg2: isize, arg3: bool, arg4: *mut bidi_it);
}
extern "C" {
    pub fn bidi_move_to_visually_next(arg1: *mut bidi_it);
}
extern "C" {
    pub fn bidi_paragraph_init(arg1: bidi_dir_t::Type, arg2: *mut bidi_it, arg3: bool);
}
extern "C" {
    pub fn bidi_mirror_char(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn bidi_push_it(arg1: *mut bidi_it);
}
extern "C" {
    pub fn bidi_pop_it(arg1: *mut bidi_it);
}
extern "C" {
    pub fn bidi_shelve_cache() -> *mut ::libc::c_void;
}
extern "C" {
    pub fn bidi_unshelve_cache(arg1: *mut ::libc::c_void, arg2: bool);
}
extern "C" {
    pub fn bidi_find_first_overridden(arg1: *mut bidi_it) -> isize;
}
extern "C" {
    pub fn row_containing_pos(
        arg1: *mut window,
        arg2: isize,
        arg3: *mut glyph_row,
        arg4: *mut glyph_row,
        arg5: ::libc::c_int,
    ) -> *mut glyph_row;
}
extern "C" {
    pub fn line_bottom_y(arg1: *mut it) -> ::libc::c_int;
}
extern "C" {
    pub fn default_line_pixel_height(arg1: *mut window) -> ::libc::c_int;
}
extern "C" {
    pub fn display_prop_intangible_p(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: isize,
        arg4: isize,
    ) -> bool;
}
extern "C" {
    pub fn resize_echo_area_exactly();
}
extern "C" {
    pub fn resize_mini_window(arg1: *mut window, arg2: bool) -> bool;
}
extern "C" {
    pub fn set_vertical_scroll_bar(arg1: *mut window);
}
extern "C" {
    pub fn set_horizontal_scroll_bar(arg1: *mut window);
}
extern "C" {
    pub fn try_window(arg1: Lisp_Object, arg2: text_pos, arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn window_box(
        arg1: *mut window,
        arg2: glyph_row_area::Type,
        arg3: *mut ::libc::c_int,
        arg4: *mut ::libc::c_int,
        arg5: *mut ::libc::c_int,
        arg6: *mut ::libc::c_int,
    );
}
extern "C" {
    pub fn window_box_height(arg1: *mut window) -> ::libc::c_int;
}
extern "C" {
    pub fn window_text_bottom_y(arg1: *mut window) -> ::libc::c_int;
}
extern "C" {
    pub fn window_box_width(arg1: *mut window, arg2: glyph_row_area::Type) -> ::libc::c_int;
}
extern "C" {
    pub fn window_box_left(arg1: *mut window, arg2: glyph_row_area::Type) -> ::libc::c_int;
}
extern "C" {
    pub fn window_box_left_offset(arg1: *mut window, arg2: glyph_row_area::Type) -> ::libc::c_int;
}
extern "C" {
    pub fn window_box_right(arg1: *mut window, arg2: glyph_row_area::Type) -> ::libc::c_int;
}
extern "C" {
    pub fn estimate_mode_line_height(arg1: *mut frame, arg2: face_id) -> ::libc::c_int;
}
extern "C" {
    pub fn move_it_to(
        arg1: *mut it,
        arg2: isize,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
        arg5: ::libc::c_int,
        arg6: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pixel_to_glyph_coords(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: *mut ::libc::c_int,
        arg5: *mut ::libc::c_int,
        arg6: *mut Emacs_Rectangle,
        arg7: bool,
    );
}
extern "C" {
    pub fn remember_mouse_glyph(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: *mut Emacs_Rectangle,
    );
}
extern "C" {
    pub fn mark_window_display_accurate(arg1: Lisp_Object, arg2: bool);
}
extern "C" {
    pub fn redisplay_preserve_echo_area(arg1: ::libc::c_int);
}
extern "C" {
    pub fn init_iterator(
        arg1: *mut it,
        arg2: *mut window,
        arg3: isize,
        arg4: isize,
        arg5: *mut glyph_row,
        arg6: face_id,
    );
}
extern "C" {
    pub fn init_iterator_to_row_start(arg1: *mut it, arg2: *mut window, arg3: *mut glyph_row);
}
extern "C" {
    pub fn start_display(arg1: *mut it, arg2: *mut window, arg3: text_pos);
}
extern "C" {
    pub fn move_it_vertically(arg1: *mut it, arg2: ::libc::c_int);
}
extern "C" {
    pub fn move_it_vertically_backward(arg1: *mut it, arg2: ::libc::c_int);
}
extern "C" {
    pub fn move_it_by_lines(arg1: *mut it, arg2: isize);
}
extern "C" {
    pub fn move_it_past_eol(arg1: *mut it);
}
extern "C" {
    pub fn move_it_in_display_line(
        it: *mut it,
        to_charpos: isize,
        to_x: ::libc::c_int,
        op: move_operation_enum::Type,
    );
}
extern "C" {
    pub fn partial_line_height(it_origin: *mut it) -> ::libc::c_int;
}
extern "C" {
    pub fn in_display_vector_p(arg1: *mut it) -> bool;
}
extern "C" {
    pub fn frame_mode_line_height(arg1: *mut frame) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}redisplaying_p"]
    pub static mut redisplaying_p: bool;
}
extern "C" {
    #[link_name = "\u{1}help_echo_showing_p"]
    pub static mut help_echo_showing_p: bool;
}
extern "C" {
    #[link_name = "\u{1}help_echo_string"]
    pub static mut help_echo_string: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}help_echo_window"]
    pub static mut help_echo_window: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}help_echo_object"]
    pub static mut help_echo_object: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}previous_help_echo_string"]
    pub static mut previous_help_echo_string: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}help_echo_pos"]
    pub static mut help_echo_pos: isize;
}
extern "C" {
    #[link_name = "\u{1}last_tab_bar_item"]
    pub static mut last_tab_bar_item: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}last_tool_bar_item"]
    pub static mut last_tool_bar_item: ::libc::c_int;
}
extern "C" {
    pub fn reseat_at_previous_visible_line_start(arg1: *mut it);
}
extern "C" {
    pub fn lookup_glyphless_char_display(arg1: ::libc::c_int, arg2: *mut it) -> Lisp_Object;
}
extern "C" {
    pub fn compute_display_string_pos(
        arg1: *mut text_pos,
        arg2: *mut bidi_string_data,
        arg3: *mut window,
        arg4: bool,
        arg5: *mut ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn compute_display_string_end(arg1: isize, arg2: *mut bidi_string_data) -> isize;
}
extern "C" {
    pub fn produce_stretch_glyph(arg1: *mut it);
}
extern "C" {
    pub fn merge_glyphless_glyph_face(arg1: *mut it) -> ::libc::c_int;
}
extern "C" {
    pub fn forget_escape_and_glyphless_faces();
}
extern "C" {
    pub fn get_font_ascent_descent(
        arg1: *mut font,
        arg2: *mut ::libc::c_int,
        arg3: *mut ::libc::c_int,
    );
}
extern "C" {
    pub fn gui_get_glyph_overhangs(
        arg1: *mut glyph,
        arg2: *mut frame,
        arg3: *mut ::libc::c_int,
        arg4: *mut ::libc::c_int,
    );
}
extern "C" {
    pub fn font_for_underline_metrics(arg1: *mut glyph_string) -> *mut font;
}
extern "C" {
    pub fn gui_produce_glyphs(arg1: *mut it);
}
extern "C" {
    pub fn gui_write_glyphs(
        arg1: *mut window,
        arg2: *mut glyph_row,
        arg3: *mut glyph,
        arg4: glyph_row_area::Type,
        arg5: ::libc::c_int,
    );
}
extern "C" {
    pub fn gui_insert_glyphs(
        arg1: *mut window,
        arg2: *mut glyph_row,
        arg3: *mut glyph,
        arg4: glyph_row_area::Type,
        arg5: ::libc::c_int,
    );
}
extern "C" {
    pub fn gui_clear_end_of_line(
        arg1: *mut window,
        arg2: *mut glyph_row,
        arg3: glyph_row_area::Type,
        arg4: ::libc::c_int,
    );
}
extern "C" {
    pub fn gui_fix_overlapping_area(
        arg1: *mut window,
        arg2: *mut glyph_row,
        arg3: glyph_row_area::Type,
        arg4: ::libc::c_int,
    );
}
extern "C" {
    pub fn draw_phys_cursor_glyph(
        arg1: *mut window,
        arg2: *mut glyph_row,
        arg3: draw_glyphs_face::Type,
    );
}
extern "C" {
    pub fn get_phys_cursor_geometry(
        arg1: *mut window,
        arg2: *mut glyph_row,
        arg3: *mut glyph,
        arg4: *mut ::libc::c_int,
        arg5: *mut ::libc::c_int,
        arg6: *mut ::libc::c_int,
    );
}
extern "C" {
    pub fn erase_phys_cursor(arg1: *mut window);
}
extern "C" {
    pub fn display_and_set_cursor(
        arg1: *mut window,
        arg2: bool,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
        arg5: ::libc::c_int,
        arg6: ::libc::c_int,
    );
}
extern "C" {
    pub fn gui_update_cursor(arg1: *mut frame, arg2: bool);
}
extern "C" {
    pub fn gui_clear_cursor(arg1: *mut window);
}
extern "C" {
    pub fn gui_draw_vertical_border(w: *mut window);
}
extern "C" {
    pub fn gui_draw_right_divider(w: *mut window);
}
extern "C" {
    pub fn get_glyph_string_clip_rects(
        arg1: *mut glyph_string,
        arg2: *mut Emacs_Rectangle,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn get_glyph_string_clip_rect(arg1: *mut glyph_string, nr: *mut Emacs_Rectangle);
}
extern "C" {
    pub fn find_hot_spot(
        arg1: Lisp_Object,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn handle_tab_bar_click(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: bool,
        arg5: ::libc::c_int,
    );
}
extern "C" {
    pub fn handle_tool_bar_click(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: bool,
        arg5: ::libc::c_int,
    );
}
extern "C" {
    pub fn expose_frame(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
        arg5: ::libc::c_int,
    );
}
extern "C" {
    pub fn gui_intersect_rectangles(
        arg1: *const Emacs_Rectangle,
        arg2: *const Emacs_Rectangle,
        arg3: *mut Emacs_Rectangle,
    ) -> bool;
}
extern "C" {
    pub fn note_mouse_highlight(arg1: *mut frame, arg2: ::libc::c_int, arg3: ::libc::c_int);
}
extern "C" {
    pub fn gui_clear_window_mouse_face(arg1: *mut window);
}
extern "C" {
    pub fn cancel_mouse_face(arg1: *mut frame);
}
extern "C" {
    pub fn clear_mouse_face(arg1: *mut Mouse_HLInfo) -> bool;
}
extern "C" {
    pub fn cursor_in_mouse_face_p(w: *mut window) -> bool;
}
extern "C" {
    pub fn tty_draw_row_with_mouse_face(
        arg1: *mut window,
        arg2: *mut glyph_row,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
        arg5: draw_glyphs_face::Type,
    );
}
extern "C" {
    pub fn display_tty_menu_item(
        arg1: *const ::libc::c_char,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
        arg5: ::libc::c_int,
        arg6: bool,
    );
}
extern "C" {
    pub fn lookup_fringe_bitmap(arg1: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    pub fn draw_fringe_bitmap(arg1: *mut window, arg2: *mut glyph_row, arg3: ::libc::c_int);
}
extern "C" {
    pub fn draw_row_fringe_bitmaps(arg1: *mut window, arg2: *mut glyph_row);
}
extern "C" {
    pub fn draw_window_fringes(arg1: *mut window, arg2: bool) -> bool;
}
extern "C" {
    pub fn update_window_fringes(arg1: *mut window, arg2: bool) -> bool;
}
extern "C" {
    pub fn gui_init_fringe(arg1: *mut redisplay_interface);
}
extern "C" {
    pub fn row_hash(arg1: *mut glyph_row) -> ::libc::c_uint;
}
extern "C" {
    pub fn buffer_flipping_blocked_p() -> bool;
}
extern "C" {
    pub fn image_bitmap_pixmap(arg1: *mut frame, arg2: isize) -> isize;
}
extern "C" {
    pub fn image_reference_bitmap(arg1: *mut frame, arg2: isize);
}
extern "C" {
    pub fn image_create_bitmap_from_data(
        arg1: *mut frame,
        arg2: *mut ::libc::c_char,
        arg3: ::libc::c_uint,
        arg4: ::libc::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn image_create_bitmap_from_file(arg1: *mut frame, arg2: Lisp_Object) -> isize;
}
extern "C" {
    pub fn image_destroy_bitmap(arg1: *mut frame, arg2: isize);
}
extern "C" {
    pub fn image_destroy_all_bitmaps(arg1: *mut Display_Info);
}
extern "C" {
    pub fn image_find_image_file(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn make_image_cache() -> *mut image_cache;
}
extern "C" {
    pub fn free_image_cache(arg1: *mut frame);
}
extern "C" {
    pub fn clear_image_caches(arg1: Lisp_Object);
}
extern "C" {
    pub fn mark_image_cache(arg1: *mut image_cache);
}
extern "C" {
    pub fn valid_image_p(arg1: Lisp_Object) -> bool;
}
extern "C" {
    pub fn prepare_image_for_display(arg1: *mut frame, arg2: *mut image);
}
extern "C" {
    pub fn lookup_image(arg1: *mut frame, arg2: Lisp_Object, arg3: ::libc::c_int) -> isize;
}
extern "C" {
    pub fn image_background(
        arg1: *mut image,
        arg2: *mut frame,
        img: Emacs_Pix_Context,
    ) -> RGB_PIXEL_COLOR;
}
extern "C" {
    pub fn image_background_transparent(
        arg1: *mut image,
        arg2: *mut frame,
        mask: Emacs_Pix_Context,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn image_ascent(arg1: *mut image, arg2: *mut face, arg3: *mut glyph_slice)
        -> ::libc::c_int;
}
extern "C" {
    pub fn get_tty_size(arg1: ::libc::c_int, arg2: *mut ::libc::c_int, arg3: *mut ::libc::c_int);
}
extern "C" {
    pub fn request_sigio();
}
extern "C" {
    pub fn unrequest_sigio();
}
extern "C" {
    pub fn tabs_safe_p(arg1: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn init_baud_rate(arg1: ::libc::c_int);
}
extern "C" {
    pub fn init_sigio(arg1: ::libc::c_int);
}
extern "C" {
    pub fn update_face_from_frame_parameter(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn tty_defined_color(
        arg1: *mut frame,
        arg2: *const ::libc::c_char,
        arg3: *mut Emacs_Color,
        arg4: bool,
        arg5: bool,
    ) -> bool;
}
extern "C" {
    pub fn parse_color_spec(
        arg1: *const ::libc::c_char,
        arg2: *mut ::libc::c_ushort,
        arg3: *mut ::libc::c_ushort,
        arg4: *mut ::libc::c_ushort,
    ) -> bool;
}
extern "C" {
    pub fn tty_color_name(arg1: *mut frame, arg2: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn clear_face_cache(arg1: bool);
}
extern "C" {
    pub fn load_color(
        arg1: *mut frame,
        arg2: *mut face,
        arg3: Lisp_Object,
        arg4: lface_attribute_index::Type,
    ) -> ::libc::c_ulong;
}
extern "C" {
    pub fn choose_face_font(
        arg1: *mut frame,
        arg2: *mut Lisp_Object,
        arg3: Lisp_Object,
        arg4: *mut ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn prepare_face_for_display(arg1: *mut frame, arg2: *mut face);
}
extern "C" {
    pub fn lookup_named_face(
        arg1: *mut window,
        arg2: *mut frame,
        arg3: Lisp_Object,
        arg4: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn lookup_basic_face(
        arg1: *mut window,
        arg2: *mut frame,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn smaller_face(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn face_with_height(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn lookup_derived_face(
        arg1: *mut window,
        arg2: *mut frame,
        arg3: Lisp_Object,
        arg4: ::libc::c_int,
        arg5: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn init_frame_faces(arg1: *mut frame);
}
extern "C" {
    pub fn free_frame_faces(arg1: *mut frame);
}
extern "C" {
    pub fn recompute_basic_faces(arg1: *mut frame);
}
extern "C" {
    pub fn face_at_buffer_position(
        arg1: *mut window,
        arg2: isize,
        arg3: *mut isize,
        arg4: isize,
        arg5: bool,
        arg6: ::libc::c_int,
        arg7: lface_attribute_index::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn face_for_overlay_string(
        arg1: *mut window,
        arg2: isize,
        arg3: *mut isize,
        arg4: isize,
        arg5: bool,
        arg6: Lisp_Object,
        arg7: lface_attribute_index::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn face_at_string_position(
        arg1: *mut window,
        arg2: Lisp_Object,
        arg3: isize,
        arg4: isize,
        arg5: *mut isize,
        arg6: face_id,
        arg7: bool,
        arg8: lface_attribute_index::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn merge_faces(
        arg1: *mut window,
        arg2: Lisp_Object,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn compute_char_face(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: Lisp_Object,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn free_all_realized_faces(arg1: Lisp_Object);
}
extern "C" {
    #[link_name = "\u{1}unspecified_fg"]
    pub static mut unspecified_fg: [::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}unspecified_bg"]
    pub static mut unspecified_bg: [::libc::c_char; 0usize];
}
extern "C" {
    pub fn start_hourglass();
}
extern "C" {
    pub fn cancel_hourglass();
}
extern "C" {
    pub fn popup_activated() -> ::libc::c_int;
}
extern "C" {
    pub fn buffer_posn_from_coords(
        arg1: *mut window,
        arg2: *mut ::libc::c_int,
        arg3: *mut ::libc::c_int,
        arg4: *mut display_pos,
        arg5: *mut Lisp_Object,
        arg6: *mut ::libc::c_int,
        arg7: *mut ::libc::c_int,
        arg8: *mut ::libc::c_int,
        arg9: *mut ::libc::c_int,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn mode_line_string(
        arg1: *mut window,
        arg2: window_part::Type,
        arg3: *mut ::libc::c_int,
        arg4: *mut ::libc::c_int,
        arg5: *mut isize,
        arg6: *mut Lisp_Object,
        arg7: *mut ::libc::c_int,
        arg8: *mut ::libc::c_int,
        arg9: *mut ::libc::c_int,
        arg10: *mut ::libc::c_int,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn marginal_area_string(
        arg1: *mut window,
        arg2: window_part::Type,
        arg3: *mut ::libc::c_int,
        arg4: *mut ::libc::c_int,
        arg5: *mut isize,
        arg6: *mut Lisp_Object,
        arg7: *mut ::libc::c_int,
        arg8: *mut ::libc::c_int,
        arg9: *mut ::libc::c_int,
        arg10: *mut ::libc::c_int,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn redraw_frame(arg1: *mut frame);
}
extern "C" {
    pub fn update_frame(arg1: *mut frame, arg2: bool, arg3: bool) -> bool;
}
extern "C" {
    pub fn update_frame_with_menu(arg1: *mut frame, arg2: ::libc::c_int, arg3: ::libc::c_int);
}
extern "C" {
    pub fn update_mouse_position(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn bitch_at_user();
}
extern "C" {
    pub fn adjust_frame_glyphs(arg1: *mut frame);
}
extern "C" {
    pub fn free_glyphs(arg1: *mut frame);
}
extern "C" {
    pub fn free_window_matrices(arg1: *mut window);
}
extern "C" {
    pub fn check_glyph_memory();
}
extern "C" {
    pub fn mirrored_line_dance(
        arg1: *mut glyph_matrix,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: *mut ::libc::c_int,
        arg5: *mut ::libc::c_char,
    );
}
extern "C" {
    pub fn clear_glyph_matrix(arg1: *mut glyph_matrix);
}
extern "C" {
    pub fn clear_current_matrices(f: *mut frame);
}
extern "C" {
    pub fn clear_desired_matrices(arg1: *mut frame);
}
extern "C" {
    pub fn shift_glyph_matrix(
        arg1: *mut window,
        arg2: *mut glyph_matrix,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
        arg5: ::libc::c_int,
    );
}
extern "C" {
    pub fn rotate_matrix(
        arg1: *mut glyph_matrix,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
    );
}
extern "C" {
    pub fn increment_matrix_positions(
        arg1: *mut glyph_matrix,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: isize,
        arg5: isize,
    );
}
extern "C" {
    pub fn blank_row(arg1: *mut window, arg2: *mut glyph_row, arg3: ::libc::c_int);
}
extern "C" {
    pub fn clear_glyph_matrix_rows(
        arg1: *mut glyph_matrix,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
    );
}
extern "C" {
    pub fn clear_glyph_row(arg1: *mut glyph_row);
}
extern "C" {
    pub fn prepare_desired_row(arg1: *mut window, arg2: *mut glyph_row, arg3: bool);
}
extern "C" {
    pub fn update_single_window(arg1: *mut window);
}
extern "C" {
    pub fn gui_update_window_begin(arg1: *mut window);
}
extern "C" {
    pub fn gui_update_window_end(arg1: *mut window, arg2: bool, arg3: bool);
}
extern "C" {
    pub fn do_pending_window_change(arg1: bool);
}
extern "C" {
    pub fn change_frame_size(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: bool,
        arg5: bool,
        arg6: bool,
        arg7: bool,
    );
}
extern "C" {
    pub fn init_display();
}
extern "C" {
    pub fn syms_of_display();
}
extern "C" {
    pub fn spec_glyph_lookup_face(arg1: *mut window, arg2: *mut GLYPH);
}
extern "C" {
    pub fn fill_up_frame_row_with_spaces(arg1: *mut glyph_row, arg2: ::libc::c_int);
}
extern "C" {
    pub fn ring_bell(arg1: *mut frame);
}
extern "C" {
    pub fn update_begin(arg1: *mut frame);
}
extern "C" {
    pub fn update_end(arg1: *mut frame);
}
extern "C" {
    pub fn set_terminal_window(arg1: *mut frame, arg2: ::libc::c_int);
}
extern "C" {
    pub fn cursor_to(arg1: *mut frame, arg2: ::libc::c_int, arg3: ::libc::c_int);
}
extern "C" {
    pub fn raw_cursor_to(arg1: *mut frame, arg2: ::libc::c_int, arg3: ::libc::c_int);
}
extern "C" {
    pub fn clear_to_end(arg1: *mut frame);
}
extern "C" {
    pub fn clear_frame(arg1: *mut frame);
}
extern "C" {
    pub fn clear_end_of_line(arg1: *mut frame, arg2: ::libc::c_int);
}
extern "C" {
    pub fn write_glyphs(arg1: *mut frame, arg2: *mut glyph, arg3: ::libc::c_int);
}
extern "C" {
    pub fn insert_glyphs(arg1: *mut frame, arg2: *mut glyph, arg3: ::libc::c_int);
}
extern "C" {
    pub fn delete_glyphs(arg1: *mut frame, arg2: ::libc::c_int);
}
extern "C" {
    pub fn ins_del_lines(arg1: *mut frame, arg2: ::libc::c_int, arg3: ::libc::c_int);
}
extern "C" {
    pub fn init_initial_terminal() -> *mut terminal;
}
extern "C" {
    pub fn tty_turn_off_insert(arg1: *mut tty_display_info);
}
extern "C" {
    pub fn string_cost(arg1: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn per_line_cost(arg1: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn calculate_costs(arg1: *mut frame);
}
extern "C" {
    pub fn produce_glyphs(arg1: *mut it);
}
extern "C" {
    pub fn tty_capable_p(arg1: *mut tty_display_info, arg2: ::libc::c_uint) -> bool;
}
extern "C" {
    pub fn set_tty_color_mode(arg1: *mut tty_display_info, arg2: *mut frame);
}
extern "C" {
    pub fn create_tty_output(arg1: *mut frame);
}
extern "C" {
    pub fn init_tty(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: bool,
    ) -> *mut terminal;
}
extern "C" {
    pub fn tty_append_glyph(arg1: *mut it);
}
pub mod _bindgen_ty_44 {
    pub type Type = u32;
    pub const SCROLL_INFINITY: Type = 1000000;
}
extern "C" {
    pub fn scrolling_max_lines_saved(
        arg1: ::libc::c_int,
        arg2: ::libc::c_int,
        arg3: *mut ::libc::c_uint,
        arg4: *mut ::libc::c_uint,
        arg5: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn do_line_insertion_deletion_costs(
        arg1: *mut frame,
        arg2: *const ::libc::c_char,
        arg3: *const ::libc::c_char,
        arg4: *const ::libc::c_char,
        arg5: *const ::libc::c_char,
        arg6: *const ::libc::c_char,
        arg7: *const ::libc::c_char,
        arg8: ::libc::c_int,
    );
}
extern "C" {
    pub fn scrolling_1(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
        arg5: *mut ::libc::c_int,
        arg6: *mut ::libc::c_int,
        arg7: *mut ::libc::c_uint,
        arg8: *mut ::libc::c_uint,
        arg9: ::libc::c_int,
    );
}
pub mod resource_types {
    pub type Type = u32;
    pub const RES_TYPE_NUMBER: Type = 0;
    pub const RES_TYPE_FLOAT: Type = 1;
    pub const RES_TYPE_BOOLEAN: Type = 2;
    pub const RES_TYPE_STRING: Type = 3;
    pub const RES_TYPE_SYMBOL: Type = 4;
    pub const RES_TYPE_BOOLEAN_NUMBER: Type = 5;
}
extern "C" {
    pub fn check_x_display_info(arg1: Lisp_Object) -> *mut Display_Info;
}
extern "C" {
    pub fn gui_display_get_arg(
        arg1: *mut Display_Info,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: *const ::libc::c_char,
        arg5: *const ::libc::c_char,
        arg6: resource_types::Type,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn gui_frame_get_and_record_arg(
        arg1: *mut frame,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: *const ::libc::c_char,
        arg5: *const ::libc::c_char,
        arg6: resource_types::Type,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn gui_default_parameter(
        arg1: *mut frame,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: *const ::libc::c_char,
        arg6: *const ::libc::c_char,
        arg7: resource_types::Type,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn gui_mouse_grabbed(arg1: *mut Display_Info) -> bool;
}
extern "C" {
    pub fn gui_redo_mouse_highlight(arg1: *mut Display_Info);
}
pub mod composition_method {
    pub type Type = u32;
    pub const COMPOSITION_RELATIVE: Type = 0;
    pub const COMPOSITION_WITH_RULE: Type = 1;
    pub const COMPOSITION_WITH_ALTCHARS: Type = 2;
    pub const COMPOSITION_WITH_RULE_ALTCHARS: Type = 3;
    pub const COMPOSITION_NO: Type = 4;
}
extern "C" {
    pub fn composition_registered_p(prop: Lisp_Object) -> bool;
}
extern "C" {
    pub fn COMPOSITION_ENCODE_RULE_VALID(gref: ::libc::c_int, nref: ::libc::c_int) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct composition {
    pub glyph_len: ::libc::c_int,
    pub pixel_width: ::libc::c_short,
    pub ascent: ::libc::c_short,
    pub descent: ::libc::c_short,
    pub lbearing: ::libc::c_short,
    pub rbearing: ::libc::c_short,
    pub width: ::libc::c_int,
    pub method: composition_method::Type,
    pub hash_index: isize,
    pub font: *mut ::libc::c_void,
    pub offsets: *mut ::libc::c_short,
}
#[test]
fn bindgen_test_layout_composition() {
    assert_eq!(
        ::std::mem::size_of::<composition>(),
        48usize,
        concat!("Size of: ", stringify!(composition))
    );
    assert_eq!(
        ::std::mem::align_of::<composition>(),
        8usize,
        concat!("Alignment of ", stringify!(composition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition>())).glyph_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(composition),
            "::",
            stringify!(glyph_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition>())).pixel_width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(composition),
            "::",
            stringify!(pixel_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition>())).ascent as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(composition),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition>())).descent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(composition),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition>())).lbearing as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(composition),
            "::",
            stringify!(lbearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition>())).rbearing as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(composition),
            "::",
            stringify!(rbearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(composition),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition>())).method as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(composition),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition>())).hash_index as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(composition),
            "::",
            stringify!(hash_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition>())).font as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(composition),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition>())).offsets as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(composition),
            "::",
            stringify!(offsets)
        )
    );
}
impl Default for composition {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}composition_table"]
    pub static mut composition_table: *mut *mut composition;
}
extern "C" {
    #[link_name = "\u{1}n_compositions"]
    pub static mut n_compositions: isize;
}
extern "C" {
    #[link_name = "\u{1}composition_hash_table"]
    pub static mut composition_hash_table: Lisp_Object;
}
extern "C" {
    pub fn get_composition_id(
        arg1: isize,
        arg2: isize,
        arg3: isize,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> isize;
}
extern "C" {
    pub fn find_composition(
        arg1: isize,
        arg2: isize,
        arg3: *mut isize,
        arg4: *mut isize,
        arg5: *mut Lisp_Object,
        arg6: Lisp_Object,
    ) -> bool;
}
extern "C" {
    pub fn update_compositions(arg1: isize, arg2: isize, arg3: ::libc::c_int);
}
extern "C" {
    pub fn make_composition_value_copy(arg1: Lisp_Object);
}
extern "C" {
    pub fn syms_of_composite();
}
extern "C" {
    pub fn compose_text(
        arg1: isize,
        arg2: isize,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    );
}
extern "C" {
    pub fn composition_method(prop: Lisp_Object) -> composition_method::Type;
}
extern "C" {
    pub fn composition_valid_p(start: isize, end: isize, prop: Lisp_Object) -> bool;
}
extern "C" {
    pub fn lgstring_glyph_addr(lgs: Lisp_Object, idx: isize) -> *mut Lisp_Object;
}
pub mod lglyph_indices {
    pub type Type = u32;
    pub const LGLYPH_IX_FROM: Type = 0;
    pub const LGLYPH_IX_TO: Type = 1;
    pub const LGLYPH_IX_CHAR: Type = 2;
    pub const LGLYPH_IX_CODE: Type = 3;
    pub const LGLYPH_IX_WIDTH: Type = 4;
    pub const LGLYPH_IX_LBEARING: Type = 5;
    pub const LGLYPH_IX_RBEARING: Type = 6;
    pub const LGLYPH_IX_ASCENT: Type = 7;
    pub const LGLYPH_IX_DESCENT: Type = 8;
    pub const LGLYPH_IX_ADJUSTMENT: Type = 9;
    pub const LGLYPH_SIZE: Type = 10;
}
extern "C" {
    pub fn composition_gstring_put_cache(arg1: Lisp_Object, arg2: isize) -> Lisp_Object;
}
extern "C" {
    pub fn composition_gstring_from_id(arg1: isize) -> Lisp_Object;
}
extern "C" {
    pub fn composition_gstring_p(arg1: Lisp_Object) -> bool;
}
extern "C" {
    pub fn composition_gstring_width(
        arg1: Lisp_Object,
        arg2: isize,
        arg3: isize,
        arg4: *mut font_metrics,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn composition_compute_stop_pos(
        arg1: *mut composition_it,
        arg2: isize,
        arg3: isize,
        arg4: isize,
        arg5: Lisp_Object,
    );
}
extern "C" {
    pub fn composition_reseat_it(
        arg1: *mut composition_it,
        arg2: isize,
        arg3: isize,
        arg4: isize,
        arg5: *mut window,
        arg6: ::libc::c_schar,
        arg7: *mut face,
        arg8: Lisp_Object,
    ) -> bool;
}
extern "C" {
    pub fn composition_update_it(
        arg1: *mut composition_it,
        arg2: isize,
        arg3: isize,
        arg4: Lisp_Object,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn composition_adjust_point(arg1: isize, arg2: isize) -> isize;
}
extern "C" {
    pub fn composition_gstring_lookup_cache(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn composition_gstring_cache_clear_font(arg1: Lisp_Object);
}
pub mod composition_state {
    pub type Type = u32;
    pub const COMPOSING_NO: Type = 0;
    pub const COMPOSING_CHAR: Type = 1;
    pub const COMPOSING_RULE: Type = 2;
    pub const COMPOSING_COMPONENT_CHAR: Type = 3;
    pub const COMPOSING_COMPONENT_RULE: Type = 4;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct composition_status {
    pub state: composition_state::Type,
    pub method: composition_method::Type,
    pub old_form: bool,
    pub length: ::libc::c_int,
    pub nchars: ::libc::c_int,
    pub ncomps: ::libc::c_int,
    pub carryover: [::libc::c_int; 68usize],
}
#[test]
fn bindgen_test_layout_composition_status() {
    assert_eq!(
        ::std::mem::size_of::<composition_status>(),
        296usize,
        concat!("Size of: ", stringify!(composition_status))
    );
    assert_eq!(
        ::std::mem::align_of::<composition_status>(),
        4usize,
        concat!("Alignment of ", stringify!(composition_status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_status>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_status),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_status>())).method as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_status),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_status>())).old_form as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_status),
            "::",
            stringify!(old_form)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_status>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_status),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_status>())).nchars as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_status),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_status>())).ncomps as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_status),
            "::",
            stringify!(ncomps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<composition_status>())).carryover as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(composition_status),
            "::",
            stringify!(carryover)
        )
    );
}
impl Default for composition_status {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iso_2022_spec {
    pub flags: ::libc::c_uint,
    pub current_invocation: [::libc::c_int; 2usize],
    pub current_designation: [::libc::c_int; 4usize],
    pub ctext_extended_segment_len: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub cmp_status: composition_status,
}
#[test]
fn bindgen_test_layout_iso_2022_spec() {
    assert_eq!(
        ::std::mem::size_of::<iso_2022_spec>(),
        332usize,
        concat!("Size of: ", stringify!(iso_2022_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<iso_2022_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(iso_2022_spec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iso_2022_spec>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iso_2022_spec),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iso_2022_spec>())).current_invocation as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iso_2022_spec),
            "::",
            stringify!(current_invocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iso_2022_spec>())).current_designation as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(iso_2022_spec),
            "::",
            stringify!(current_designation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<iso_2022_spec>())).ctext_extended_segment_len as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(iso_2022_spec),
            "::",
            stringify!(ctext_extended_segment_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iso_2022_spec>())).cmp_status as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(iso_2022_spec),
            "::",
            stringify!(cmp_status)
        )
    );
}
impl Default for iso_2022_spec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl iso_2022_spec {
    #[inline]
    pub fn single_shifting(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_single_shifting(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bol(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bol(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn embedded_utf_8(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_embedded_utf_8(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        single_shifting: bool_bf,
        bol: bool_bf,
        embedded_utf_8: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let single_shifting: u8 = unsafe { ::std::mem::transmute(single_shifting) };
            single_shifting as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bol: u8 = unsafe { ::std::mem::transmute(bol) };
            bol as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let embedded_utf_8: u8 = unsafe { ::std::mem::transmute(embedded_utf_8) };
            embedded_utf_8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct emacs_mule_spec {
    pub cmp_status: composition_status,
}
#[test]
fn bindgen_test_layout_emacs_mule_spec() {
    assert_eq!(
        ::std::mem::size_of::<emacs_mule_spec>(),
        296usize,
        concat!("Size of: ", stringify!(emacs_mule_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<emacs_mule_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(emacs_mule_spec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_mule_spec>())).cmp_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_mule_spec),
            "::",
            stringify!(cmp_status)
        )
    );
}
impl Default for emacs_mule_spec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct undecided_spec {
    pub inhibit_nbd: ::libc::c_int,
    pub inhibit_ied: ::libc::c_int,
    pub prefer_utf_8: bool,
}
#[test]
fn bindgen_test_layout_undecided_spec() {
    assert_eq!(
        ::std::mem::size_of::<undecided_spec>(),
        12usize,
        concat!("Size of: ", stringify!(undecided_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<undecided_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(undecided_spec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undecided_spec>())).inhibit_nbd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(undecided_spec),
            "::",
            stringify!(inhibit_nbd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undecided_spec>())).inhibit_ied as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(undecided_spec),
            "::",
            stringify!(inhibit_ied)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<undecided_spec>())).prefer_utf_8 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(undecided_spec),
            "::",
            stringify!(prefer_utf_8)
        )
    );
}
pub mod utf_bom_type {
    pub type Type = u32;
    pub const utf_detect_bom: Type = 0;
    pub const utf_without_bom: Type = 1;
    pub const utf_with_bom: Type = 2;
}
pub mod utf_16_endian_type {
    pub type Type = u32;
    pub const utf_16_big_endian: Type = 0;
    pub const utf_16_little_endian: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utf_16_spec {
    pub bom: utf_bom_type::Type,
    pub endian: utf_16_endian_type::Type,
    pub surrogate: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_utf_16_spec() {
    assert_eq!(
        ::std::mem::size_of::<utf_16_spec>(),
        12usize,
        concat!("Size of: ", stringify!(utf_16_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<utf_16_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(utf_16_spec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<utf_16_spec>())).bom as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(utf_16_spec),
            "::",
            stringify!(bom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<utf_16_spec>())).endian as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(utf_16_spec),
            "::",
            stringify!(endian)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<utf_16_spec>())).surrogate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(utf_16_spec),
            "::",
            stringify!(surrogate)
        )
    );
}
impl Default for utf_16_spec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct coding_detection_info {
    pub checked: ::libc::c_int,
    pub found: ::libc::c_int,
    pub rejected: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_coding_detection_info() {
    assert_eq!(
        ::std::mem::size_of::<coding_detection_info>(),
        12usize,
        concat!("Size of: ", stringify!(coding_detection_info))
    );
    assert_eq!(
        ::std::mem::align_of::<coding_detection_info>(),
        4usize,
        concat!("Alignment of ", stringify!(coding_detection_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_detection_info>())).checked as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_detection_info),
            "::",
            stringify!(checked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_detection_info>())).found as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_detection_info),
            "::",
            stringify!(found)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_detection_info>())).rejected as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_detection_info),
            "::",
            stringify!(rejected)
        )
    );
}
#[repr(C)]
pub struct coding_system {
    pub id: isize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub max_charset_id: ::libc::c_int,
    pub spec: coding_system__bindgen_ty_1,
    pub safe_charsets: *mut ::libc::c_uchar,
    pub head_ascii: isize,
    pub detected_utf8_bytes: isize,
    pub detected_utf8_chars: isize,
    pub produced: isize,
    pub produced_char: isize,
    pub consumed: isize,
    pub consumed_char: isize,
    pub src_pos: isize,
    pub src_pos_byte: isize,
    pub src_chars: isize,
    pub src_bytes: isize,
    pub src_object: Lisp_Object,
    pub source: *const ::libc::c_uchar,
    pub dst_pos: isize,
    pub dst_pos_byte: isize,
    pub dst_bytes: isize,
    pub dst_object: Lisp_Object,
    pub destination: *mut ::libc::c_uchar,
    pub charbuf: *mut ::libc::c_int,
    pub charbuf_size: ::libc::c_int,
    pub charbuf_used: ::libc::c_int,
    pub carryover: [::libc::c_uchar; 64usize],
    pub carryover_bytes: ::libc::c_int,
    pub default_char: ::libc::c_int,
    pub detector: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut coding_system, arg2: *mut coding_detection_info) -> bool,
    >,
    pub decoder: ::std::option::Option<unsafe extern "C" fn(arg1: *mut coding_system)>,
    pub encoder: ::std::option::Option<unsafe extern "C" fn(arg1: *mut coding_system) -> bool>,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union coding_system__bindgen_ty_1 {
    pub iso_2022: iso_2022_spec,
    pub ccl: *mut ccl_spec,
    pub utf_16: utf_16_spec,
    pub utf_8_bom: utf_bom_type::Type,
    pub emacs_mule: emacs_mule_spec,
    pub undecided: undecided_spec,
    _bindgen_union_align: [u64; 42usize],
}
#[test]
fn bindgen_test_layout_coding_system__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<coding_system__bindgen_ty_1>(),
        336usize,
        concat!("Size of: ", stringify!(coding_system__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<coding_system__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(coding_system__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<coding_system__bindgen_ty_1>())).iso_2022 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system__bindgen_ty_1),
            "::",
            stringify!(iso_2022)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system__bindgen_ty_1>())).ccl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system__bindgen_ty_1),
            "::",
            stringify!(ccl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<coding_system__bindgen_ty_1>())).utf_16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system__bindgen_ty_1),
            "::",
            stringify!(utf_16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<coding_system__bindgen_ty_1>())).utf_8_bom as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system__bindgen_ty_1),
            "::",
            stringify!(utf_8_bom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<coding_system__bindgen_ty_1>())).emacs_mule as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system__bindgen_ty_1),
            "::",
            stringify!(emacs_mule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<coding_system__bindgen_ty_1>())).undecided as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system__bindgen_ty_1),
            "::",
            stringify!(undecided)
        )
    );
}
impl Default for coding_system__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_coding_system() {
    assert_eq!(
        ::std::mem::size_of::<coding_system>(),
        616usize,
        concat!("Size of: ", stringify!(coding_system))
    );
    assert_eq!(
        ::std::mem::align_of::<coding_system>(),
        8usize,
        concat!("Alignment of ", stringify!(coding_system))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).max_charset_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(max_charset_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).spec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).safe_charsets as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(safe_charsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).head_ascii as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(head_ascii)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<coding_system>())).detected_utf8_bytes as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(detected_utf8_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<coding_system>())).detected_utf8_chars as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(detected_utf8_chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).produced as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(produced)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).produced_char as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(produced_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).consumed as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(consumed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).consumed_char as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(consumed_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).src_pos as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(src_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).src_pos_byte as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(src_pos_byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).src_chars as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(src_chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).src_bytes as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(src_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).src_object as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(src_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).source as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).dst_pos as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(dst_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).dst_pos_byte as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(dst_pos_byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).dst_bytes as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(dst_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).dst_object as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(dst_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).destination as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).charbuf as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(charbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).charbuf_size as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(charbuf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).charbuf_used as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(charbuf_used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).carryover as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(carryover)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).carryover_bytes as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(carryover_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).default_char as *const _ as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).detector as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(detector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).decoder as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(decoder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<coding_system>())).encoder as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(coding_system),
            "::",
            stringify!(encoder)
        )
    );
}
impl Default for coding_system {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl coding_system {
    #[inline]
    pub fn common_flags(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_common_flags(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn mode(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn src_multibyte(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_src_multibyte(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_multibyte(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_multibyte(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chars_at_source(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_chars_at_source(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn raw_destination(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_raw_destination(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn annotated(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_annotated(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eol_seen(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_eol_seen(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn result(&self) -> coding_result_code::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_result(&mut self, val: coding_result_code::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        common_flags: ::libc::c_uint,
        mode: ::libc::c_uint,
        src_multibyte: bool_bf,
        dst_multibyte: bool_bf,
        chars_at_source: bool_bf,
        raw_destination: bool_bf,
        annotated: bool_bf,
        eol_seen: ::libc::c_uint,
        result: coding_result_code::Type,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let common_flags: u32 = unsafe { ::std::mem::transmute(common_flags) };
            common_flags as u64
        });
        __bindgen_bitfield_unit.set(14usize, 5u8, {
            let mode: u32 = unsafe { ::std::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let src_multibyte: u8 = unsafe { ::std::mem::transmute(src_multibyte) };
            src_multibyte as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let dst_multibyte: u8 = unsafe { ::std::mem::transmute(dst_multibyte) };
            dst_multibyte as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let chars_at_source: u8 = unsafe { ::std::mem::transmute(chars_at_source) };
            chars_at_source as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let raw_destination: u8 = unsafe { ::std::mem::transmute(raw_destination) };
            raw_destination as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let annotated: u8 = unsafe { ::std::mem::transmute(annotated) };
            annotated as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let eol_seen: u32 = unsafe { ::std::mem::transmute(eol_seen) };
            eol_seen as u64
        });
        __bindgen_bitfield_unit.set(27usize, 3u8, {
            let result: u32 = unsafe { ::std::mem::transmute(result) };
            result as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn code_conversion_save(arg1: bool, arg2: bool) -> Lisp_Object;
}
extern "C" {
    pub fn encode_coding_utf_8(arg1: *mut coding_system) -> bool;
}
extern "C" {
    pub fn utf8_string_p(arg1: Lisp_Object) -> bool;
}
extern "C" {
    pub fn setup_coding_system(arg1: Lisp_Object, arg2: *mut coding_system);
}
extern "C" {
    pub fn coding_charset_list(arg1: *mut coding_system) -> Lisp_Object;
}
extern "C" {
    pub fn coding_system_charset_list(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn code_convert_string(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: bool,
        arg5: bool,
        arg6: bool,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn code_convert_string_norecord(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: bool,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn encode_string_utf_8(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: bool,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn decode_string_utf_8(
        arg1: Lisp_Object,
        arg2: *const ::libc::c_char,
        arg3: isize,
        arg4: Lisp_Object,
        arg5: bool,
        arg6: Lisp_Object,
        arg7: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn encode_file_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn decode_file_name(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn raw_text_coding_system(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn raw_text_coding_system_p(arg1: *mut coding_system) -> bool;
}
extern "C" {
    pub fn coding_inherit_eol_type(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn complement_process_encoding_system(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn make_string_from_utf8(arg1: *const ::libc::c_char, arg2: isize) -> Lisp_Object;
}
extern "C" {
    pub fn decode_coding_gap(arg1: *mut coding_system, arg2: isize);
}
extern "C" {
    pub fn decode_coding_object(
        arg1: *mut coding_system,
        arg2: Lisp_Object,
        arg3: isize,
        arg4: isize,
        arg5: isize,
        arg6: isize,
        arg7: Lisp_Object,
    );
}
extern "C" {
    pub fn encode_coding_object(
        arg1: *mut coding_system,
        arg2: Lisp_Object,
        arg3: isize,
        arg4: isize,
        arg5: isize,
        arg6: isize,
        arg7: Lisp_Object,
    );
}
extern "C" {
    pub fn surrogates_to_codepoint(arg1: ::libc::c_int, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn build_string_from_utf8(str: *const ::libc::c_char) -> Lisp_Object;
}
extern "C" {
    pub fn preferred_coding_system() -> Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}safe_terminal_coding"]
    pub static mut safe_terminal_coding: coding_system;
}
extern "C" {
    #[link_name = "\u{1}emacs_mule_bytes"]
    pub static mut emacs_mule_bytes: [::libc::c_char; 256usize];
}
extern "C" {
    #[link_name = "\u{1}unread_switch_frame"]
    pub static mut unread_switch_frame: Lisp_Object;
}
extern "C" {
    pub fn disp_char_vector(arg1: *mut Lisp_Char_Table, arg2: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn window_display_table(arg1: *mut window) -> *mut Lisp_Char_Table;
}
extern "C" {
    pub fn buffer_display_table() -> *mut Lisp_Char_Table;
}
extern "C" {
    #[link_name = "\u{1}gnu_xbm_bits"]
    pub static mut gnu_xbm_bits: [::libc::c_uchar; 350usize];
}
pub type emacs_env = emacs_env_28;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct emacs_value_tag {
    _unused: [u8; 0],
}
pub type emacs_value = *mut emacs_value_tag;
pub mod _bindgen_ty_45 {
    pub type Type = i32;
    pub const emacs_variadic_function: Type = -2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct emacs_runtime {
    pub size: isize,
    pub private_members: *mut emacs_runtime_private,
    pub get_environment:
        ::std::option::Option<unsafe extern "C" fn(runtime: *mut emacs_runtime) -> *mut emacs_env>,
}
#[test]
fn bindgen_test_layout_emacs_runtime() {
    assert_eq!(
        ::std::mem::size_of::<emacs_runtime>(),
        24usize,
        concat!("Size of: ", stringify!(emacs_runtime))
    );
    assert_eq!(
        ::std::mem::align_of::<emacs_runtime>(),
        8usize,
        concat!("Alignment of ", stringify!(emacs_runtime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_runtime>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_runtime),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_runtime>())).private_members as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_runtime),
            "::",
            stringify!(private_members)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_runtime>())).get_environment as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_runtime),
            "::",
            stringify!(get_environment)
        )
    );
}
impl Default for emacs_runtime {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type emacs_function = ::std::option::Option<
    unsafe extern "C" fn(
        env: *mut emacs_env,
        nargs: isize,
        args: *mut emacs_value,
        data: *mut ::libc::c_void,
    ) -> emacs_value,
>;
pub type emacs_finalizer = ::std::option::Option<unsafe extern "C" fn(data: *mut ::libc::c_void)>;
pub mod emacs_funcall_exit {
    pub type Type = u32;
    pub const emacs_funcall_exit_return: Type = 0;
    pub const emacs_funcall_exit_signal: Type = 1;
    pub const emacs_funcall_exit_throw: Type = 2;
}
pub mod emacs_process_input_result {
    pub type Type = u32;
    pub const emacs_process_input_continue: Type = 0;
    pub const emacs_process_input_quit: Type = 1;
}
pub type emacs_limb_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct emacs_env_25 {
    pub size: isize,
    pub private_members: *mut emacs_env_private,
    pub make_global_ref: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, value: emacs_value) -> emacs_value,
    >,
    pub free_global_ref:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, global_value: emacs_value)>,
    pub non_local_exit_check: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env) -> emacs_funcall_exit::Type,
    >,
    pub non_local_exit_clear: ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env)>,
    pub non_local_exit_get: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            symbol: *mut emacs_value,
            data: *mut emacs_value,
        ) -> emacs_funcall_exit::Type,
    >,
    pub non_local_exit_signal: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, symbol: emacs_value, data: emacs_value),
    >,
    pub non_local_exit_throw: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, tag: emacs_value, value: emacs_value),
    >,
    pub make_function: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            min_arity: isize,
            max_arity: isize,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    env: *mut emacs_env,
                    nargs: isize,
                    args: *mut emacs_value,
                    data: *mut ::libc::c_void,
                ) -> emacs_value,
            >,
            docstring: *const ::libc::c_char,
            data: *mut ::libc::c_void,
        ) -> emacs_value,
    >,
    pub funcall: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            func: emacs_value,
            nargs: isize,
            args: *mut emacs_value,
        ) -> emacs_value,
    >,
    pub intern: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, name: *const ::libc::c_char) -> emacs_value,
    >,
    pub type_of: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> emacs_value,
    >,
    pub is_not_nil:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> bool>,
    pub eq: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, a: emacs_value, b: emacs_value) -> bool,
    >,
    pub extract_integer: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> intmax_t,
    >,
    pub make_integer: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, n: intmax_t) -> emacs_value,
    >,
    pub extract_float:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> f64>,
    pub make_float:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, d: f64) -> emacs_value>,
    pub copy_string_contents: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            value: emacs_value,
            buf: *mut ::libc::c_char,
            len: *mut isize,
        ) -> bool,
    >,
    pub make_string: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            str: *const ::libc::c_char,
            len: isize,
        ) -> emacs_value,
    >,
    pub make_user_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            fin: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
            ptr: *mut ::libc::c_void,
        ) -> emacs_value,
    >,
    pub get_user_ptr: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> *mut ::libc::c_void,
    >,
    pub set_user_ptr: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value, ptr: *mut ::libc::c_void),
    >,
    pub get_user_finalizer: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            env: *mut emacs_env,
            uptr: emacs_value,
        ) -> ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void, env: *mut emacs_env, uptr: emacs_value),
        >,
    >,
    pub set_user_finalizer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            arg: emacs_value,
            fin: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        ),
    >,
    pub vec_get: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, vector: emacs_value, index: isize) -> emacs_value,
    >,
    pub vec_set: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            vector: emacs_value,
            index: isize,
            value: emacs_value,
        ),
    >,
    pub vec_size: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, vector: emacs_value) -> isize,
    >,
}
#[test]
fn bindgen_test_layout_emacs_env_25() {
    assert_eq!(
        ::std::mem::size_of::<emacs_env_25>(),
        232usize,
        concat!("Size of: ", stringify!(emacs_env_25))
    );
    assert_eq!(
        ::std::mem::align_of::<emacs_env_25>(),
        8usize,
        concat!("Alignment of ", stringify!(emacs_env_25))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).private_members as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(private_members)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).make_global_ref as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(make_global_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).free_global_ref as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(free_global_ref)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_25>())).non_local_exit_check as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(non_local_exit_check)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_25>())).non_local_exit_clear as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(non_local_exit_clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).non_local_exit_get as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(non_local_exit_get)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_25>())).non_local_exit_signal as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(non_local_exit_signal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_25>())).non_local_exit_throw as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(non_local_exit_throw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).make_function as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(make_function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).funcall as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(funcall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).intern as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(intern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).type_of as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(type_of)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).is_not_nil as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(is_not_nil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).eq as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(eq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).extract_integer as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(extract_integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).make_integer as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(make_integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).extract_float as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(extract_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).make_float as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(make_float)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_25>())).copy_string_contents as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(copy_string_contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).make_string as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(make_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).make_user_ptr as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(make_user_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).get_user_ptr as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(get_user_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).set_user_ptr as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(set_user_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).get_user_finalizer as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(get_user_finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).set_user_finalizer as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(set_user_finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).vec_get as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(vec_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).vec_set as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(vec_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_25>())).vec_size as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_25),
            "::",
            stringify!(vec_size)
        )
    );
}
impl Default for emacs_env_25 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct emacs_env_26 {
    pub size: isize,
    pub private_members: *mut emacs_env_private,
    pub make_global_ref: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, value: emacs_value) -> emacs_value,
    >,
    pub free_global_ref:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, global_value: emacs_value)>,
    pub non_local_exit_check: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env) -> emacs_funcall_exit::Type,
    >,
    pub non_local_exit_clear: ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env)>,
    pub non_local_exit_get: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            symbol: *mut emacs_value,
            data: *mut emacs_value,
        ) -> emacs_funcall_exit::Type,
    >,
    pub non_local_exit_signal: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, symbol: emacs_value, data: emacs_value),
    >,
    pub non_local_exit_throw: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, tag: emacs_value, value: emacs_value),
    >,
    pub make_function: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            min_arity: isize,
            max_arity: isize,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    env: *mut emacs_env,
                    nargs: isize,
                    args: *mut emacs_value,
                    data: *mut ::libc::c_void,
                ) -> emacs_value,
            >,
            docstring: *const ::libc::c_char,
            data: *mut ::libc::c_void,
        ) -> emacs_value,
    >,
    pub funcall: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            func: emacs_value,
            nargs: isize,
            args: *mut emacs_value,
        ) -> emacs_value,
    >,
    pub intern: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, name: *const ::libc::c_char) -> emacs_value,
    >,
    pub type_of: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> emacs_value,
    >,
    pub is_not_nil:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> bool>,
    pub eq: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, a: emacs_value, b: emacs_value) -> bool,
    >,
    pub extract_integer: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> intmax_t,
    >,
    pub make_integer: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, n: intmax_t) -> emacs_value,
    >,
    pub extract_float:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> f64>,
    pub make_float:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, d: f64) -> emacs_value>,
    pub copy_string_contents: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            value: emacs_value,
            buf: *mut ::libc::c_char,
            len: *mut isize,
        ) -> bool,
    >,
    pub make_string: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            str: *const ::libc::c_char,
            len: isize,
        ) -> emacs_value,
    >,
    pub make_user_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            fin: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
            ptr: *mut ::libc::c_void,
        ) -> emacs_value,
    >,
    pub get_user_ptr: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> *mut ::libc::c_void,
    >,
    pub set_user_ptr: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value, ptr: *mut ::libc::c_void),
    >,
    pub get_user_finalizer: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            env: *mut emacs_env,
            uptr: emacs_value,
        ) -> ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void, env: *mut emacs_env, uptr: emacs_value),
        >,
    >,
    pub set_user_finalizer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            arg: emacs_value,
            fin: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        ),
    >,
    pub vec_get: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, vector: emacs_value, index: isize) -> emacs_value,
    >,
    pub vec_set: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            vector: emacs_value,
            index: isize,
            value: emacs_value,
        ),
    >,
    pub vec_size: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, vector: emacs_value) -> isize,
    >,
    pub should_quit: ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env) -> bool>,
}
#[test]
fn bindgen_test_layout_emacs_env_26() {
    assert_eq!(
        ::std::mem::size_of::<emacs_env_26>(),
        240usize,
        concat!("Size of: ", stringify!(emacs_env_26))
    );
    assert_eq!(
        ::std::mem::align_of::<emacs_env_26>(),
        8usize,
        concat!("Alignment of ", stringify!(emacs_env_26))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).private_members as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(private_members)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).make_global_ref as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(make_global_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).free_global_ref as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(free_global_ref)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_26>())).non_local_exit_check as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(non_local_exit_check)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_26>())).non_local_exit_clear as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(non_local_exit_clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).non_local_exit_get as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(non_local_exit_get)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_26>())).non_local_exit_signal as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(non_local_exit_signal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_26>())).non_local_exit_throw as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(non_local_exit_throw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).make_function as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(make_function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).funcall as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(funcall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).intern as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(intern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).type_of as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(type_of)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).is_not_nil as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(is_not_nil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).eq as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(eq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).extract_integer as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(extract_integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).make_integer as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(make_integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).extract_float as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(extract_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).make_float as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(make_float)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_26>())).copy_string_contents as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(copy_string_contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).make_string as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(make_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).make_user_ptr as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(make_user_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).get_user_ptr as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(get_user_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).set_user_ptr as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(set_user_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).get_user_finalizer as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(get_user_finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).set_user_finalizer as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(set_user_finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).vec_get as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(vec_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).vec_set as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(vec_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).vec_size as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(vec_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_26>())).should_quit as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_26),
            "::",
            stringify!(should_quit)
        )
    );
}
impl Default for emacs_env_26 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct emacs_env_27 {
    pub size: isize,
    pub private_members: *mut emacs_env_private,
    pub make_global_ref: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, value: emacs_value) -> emacs_value,
    >,
    pub free_global_ref:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, global_value: emacs_value)>,
    pub non_local_exit_check: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env) -> emacs_funcall_exit::Type,
    >,
    pub non_local_exit_clear: ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env)>,
    pub non_local_exit_get: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            symbol: *mut emacs_value,
            data: *mut emacs_value,
        ) -> emacs_funcall_exit::Type,
    >,
    pub non_local_exit_signal: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, symbol: emacs_value, data: emacs_value),
    >,
    pub non_local_exit_throw: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, tag: emacs_value, value: emacs_value),
    >,
    pub make_function: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            min_arity: isize,
            max_arity: isize,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    env: *mut emacs_env,
                    nargs: isize,
                    args: *mut emacs_value,
                    data: *mut ::libc::c_void,
                ) -> emacs_value,
            >,
            docstring: *const ::libc::c_char,
            data: *mut ::libc::c_void,
        ) -> emacs_value,
    >,
    pub funcall: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            func: emacs_value,
            nargs: isize,
            args: *mut emacs_value,
        ) -> emacs_value,
    >,
    pub intern: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, name: *const ::libc::c_char) -> emacs_value,
    >,
    pub type_of: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> emacs_value,
    >,
    pub is_not_nil:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> bool>,
    pub eq: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, a: emacs_value, b: emacs_value) -> bool,
    >,
    pub extract_integer: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> intmax_t,
    >,
    pub make_integer: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, n: intmax_t) -> emacs_value,
    >,
    pub extract_float:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> f64>,
    pub make_float:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, d: f64) -> emacs_value>,
    pub copy_string_contents: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            value: emacs_value,
            buf: *mut ::libc::c_char,
            len: *mut isize,
        ) -> bool,
    >,
    pub make_string: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            str: *const ::libc::c_char,
            len: isize,
        ) -> emacs_value,
    >,
    pub make_user_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            fin: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
            ptr: *mut ::libc::c_void,
        ) -> emacs_value,
    >,
    pub get_user_ptr: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> *mut ::libc::c_void,
    >,
    pub set_user_ptr: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value, ptr: *mut ::libc::c_void),
    >,
    pub get_user_finalizer: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            env: *mut emacs_env,
            uptr: emacs_value,
        ) -> ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void, env: *mut emacs_env, uptr: emacs_value),
        >,
    >,
    pub set_user_finalizer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            arg: emacs_value,
            fin: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        ),
    >,
    pub vec_get: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, vector: emacs_value, index: isize) -> emacs_value,
    >,
    pub vec_set: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            vector: emacs_value,
            index: isize,
            value: emacs_value,
        ),
    >,
    pub vec_size: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, vector: emacs_value) -> isize,
    >,
    pub should_quit: ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env) -> bool>,
    pub process_input: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env) -> emacs_process_input_result::Type,
    >,
    pub extract_time: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> timespec,
    >,
    pub make_time: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, time: timespec) -> emacs_value,
    >,
    pub extract_big_integer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            arg: emacs_value,
            sign: *mut ::libc::c_int,
            count: *mut isize,
            magnitude: *mut emacs_limb_t,
        ) -> bool,
    >,
    pub make_big_integer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            sign: ::libc::c_int,
            count: isize,
            magnitude: *const emacs_limb_t,
        ) -> emacs_value,
    >,
}
#[test]
fn bindgen_test_layout_emacs_env_27() {
    assert_eq!(
        ::std::mem::size_of::<emacs_env_27>(),
        280usize,
        concat!("Size of: ", stringify!(emacs_env_27))
    );
    assert_eq!(
        ::std::mem::align_of::<emacs_env_27>(),
        8usize,
        concat!("Alignment of ", stringify!(emacs_env_27))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).private_members as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(private_members)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).make_global_ref as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(make_global_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).free_global_ref as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(free_global_ref)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_27>())).non_local_exit_check as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(non_local_exit_check)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_27>())).non_local_exit_clear as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(non_local_exit_clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).non_local_exit_get as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(non_local_exit_get)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_27>())).non_local_exit_signal as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(non_local_exit_signal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_27>())).non_local_exit_throw as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(non_local_exit_throw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).make_function as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(make_function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).funcall as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(funcall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).intern as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(intern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).type_of as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(type_of)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).is_not_nil as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(is_not_nil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).eq as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(eq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).extract_integer as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(extract_integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).make_integer as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(make_integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).extract_float as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(extract_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).make_float as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(make_float)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_27>())).copy_string_contents as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(copy_string_contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).make_string as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(make_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).make_user_ptr as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(make_user_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).get_user_ptr as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(get_user_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).set_user_ptr as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(set_user_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).get_user_finalizer as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(get_user_finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).set_user_finalizer as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(set_user_finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).vec_get as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(vec_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).vec_set as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(vec_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).vec_size as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(vec_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).should_quit as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(should_quit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).process_input as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(process_input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).extract_time as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(extract_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).make_time as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(make_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_27>())).extract_big_integer as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(extract_big_integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_27>())).make_big_integer as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_27),
            "::",
            stringify!(make_big_integer)
        )
    );
}
impl Default for emacs_env_27 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct emacs_env_28 {
    pub size: isize,
    pub private_members: *mut emacs_env_private,
    pub make_global_ref: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, value: emacs_value) -> emacs_value,
    >,
    pub free_global_ref:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, global_value: emacs_value)>,
    pub non_local_exit_check: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env) -> emacs_funcall_exit::Type,
    >,
    pub non_local_exit_clear: ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env)>,
    pub non_local_exit_get: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            symbol: *mut emacs_value,
            data: *mut emacs_value,
        ) -> emacs_funcall_exit::Type,
    >,
    pub non_local_exit_signal: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, symbol: emacs_value, data: emacs_value),
    >,
    pub non_local_exit_throw: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, tag: emacs_value, value: emacs_value),
    >,
    pub make_function: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            min_arity: isize,
            max_arity: isize,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    env: *mut emacs_env,
                    nargs: isize,
                    args: *mut emacs_value,
                    data: *mut ::libc::c_void,
                ) -> emacs_value,
            >,
            docstring: *const ::libc::c_char,
            data: *mut ::libc::c_void,
        ) -> emacs_value,
    >,
    pub funcall: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            func: emacs_value,
            nargs: isize,
            args: *mut emacs_value,
        ) -> emacs_value,
    >,
    pub intern: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, name: *const ::libc::c_char) -> emacs_value,
    >,
    pub type_of: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> emacs_value,
    >,
    pub is_not_nil:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> bool>,
    pub eq: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, a: emacs_value, b: emacs_value) -> bool,
    >,
    pub extract_integer: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> intmax_t,
    >,
    pub make_integer: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, n: intmax_t) -> emacs_value,
    >,
    pub extract_float:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> f64>,
    pub make_float:
        ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env, d: f64) -> emacs_value>,
    pub copy_string_contents: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            value: emacs_value,
            buf: *mut ::libc::c_char,
            len: *mut isize,
        ) -> bool,
    >,
    pub make_string: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            str: *const ::libc::c_char,
            len: isize,
        ) -> emacs_value,
    >,
    pub make_user_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            fin: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
            ptr: *mut ::libc::c_void,
        ) -> emacs_value,
    >,
    pub get_user_ptr: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> *mut ::libc::c_void,
    >,
    pub set_user_ptr: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value, ptr: *mut ::libc::c_void),
    >,
    pub get_user_finalizer: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            env: *mut emacs_env,
            uptr: emacs_value,
        ) -> ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void, env: *mut emacs_env, uptr: emacs_value),
        >,
    >,
    pub set_user_finalizer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            arg: emacs_value,
            fin: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        ),
    >,
    pub vec_get: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, vector: emacs_value, index: isize) -> emacs_value,
    >,
    pub vec_set: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            vector: emacs_value,
            index: isize,
            value: emacs_value,
        ),
    >,
    pub vec_size: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, vector: emacs_value) -> isize,
    >,
    pub should_quit: ::std::option::Option<unsafe extern "C" fn(env: *mut emacs_env) -> bool>,
    pub process_input: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env) -> emacs_process_input_result::Type,
    >,
    pub extract_time: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, arg: emacs_value) -> timespec,
    >,
    pub make_time: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, time: timespec) -> emacs_value,
    >,
    pub extract_big_integer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            arg: emacs_value,
            sign: *mut ::libc::c_int,
            count: *mut isize,
            magnitude: *mut emacs_limb_t,
        ) -> bool,
    >,
    pub make_big_integer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            sign: ::libc::c_int,
            count: isize,
            magnitude: *const emacs_limb_t,
        ) -> emacs_value,
    >,
    pub get_function_finalizer: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            env: *mut emacs_env,
            arg: emacs_value,
        ) -> ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::libc::c_void, env: *mut emacs_env, arg: emacs_value),
        >,
    >,
    pub set_function_finalizer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            arg: emacs_value,
            fin: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        ),
    >,
    pub open_channel: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, pipe_process: emacs_value) -> ::libc::c_int,
    >,
    pub make_interactive: ::std::option::Option<
        unsafe extern "C" fn(env: *mut emacs_env, function: emacs_value, spec: emacs_value),
    >,
    pub make_unibyte_string: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut emacs_env,
            str: *const ::libc::c_char,
            len: isize,
        ) -> emacs_value,
    >,
}
#[test]
fn bindgen_test_layout_emacs_env_28() {
    assert_eq!(
        ::std::mem::size_of::<emacs_env_28>(),
        320usize,
        concat!("Size of: ", stringify!(emacs_env_28))
    );
    assert_eq!(
        ::std::mem::align_of::<emacs_env_28>(),
        8usize,
        concat!("Alignment of ", stringify!(emacs_env_28))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).private_members as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(private_members)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).make_global_ref as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(make_global_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).free_global_ref as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(free_global_ref)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_28>())).non_local_exit_check as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(non_local_exit_check)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_28>())).non_local_exit_clear as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(non_local_exit_clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).non_local_exit_get as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(non_local_exit_get)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_28>())).non_local_exit_signal as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(non_local_exit_signal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_28>())).non_local_exit_throw as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(non_local_exit_throw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).make_function as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(make_function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).funcall as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(funcall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).intern as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(intern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).type_of as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(type_of)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).is_not_nil as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(is_not_nil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).eq as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(eq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).extract_integer as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(extract_integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).make_integer as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(make_integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).extract_float as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(extract_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).make_float as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(make_float)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_28>())).copy_string_contents as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(copy_string_contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).make_string as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(make_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).make_user_ptr as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(make_user_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).get_user_ptr as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(get_user_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).set_user_ptr as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(set_user_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).get_user_finalizer as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(get_user_finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).set_user_finalizer as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(set_user_finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).vec_get as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(vec_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).vec_set as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(vec_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).vec_size as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(vec_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).should_quit as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(should_quit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).process_input as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(process_input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).extract_time as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(extract_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).make_time as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(make_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_28>())).extract_big_integer as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(extract_big_integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).make_big_integer as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(make_big_integer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_28>())).get_function_finalizer as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(get_function_finalizer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_28>())).set_function_finalizer as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(set_function_finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).open_channel as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(open_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_env_28>())).make_interactive as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(make_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<emacs_env_28>())).make_unibyte_string as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_env_28),
            "::",
            stringify!(make_unibyte_string)
        )
    );
}
impl Default for emacs_env_28 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn emacs_module_init(runtime: *mut emacs_runtime) -> ::libc::c_int;
}
pub mod _bindgen_ty_46 {
    pub type Type = u32;
    pub const TIMESPEC_HZ: Type = 1000000000;
}
pub mod _bindgen_ty_47 {
    pub type Type = u32;
    pub const LOG10_TIMESPEC_HZ: Type = 9;
}
pub mod _bindgen_ty_48 {
    pub type Type = u32;
    pub const TIMESPEC_RESOLUTION: Type = 1000000000;
}
pub mod _bindgen_ty_49 {
    pub type Type = u32;
    pub const LOG10_TIMESPEC_RESOLUTION: Type = 9;
}
extern "C" {
    pub fn make_timespec(s: time_t, ns: ::libc::c_long) -> timespec;
}
extern "C" {
    pub fn timespec_cmp(a: timespec, b: timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn timespec_sign(a: timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn timespec_add(arg1: timespec, arg2: timespec) -> timespec;
}
extern "C" {
    pub fn timespec_sub(arg1: timespec, arg2: timespec) -> timespec;
}
extern "C" {
    pub fn dtotimespec(arg1: f64) -> timespec;
}
extern "C" {
    pub fn timespectod(a: timespec) -> f64;
}
extern "C" {
    pub fn current_timespec() -> timespec;
}
extern "C" {
    pub fn gettime(arg1: *mut timespec);
}
extern "C" {
    pub fn settime(arg1: *const timespec) -> ::libc::c_int;
}
pub type Time = ::libc::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::libc::c_int,
    pub tz_dsttime: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::libc::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::libc::c_int;
}
pub mod __itimer_which {
    pub type Type = u32;
    pub const ITIMER_REAL: Type = 0;
    pub const ITIMER_VIRTUAL: Type = 1;
    pub const ITIMER_PROF: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub use self::__itimer_which::Type as __itimer_which_t;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::libc::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn utimes(__file: *const ::libc::c_char, __tvp: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn lutimes(__file: *const ::libc::c_char, __tvp: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::libc::c_int, __tvp: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn futimesat(
        __fd: ::libc::c_int,
        __file: *const ::libc::c_char,
        __tvp: *const timeval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn invalid_timespec() -> timespec;
}
extern "C" {
    pub fn timespec_valid_p(t: timespec) -> bool;
}
extern "C" {
    pub fn set_waiting_for_input(arg1: *mut timespec);
}
pub mod _bindgen_ty_50 {
    pub type Type = u32;
    pub const LO_TIME_BITS: Type = 16;
}
#[repr(C)]
pub struct lisp_time {
    pub ticks: Lisp_Object,
    pub hz: Lisp_Object,
}
#[test]
fn bindgen_test_layout_lisp_time() {
    assert_eq!(
        ::std::mem::size_of::<lisp_time>(),
        16usize,
        concat!("Size of: ", stringify!(lisp_time))
    );
    assert_eq!(
        ::std::mem::align_of::<lisp_time>(),
        8usize,
        concat!("Alignment of ", stringify!(lisp_time))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lisp_time>())).ticks as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lisp_time),
            "::",
            stringify!(ticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lisp_time>())).hz as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lisp_time),
            "::",
            stringify!(hz)
        )
    );
}
impl Default for lisp_time {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn make_timeval(arg1: timespec) -> timeval;
}
extern "C" {
    pub fn make_lisp_time(arg1: timespec) -> Lisp_Object;
}
extern "C" {
    pub fn timespec_to_lisp(arg1: timespec) -> Lisp_Object;
}
extern "C" {
    pub fn list4_to_timespec(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: *mut timespec,
    ) -> bool;
}
extern "C" {
    pub fn lisp_time_argument(arg1: Lisp_Object) -> timespec;
}
extern "C" {
    pub fn time_overflow();
}
extern "C" {
    pub fn init_timefns();
}
extern "C" {
    pub fn syms_of_timefns();
}
pub mod scroll_bar_part {
    pub type Type = u32;
    pub const scroll_bar_nowhere: Type = 0;
    pub const scroll_bar_above_handle: Type = 1;
    pub const scroll_bar_handle: Type = 2;
    pub const scroll_bar_below_handle: Type = 3;
    pub const scroll_bar_up_arrow: Type = 4;
    pub const scroll_bar_down_arrow: Type = 5;
    pub const scroll_bar_to_top: Type = 6;
    pub const scroll_bar_to_bottom: Type = 7;
    pub const scroll_bar_end_scroll: Type = 8;
    pub const scroll_bar_move_ratio: Type = 9;
    pub const scroll_bar_before_handle: Type = 10;
    pub const scroll_bar_horizontal_handle: Type = 11;
    pub const scroll_bar_after_handle: Type = 12;
    pub const scroll_bar_left_arrow: Type = 13;
    pub const scroll_bar_right_arrow: Type = 14;
    pub const scroll_bar_to_leftmost: Type = 15;
    pub const scroll_bar_to_rightmost: Type = 16;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum output_method {
    output_initial = 0,
    output_termcap = 1,
    output_x_window = 2,
    output_msdos_raw = 3,
    output_w32 = 4,
    output_ns = 5,
    output_wr = 6,
}
pub mod event_kind {
    pub type Type = u32;
    pub const NO_EVENT: Type = 0;
    pub const ASCII_KEYSTROKE_EVENT: Type = 1;
    pub const MULTIBYTE_CHAR_KEYSTROKE_EVENT: Type = 2;
    pub const NON_ASCII_KEYSTROKE_EVENT: Type = 3;
    pub const TIMER_EVENT: Type = 4;
    pub const MOUSE_CLICK_EVENT: Type = 5;
    pub const WHEEL_EVENT: Type = 6;
    pub const HORIZ_WHEEL_EVENT: Type = 7;
    pub const SCROLL_BAR_CLICK_EVENT: Type = 8;
    pub const HORIZONTAL_SCROLL_BAR_CLICK_EVENT: Type = 9;
    pub const SELECTION_REQUEST_EVENT: Type = 10;
    pub const SELECTION_CLEAR_EVENT: Type = 11;
    pub const DELETE_WINDOW_EVENT: Type = 12;
    pub const MENU_BAR_EVENT: Type = 13;
    pub const ICONIFY_EVENT: Type = 14;
    pub const DEICONIFY_EVENT: Type = 15;
    pub const MENU_BAR_ACTIVATE_EVENT: Type = 16;
    pub const DRAG_N_DROP_EVENT: Type = 17;
    pub const USER_SIGNAL_EVENT: Type = 18;
    pub const HELP_EVENT: Type = 19;
    pub const TAB_BAR_EVENT: Type = 20;
    pub const TOOL_BAR_EVENT: Type = 21;
    pub const FOCUS_IN_EVENT: Type = 22;
    pub const FOCUS_OUT_EVENT: Type = 23;
    pub const MOVE_FRAME_EVENT: Type = 24;
    pub const SELECT_WINDOW_EVENT: Type = 25;
    pub const SAVE_SESSION_EVENT: Type = 26;
    pub const DBUS_EVENT: Type = 27;
    pub const THREAD_EVENT: Type = 28;
    pub const CONFIG_CHANGED_EVENT: Type = 29;
    pub const FILE_NOTIFY_EVENT: Type = 30;
}
pub mod _bindgen_ty_51 {
    pub type Type = u32;
    pub const EVENT_KIND_WIDTH: Type = 16;
}
#[repr(C)]
pub struct input_event {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub code: ::libc::c_uint,
    pub modifiers: ::libc::c_uint,
    pub x: Lisp_Object,
    pub y: Lisp_Object,
    pub timestamp: Time,
    pub frame_or_window: Lisp_Object,
    pub arg: Lisp_Object,
}
#[test]
fn bindgen_test_layout_input_event() {
    assert_eq!(
        ::std::mem::size_of::<input_event>(),
        56usize,
        concat!("Size of: ", stringify!(input_event))
    );
    assert_eq!(
        ::std::mem::align_of::<input_event>(),
        8usize,
        concat!("Alignment of ", stringify!(input_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<input_event>())).code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(input_event),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<input_event>())).modifiers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(input_event),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<input_event>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(input_event),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<input_event>())).y as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(input_event),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<input_event>())).timestamp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(input_event),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<input_event>())).frame_or_window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(input_event),
            "::",
            stringify!(frame_or_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<input_event>())).arg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(input_event),
            "::",
            stringify!(arg)
        )
    );
}
impl Default for input_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl input_event {
    #[inline]
    pub fn kind(&self) -> event_kind::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: event_kind::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn part(&self) -> scroll_bar_part::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_part(&mut self, val: scroll_bar_part::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        kind: event_kind::Type,
        part: scroll_bar_part::Type,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let part: u32 = unsafe { ::std::mem::transmute(part) };
            part as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod _bindgen_ty_52 {
    pub type Type = u32;
    pub const up_modifier: Type = 1;
    pub const down_modifier: Type = 2;
    pub const drag_modifier: Type = 4;
    pub const click_modifier: Type = 8;
    pub const double_modifier: Type = 16;
    pub const triple_modifier: Type = 32;
    pub const alt_modifier: Type = 4194304;
    pub const super_modifier: Type = 8388608;
    pub const hyper_modifier: Type = 16777216;
    pub const shift_modifier: Type = 33554432;
    pub const ctrl_modifier: Type = 67108864;
    pub const meta_modifier: Type = 134217728;
}
pub mod Gpm_Etype {
    pub type Type = u32;
    pub const GPM_MOVE: Type = 1;
    pub const GPM_DRAG: Type = 2;
    pub const GPM_DOWN: Type = 4;
    pub const GPM_UP: Type = 8;
    pub const GPM_SINGLE: Type = 16;
    pub const GPM_DOUBLE: Type = 32;
    pub const GPM_TRIPLE: Type = 64;
    pub const GPM_MFLAG: Type = 128;
    pub const GPM_HARD: Type = 256;
    pub const GPM_ENTER: Type = 512;
    pub const GPM_LEAVE: Type = 1024;
}
pub mod Gpm_Margin {
    pub type Type = u32;
    pub const GPM_TOP: Type = 1;
    pub const GPM_BOT: Type = 2;
    pub const GPM_LFT: Type = 4;
    pub const GPM_RGT: Type = 8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gpm_Event {
    pub buttons: ::libc::c_uchar,
    pub modifiers: ::libc::c_uchar,
    pub vc: ::libc::c_ushort,
    pub dx: ::libc::c_short,
    pub dy: ::libc::c_short,
    pub x: ::libc::c_short,
    pub y: ::libc::c_short,
    pub type_: Gpm_Etype::Type,
    pub clicks: ::libc::c_int,
    pub margin: Gpm_Margin::Type,
    pub wdx: ::libc::c_short,
    pub wdy: ::libc::c_short,
}
#[test]
fn bindgen_test_layout_Gpm_Event() {
    assert_eq!(
        ::std::mem::size_of::<Gpm_Event>(),
        28usize,
        concat!("Size of: ", stringify!(Gpm_Event))
    );
    assert_eq!(
        ::std::mem::align_of::<Gpm_Event>(),
        4usize,
        concat!("Alignment of ", stringify!(Gpm_Event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Event>())).buttons as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Event),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Event>())).modifiers as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Event),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Event>())).vc as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Event),
            "::",
            stringify!(vc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Event>())).dx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Event),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Event>())).dy as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Event),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Event>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Event),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Event>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Event),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Event>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Event>())).clicks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Event),
            "::",
            stringify!(clicks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Event>())).margin as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Event),
            "::",
            stringify!(margin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Event>())).wdx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Event),
            "::",
            stringify!(wdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Event>())).wdy as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Event),
            "::",
            stringify!(wdy)
        )
    );
}
impl Default for Gpm_Event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Gpm_Handler = ::std::option::Option<
    unsafe extern "C" fn(event: *mut Gpm_Event, clientdata: *mut ::libc::c_void) -> ::libc::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Gpm_Connect {
    pub eventMask: ::libc::c_ushort,
    pub defaultMask: ::libc::c_ushort,
    pub minMod: ::libc::c_ushort,
    pub maxMod: ::libc::c_ushort,
    pub pid: ::libc::c_int,
    pub vc: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_Gpm_Connect() {
    assert_eq!(
        ::std::mem::size_of::<Gpm_Connect>(),
        16usize,
        concat!("Size of: ", stringify!(Gpm_Connect))
    );
    assert_eq!(
        ::std::mem::align_of::<Gpm_Connect>(),
        4usize,
        concat!("Alignment of ", stringify!(Gpm_Connect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Connect>())).eventMask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Connect),
            "::",
            stringify!(eventMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Connect>())).defaultMask as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Connect),
            "::",
            stringify!(defaultMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Connect>())).minMod as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Connect),
            "::",
            stringify!(minMod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Connect>())).maxMod as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Connect),
            "::",
            stringify!(maxMod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Connect>())).pid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Connect),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Connect>())).vc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Connect),
            "::",
            stringify!(vc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gpm_Roi {
    pub xMin: ::libc::c_short,
    pub xMax: ::libc::c_short,
    pub yMin: ::libc::c_short,
    pub yMax: ::libc::c_short,
    pub minMod: ::libc::c_ushort,
    pub maxMod: ::libc::c_ushort,
    pub eventMask: ::libc::c_ushort,
    pub owned: ::libc::c_ushort,
    pub handler: Gpm_Handler,
    pub clientdata: *mut ::libc::c_void,
    pub prev: *mut Gpm_Roi,
    pub next: *mut Gpm_Roi,
}
#[test]
fn bindgen_test_layout_Gpm_Roi() {
    assert_eq!(
        ::std::mem::size_of::<Gpm_Roi>(),
        48usize,
        concat!("Size of: ", stringify!(Gpm_Roi))
    );
    assert_eq!(
        ::std::mem::align_of::<Gpm_Roi>(),
        8usize,
        concat!("Alignment of ", stringify!(Gpm_Roi))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Roi>())).xMin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Roi),
            "::",
            stringify!(xMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Roi>())).xMax as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Roi),
            "::",
            stringify!(xMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Roi>())).yMin as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Roi),
            "::",
            stringify!(yMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Roi>())).yMax as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Roi),
            "::",
            stringify!(yMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Roi>())).minMod as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Roi),
            "::",
            stringify!(minMod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Roi>())).maxMod as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Roi),
            "::",
            stringify!(maxMod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Roi>())).eventMask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Roi),
            "::",
            stringify!(eventMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Roi>())).owned as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Roi),
            "::",
            stringify!(owned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Roi>())).handler as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Roi),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Roi>())).clientdata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Roi),
            "::",
            stringify!(clientdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Roi>())).prev as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Roi),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gpm_Roi>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Gpm_Roi),
            "::",
            stringify!(next)
        )
    );
}
impl Default for Gpm_Roi {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}gpm_flag"]
    pub static mut gpm_flag: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}gpm_ctlfd"]
    pub static mut gpm_ctlfd: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}gpm_fd"]
    pub static mut gpm_fd: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}gpm_hflag"]
    pub static mut gpm_hflag: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}gpm_morekeys"]
    pub static mut gpm_morekeys: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}gpm_zerobased"]
    pub static mut gpm_zerobased: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}gpm_visiblepointer"]
    pub static mut gpm_visiblepointer: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}gpm_mx"]
    pub static mut gpm_mx: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}gpm_my"]
    pub static mut gpm_my: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}gpm_timeout"]
    pub static mut gpm_timeout: timeval;
}
extern "C" {
    #[link_name = "\u{1}_gpm_buf"]
    pub static mut _gpm_buf: [::libc::c_uchar; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_gpm_arg"]
    pub static mut _gpm_arg: *mut ::libc::c_ushort;
}
extern "C" {
    #[link_name = "\u{1}gpm_handler"]
    pub static mut gpm_handler: Gpm_Handler;
}
extern "C" {
    #[link_name = "\u{1}gpm_data"]
    pub static mut gpm_data: *mut ::libc::c_void;
}
extern "C" {
    #[link_name = "\u{1}gpm_roi_handler"]
    pub static mut gpm_roi_handler: Gpm_Handler;
}
extern "C" {
    #[link_name = "\u{1}gpm_roi_data"]
    pub static mut gpm_roi_data: *mut ::libc::c_void;
}
extern "C" {
    #[link_name = "\u{1}gpm_roi"]
    pub static mut gpm_roi: *mut Gpm_Roi;
}
extern "C" {
    #[link_name = "\u{1}gpm_current_roi"]
    pub static mut gpm_current_roi: *mut Gpm_Roi;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct winsize {
    pub ws_row: ::libc::c_ushort,
    pub ws_col: ::libc::c_ushort,
    pub ws_xpixel: ::libc::c_ushort,
    pub ws_ypixel: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_winsize() {
    assert_eq!(
        ::std::mem::size_of::<winsize>(),
        8usize,
        concat!("Size of: ", stringify!(winsize))
    );
    assert_eq!(
        ::std::mem::align_of::<winsize>(),
        2usize,
        concat!("Alignment of ", stringify!(winsize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<winsize>())).ws_row as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(winsize),
            "::",
            stringify!(ws_row)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<winsize>())).ws_col as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(winsize),
            "::",
            stringify!(ws_col)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<winsize>())).ws_xpixel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(winsize),
            "::",
            stringify!(ws_xpixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<winsize>())).ws_ypixel as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(winsize),
            "::",
            stringify!(ws_ypixel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct termio {
    pub c_iflag: ::libc::c_ushort,
    pub c_oflag: ::libc::c_ushort,
    pub c_cflag: ::libc::c_ushort,
    pub c_lflag: ::libc::c_ushort,
    pub c_line: ::libc::c_uchar,
    pub c_cc: [::libc::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_termio() {
    assert_eq!(
        ::std::mem::size_of::<termio>(),
        18usize,
        concat!("Size of: ", stringify!(termio))
    );
    assert_eq!(
        ::std::mem::align_of::<termio>(),
        2usize,
        concat!("Alignment of ", stringify!(termio))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termio>())).c_iflag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(termio),
            "::",
            stringify!(c_iflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termio>())).c_oflag as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(termio),
            "::",
            stringify!(c_oflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termio>())).c_cflag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(termio),
            "::",
            stringify!(c_cflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termio>())).c_lflag as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(termio),
            "::",
            stringify!(c_lflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termio>())).c_line as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(termio),
            "::",
            stringify!(c_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termio>())).c_cc as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(termio),
            "::",
            stringify!(c_cc)
        )
    );
}
extern "C" {
    pub fn ioctl(__fd: ::libc::c_int, __request: ::libc::c_ulong, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn Gpm_Open(arg1: *mut Gpm_Connect, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn Gpm_Close() -> ::libc::c_int;
}
extern "C" {
    pub fn Gpm_GetEvent(arg1: *mut Gpm_Event) -> ::libc::c_int;
}
extern "C" {
    pub fn Gpm_CharsQueued() -> ::libc::c_int;
}
extern "C" {
    pub fn Gpm_Getc(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn Gpm_Repeat(millisec: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn Gpm_FitValuesM(
        x: *mut ::libc::c_int,
        y: *mut ::libc::c_int,
        margin: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}gpm_consolefd"]
    pub static mut gpm_consolefd: ::libc::c_int;
}
extern "C" {
    pub fn Gpm_HandleRoi(event: *mut Gpm_Event, clientdata: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn Gpm_PushRoi(
        x: ::libc::c_int,
        y: ::libc::c_int,
        X: ::libc::c_int,
        Y: ::libc::c_int,
        mask: ::libc::c_int,
        fun: Gpm_Handler,
        xtradata: *mut ::libc::c_void,
    ) -> *mut Gpm_Roi;
}
extern "C" {
    pub fn Gpm_PopRoi(which: *mut Gpm_Roi) -> *mut Gpm_Roi;
}
extern "C" {
    pub fn Gpm_RaiseRoi(which: *mut Gpm_Roi, before: *mut Gpm_Roi) -> *mut Gpm_Roi;
}
extern "C" {
    pub fn Gpm_LowerRoi(which: *mut Gpm_Roi, after: *mut Gpm_Roi) -> *mut Gpm_Roi;
}
extern "C" {
    pub fn Gpm_Wgetch() -> ::libc::c_int;
}
extern "C" {
    pub fn Gpm_GetLibVersion(where_: *mut ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn Gpm_GetServerVersion(where_: *mut ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn Gpm_GetSnapshot(ePtr: *mut Gpm_Event) -> ::libc::c_int;
}
extern "C" {
    pub fn Gpm_get_console() -> *mut ::libc::c_char;
}
extern "C" {
    pub fn Gpm_x_high_y(base: ::libc::c_int, pot_y: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn Gpm_cnt_digits(number: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn gpm_oops(
        line: ::libc::c_int,
        file: *const ::libc::c_char,
        text: *const ::libc::c_char,
        ...
    );
}
extern "C" {
    pub fn gpm_report(
        line: ::libc::c_int,
        file: *const ::libc::c_char,
        stat: ::libc::c_int,
        text: *const ::libc::c_char,
        ...
    );
}
extern "C" {
    pub fn handle_one_term_event(
        arg1: *mut tty_display_info,
        arg2: *mut Gpm_Event,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn term_mouse_moveto(arg1: ::libc::c_int, arg2: ::libc::c_int);
}
extern "C" {
    #[link_name = "\u{1}gpm_tty"]
    pub static mut gpm_tty: *mut tty_display_info;
}
#[repr(C)]
pub struct terminal {
    pub header: vectorlike_header,
    pub param_alist: Lisp_Object,
    pub charset_list: Lisp_Object,
    pub Vselection_alist: Lisp_Object,
    pub glyph_code_table: Lisp_Object,
    pub next_terminal: *mut terminal,
    pub id: ::libc::c_int,
    pub reference_count: ::libc::c_int,
    pub type_: output_method,
    pub name: *mut ::libc::c_char,
    pub kboard: *mut kboard,
    pub image_cache: *mut image_cache,
    pub display_info: terminal_display_info,
    pub terminal_coding: *mut coding_system,
    pub keyboard_coding: *mut coding_system,
    pub rif: *mut redisplay_interface,
    pub cursor_to_hook: ::std::option::Option<
        unsafe extern "C" fn(f: *mut frame, vpos: ::libc::c_int, hpos: ::libc::c_int),
    >,
    pub raw_cursor_to_hook: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut frame, arg2: ::libc::c_int, arg3: ::libc::c_int),
    >,
    pub clear_to_end_hook: ::std::option::Option<unsafe extern "C" fn(arg1: *mut frame)>,
    pub clear_frame_hook: ::std::option::Option<unsafe extern "C" fn(arg1: *mut frame)>,
    pub clear_end_of_line_hook:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut frame, arg2: ::libc::c_int)>,
    pub ins_del_lines_hook: ::std::option::Option<
        unsafe extern "C" fn(f: *mut frame, arg1: ::libc::c_int, arg2: ::libc::c_int),
    >,
    pub insert_glyphs_hook:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, s: *mut glyph, n: ::libc::c_int)>,
    pub write_glyphs_hook:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, s: *mut glyph, n: ::libc::c_int)>,
    pub delete_glyphs_hook:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut frame, arg2: ::libc::c_int)>,
    pub ring_bell_hook: ::std::option::Option<unsafe extern "C" fn(f: *mut frame)>,
    pub toggle_invisible_pointer_hook:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, invisible: bool)>,
    pub reset_terminal_modes_hook: ::std::option::Option<unsafe extern "C" fn(arg1: *mut terminal)>,
    pub set_terminal_modes_hook: ::std::option::Option<unsafe extern "C" fn(arg1: *mut terminal)>,
    pub update_begin_hook: ::std::option::Option<unsafe extern "C" fn(arg1: *mut frame)>,
    pub update_end_hook: ::std::option::Option<unsafe extern "C" fn(arg1: *mut frame)>,
    pub set_terminal_window_hook:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut frame, arg2: ::libc::c_int)>,
    pub defined_color_hook: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut frame,
            color_name: *const ::libc::c_char,
            color_def: *mut Emacs_Color,
            alloc: bool,
            makeIndex: bool,
        ) -> bool,
    >,
    pub query_frame_background_color:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, bgcolor: *mut Emacs_Color)>,
    pub query_colors: ::std::option::Option<
        unsafe extern "C" fn(f: *mut frame, colors: *mut Emacs_Color, ncolors: ::libc::c_int),
    >,
    pub mouse_position_hook: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut *mut frame,
            arg1: ::libc::c_int,
            bar_window: *mut Lisp_Object,
            part: *mut scroll_bar_part::Type,
            x: *mut Lisp_Object,
            y: *mut Lisp_Object,
            arg2: *mut Time,
        ),
    >,
    pub get_focus_frame: ::std::option::Option<unsafe extern "C" fn(f: *mut frame) -> Lisp_Object>,
    pub focus_frame_hook:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, noactivate: bool)>,
    pub frame_rehighlight_hook: ::std::option::Option<unsafe extern "C" fn(arg1: *mut frame)>,
    pub frame_raise_lower_hook:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, raise_flag: bool)>,
    pub frame_visible_invisible_hook:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, visible: bool)>,
    pub fullscreen_hook: ::std::option::Option<unsafe extern "C" fn(f: *mut frame)>,
    pub iconify_frame_hook: ::std::option::Option<unsafe extern "C" fn(f: *mut frame)>,
    pub set_window_size_hook: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut frame,
            change_gravity: bool,
            width: ::libc::c_int,
            height: ::libc::c_int,
            pixelwise: bool,
        ),
    >,
    pub set_frame_offset_hook: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut frame,
            xoff: ::libc::c_int,
            yoff: ::libc::c_int,
            change_gravity: ::libc::c_int,
        ),
    >,
    pub set_frame_alpha_hook: ::std::option::Option<unsafe extern "C" fn(f: *mut frame)>,
    pub set_new_font_hook: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut frame,
            font_object: Lisp_Object,
            fontset: ::libc::c_int,
        ) -> Lisp_Object,
    >,
    pub set_bitmap_icon_hook:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, file: Lisp_Object) -> bool>,
    pub implicit_set_name_hook: ::std::option::Option<
        unsafe extern "C" fn(f: *mut frame, arg: Lisp_Object, oldval: Lisp_Object),
    >,
    pub menu_show_hook: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut frame,
            x: ::libc::c_int,
            y: ::libc::c_int,
            menuflags: ::libc::c_int,
            title: Lisp_Object,
            error_name: *mut *const ::libc::c_char,
        ) -> Lisp_Object,
    >,
    pub popup_dialog_hook: ::std::option::Option<
        unsafe extern "C" fn(
            f: *mut frame,
            header: Lisp_Object,
            contents: Lisp_Object,
        ) -> Lisp_Object,
    >,
    pub change_tab_bar_height_hook:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, height: ::libc::c_int)>,
    pub change_tool_bar_height_hook:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, height: ::libc::c_int)>,
    pub set_vertical_scroll_bar_hook: ::std::option::Option<
        unsafe extern "C" fn(
            window: *mut window,
            portion: ::libc::c_int,
            whole: ::libc::c_int,
            position: ::libc::c_int,
        ),
    >,
    pub set_horizontal_scroll_bar_hook: ::std::option::Option<
        unsafe extern "C" fn(
            window: *mut window,
            portion: ::libc::c_int,
            whole: ::libc::c_int,
            position: ::libc::c_int,
        ),
    >,
    pub set_scroll_bar_default_width_hook:
        ::std::option::Option<unsafe extern "C" fn(frame: *mut frame)>,
    pub set_scroll_bar_default_height_hook:
        ::std::option::Option<unsafe extern "C" fn(frame: *mut frame)>,
    pub condemn_scroll_bars_hook: ::std::option::Option<unsafe extern "C" fn(frame: *mut frame)>,
    pub redeem_scroll_bar_hook: ::std::option::Option<unsafe extern "C" fn(window: *mut window)>,
    pub judge_scroll_bars_hook: ::std::option::Option<unsafe extern "C" fn(FRAME: *mut frame)>,
    pub read_socket_hook: ::std::option::Option<
        unsafe extern "C" fn(terminal: *mut terminal, hold_quit: *mut input_event) -> ::libc::c_int,
    >,
    pub frame_up_to_date_hook: ::std::option::Option<unsafe extern "C" fn(arg1: *mut frame)>,
    pub buffer_flipping_unblocked_hook:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut frame)>,
    pub get_string_resource_hook: ::std::option::Option<
        unsafe extern "C" fn(
            rdb: *mut ::libc::c_void,
            name: *const ::libc::c_char,
            class: *const ::libc::c_char,
        ) -> *const ::libc::c_char,
    >,
    pub free_pixmap:
        ::std::option::Option<unsafe extern "C" fn(f: *mut frame, pixmap: Emacs_Pixmap)>,
    pub delete_frame_hook: ::std::option::Option<unsafe extern "C" fn(arg1: *mut frame)>,
    pub delete_terminal_hook: ::std::option::Option<unsafe extern "C" fn(arg1: *mut terminal)>,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union terminal_display_info {
    pub tty: *mut tty_display_info,
    pub x: *mut x_display_info,
    pub w32: *mut w32_display_info,
    pub ns: *mut ns_display_info,
    pub wr: *mut wr_display_info,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_terminal_display_info() {
    assert_eq!(
        ::std::mem::size_of::<terminal_display_info>(),
        8usize,
        concat!("Size of: ", stringify!(terminal_display_info))
    );
    assert_eq!(
        ::std::mem::align_of::<terminal_display_info>(),
        8usize,
        concat!("Alignment of ", stringify!(terminal_display_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal_display_info>())).tty as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal_display_info),
            "::",
            stringify!(tty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal_display_info>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal_display_info),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal_display_info>())).w32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal_display_info),
            "::",
            stringify!(w32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal_display_info>())).ns as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal_display_info),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal_display_info>())).wr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal_display_info),
            "::",
            stringify!(wr)
        )
    );
}
impl Default for terminal_display_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_terminal() {
    assert_eq!(
        ::std::mem::size_of::<terminal>(),
        528usize,
        concat!("Size of: ", stringify!(terminal))
    );
    assert_eq!(
        ::std::mem::align_of::<terminal>(),
        8usize,
        concat!("Alignment of ", stringify!(terminal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).param_alist as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(param_alist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).charset_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(charset_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).Vselection_alist as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(Vselection_alist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).glyph_code_table as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(glyph_code_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).next_terminal as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(next_terminal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).reference_count as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(reference_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).type_ as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).name as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).kboard as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(kboard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).image_cache as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(image_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).display_info as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(display_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).terminal_coding as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(terminal_coding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).keyboard_coding as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(keyboard_coding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).rif as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(rif)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).cursor_to_hook as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(cursor_to_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).raw_cursor_to_hook as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(raw_cursor_to_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).clear_to_end_hook as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(clear_to_end_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).clear_frame_hook as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(clear_frame_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).clear_end_of_line_hook as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(clear_end_of_line_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).ins_del_lines_hook as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(ins_del_lines_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).insert_glyphs_hook as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(insert_glyphs_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).write_glyphs_hook as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(write_glyphs_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).delete_glyphs_hook as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(delete_glyphs_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).ring_bell_hook as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(ring_bell_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).toggle_invisible_pointer_hook as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(toggle_invisible_pointer_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).reset_terminal_modes_hook as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(reset_terminal_modes_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).set_terminal_modes_hook as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(set_terminal_modes_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).update_begin_hook as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(update_begin_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).update_end_hook as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(update_end_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).set_terminal_window_hook as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(set_terminal_window_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).defined_color_hook as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(defined_color_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).query_frame_background_color as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(query_frame_background_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).query_colors as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(query_colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).mouse_position_hook as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(mouse_position_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).get_focus_frame as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(get_focus_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).focus_frame_hook as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(focus_frame_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).frame_rehighlight_hook as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(frame_rehighlight_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).frame_raise_lower_hook as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(frame_raise_lower_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).frame_visible_invisible_hook as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(frame_visible_invisible_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).fullscreen_hook as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(fullscreen_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).iconify_frame_hook as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(iconify_frame_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).set_window_size_hook as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(set_window_size_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).set_frame_offset_hook as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(set_frame_offset_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).set_frame_alpha_hook as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(set_frame_alpha_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).set_new_font_hook as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(set_new_font_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).set_bitmap_icon_hook as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(set_bitmap_icon_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).implicit_set_name_hook as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(implicit_set_name_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).menu_show_hook as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(menu_show_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).popup_dialog_hook as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(popup_dialog_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).change_tab_bar_height_hook as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(change_tab_bar_height_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).change_tool_bar_height_hook as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(change_tool_bar_height_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).set_vertical_scroll_bar_hook as *const _ as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(set_vertical_scroll_bar_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).set_horizontal_scroll_bar_hook as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(set_horizontal_scroll_bar_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).set_scroll_bar_default_width_hook as *const _
                as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(set_scroll_bar_default_width_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).set_scroll_bar_default_height_hook as *const _
                as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(set_scroll_bar_default_height_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).condemn_scroll_bars_hook as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(condemn_scroll_bars_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).redeem_scroll_bar_hook as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(redeem_scroll_bar_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).judge_scroll_bars_hook as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(judge_scroll_bars_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).read_socket_hook as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(read_socket_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).frame_up_to_date_hook as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(frame_up_to_date_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).buffer_flipping_unblocked_hook as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(buffer_flipping_unblocked_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<terminal>())).get_string_resource_hook as *const _ as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(get_string_resource_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).free_pixmap as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(free_pixmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).delete_frame_hook as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(delete_frame_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<terminal>())).delete_terminal_hook as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(terminal),
            "::",
            stringify!(delete_terminal_hook)
        )
    );
}
impl Default for terminal {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn TERMINALP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn XTERMINAL(a: Lisp_Object) -> *mut terminal;
}
extern "C" {
    pub fn tset_charset_list(t: *mut terminal, val: Lisp_Object);
}
extern "C" {
    pub fn tset_selection_alist(t: *mut terminal, val: Lisp_Object);
}
extern "C" {
    #[link_name = "\u{1}terminal_list"]
    pub static mut terminal_list: *mut terminal;
}
extern "C" {
    pub fn decode_live_terminal(arg1: Lisp_Object) -> *mut terminal;
}
extern "C" {
    pub fn decode_tty_terminal(arg1: Lisp_Object) -> *mut terminal;
}
extern "C" {
    pub fn get_named_terminal(arg1: *const ::libc::c_char) -> *mut terminal;
}
extern "C" {
    pub fn create_terminal(arg1: output_method, arg2: *mut redisplay_interface) -> *mut terminal;
}
extern "C" {
    pub fn delete_terminal(arg1: *mut terminal);
}
extern "C" {
    pub fn delete_terminal_internal(arg1: *mut terminal);
}
extern "C" {
    pub fn terminal_glyph_code(arg1: *mut terminal, arg2: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}initial_terminal"]
    pub static mut initial_terminal: *mut terminal;
}
extern "C" {
    pub fn encode_terminal_code(
        arg1: *mut glyph,
        arg2: ::libc::c_int,
        arg3: *mut coding_system,
    ) -> *mut ::libc::c_uchar;
}
extern "C" {
    pub fn close_gpm(gpm_fd: ::libc::c_int);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cursor_pos {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub hpos: ::libc::c_int,
    pub vpos: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_cursor_pos() {
    assert_eq!(
        ::std::mem::size_of::<cursor_pos>(),
        16usize,
        concat!("Size of: ", stringify!(cursor_pos))
    );
    assert_eq!(
        ::std::mem::align_of::<cursor_pos>(),
        4usize,
        concat!("Alignment of ", stringify!(cursor_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cursor_pos>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cursor_pos),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cursor_pos>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cursor_pos),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cursor_pos>())).hpos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cursor_pos),
            "::",
            stringify!(hpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cursor_pos>())).vpos as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cursor_pos),
            "::",
            stringify!(vpos)
        )
    );
}
#[repr(C)]
pub struct window {
    pub header: vectorlike_header,
    pub frame: Lisp_Object,
    pub next: Lisp_Object,
    pub prev: Lisp_Object,
    pub parent: Lisp_Object,
    pub normal_lines: Lisp_Object,
    pub normal_cols: Lisp_Object,
    pub new_total: Lisp_Object,
    pub new_normal: Lisp_Object,
    pub new_pixel: Lisp_Object,
    pub contents: Lisp_Object,
    pub old_buffer: Lisp_Object,
    pub start: Lisp_Object,
    pub pointm: Lisp_Object,
    pub old_pointm: Lisp_Object,
    pub temslot: Lisp_Object,
    pub vertical_scroll_bar: Lisp_Object,
    pub vertical_scroll_bar_type: Lisp_Object,
    pub horizontal_scroll_bar: Lisp_Object,
    pub horizontal_scroll_bar_type: Lisp_Object,
    pub display_table: Lisp_Object,
    pub dedicated: Lisp_Object,
    pub redisplay_end_trigger: Lisp_Object,
    pub combination_limit: Lisp_Object,
    pub window_parameters: Lisp_Object,
    pub mode_line_help_echo: Lisp_Object,
    pub current_matrix: *mut glyph_matrix,
    pub desired_matrix: *mut glyph_matrix,
    pub prev_buffers: Lisp_Object,
    pub next_buffers: Lisp_Object,
    pub use_time: EMACS_INT,
    pub sequence_number: EMACS_INT,
    pub change_stamp: ::libc::c_int,
    pub pixel_left: ::libc::c_int,
    pub pixel_top: ::libc::c_int,
    pub left_col: ::libc::c_int,
    pub top_line: ::libc::c_int,
    pub pixel_width: ::libc::c_int,
    pub pixel_height: ::libc::c_int,
    pub old_pixel_width: ::libc::c_int,
    pub old_pixel_height: ::libc::c_int,
    pub old_body_pixel_width: ::libc::c_int,
    pub old_body_pixel_height: ::libc::c_int,
    pub total_cols: ::libc::c_int,
    pub total_lines: ::libc::c_int,
    pub hscroll: isize,
    pub min_hscroll: isize,
    pub hscroll_whole: isize,
    pub last_modified: modiff_count,
    pub last_overlay_modified: modiff_count,
    pub last_point: isize,
    pub base_line_number: isize,
    pub base_line_pos: isize,
    pub column_number_displayed: isize,
    pub nrows_scale_factor: ::libc::c_int,
    pub ncols_scale_factor: ::libc::c_int,
    pub cursor: cursor_pos,
    pub phys_cursor: cursor_pos,
    pub output_cursor: cursor_pos,
    pub last_cursor_vpos: ::libc::c_int,
    pub phys_cursor_type: text_cursor_kinds::Type,
    pub phys_cursor_width: ::libc::c_int,
    pub phys_cursor_ascent: ::libc::c_int,
    pub phys_cursor_height: ::libc::c_int,
    pub left_fringe_width: ::libc::c_int,
    pub right_fringe_width: ::libc::c_int,
    pub left_margin_cols: ::libc::c_int,
    pub right_margin_cols: ::libc::c_int,
    pub scroll_bar_width: ::libc::c_int,
    pub scroll_bar_height: ::libc::c_int,
    pub mode_line_height: ::libc::c_int,
    pub header_line_height: ::libc::c_int,
    pub tab_line_height: ::libc::c_int,
    pub window_end_pos: isize,
    pub window_end_vpos: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub vscroll: ::libc::c_int,
    pub window_end_bytepos: isize,
}
#[test]
fn bindgen_test_layout_window() {
    assert_eq!(
        ::std::mem::size_of::<window>(),
        528usize,
        concat!("Size of: ", stringify!(window))
    );
    assert_eq!(
        ::std::mem::align_of::<window>(),
        8usize,
        concat!("Alignment of ", stringify!(window))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).frame as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).normal_lines as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(normal_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).normal_cols as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(normal_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).new_total as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(new_total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).new_normal as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(new_normal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).new_pixel as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(new_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).contents as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).old_buffer as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(old_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).start as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).pointm as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(pointm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).old_pointm as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(old_pointm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).temslot as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(temslot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).vertical_scroll_bar as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(vertical_scroll_bar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).vertical_scroll_bar_type as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(vertical_scroll_bar_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).horizontal_scroll_bar as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(horizontal_scroll_bar)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<window>())).horizontal_scroll_bar_type as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(horizontal_scroll_bar_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).display_table as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(display_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).dedicated as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(dedicated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).redisplay_end_trigger as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(redisplay_end_trigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).combination_limit as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(combination_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).window_parameters as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(window_parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).mode_line_help_echo as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(mode_line_help_echo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).current_matrix as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(current_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).desired_matrix as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(desired_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).prev_buffers as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(prev_buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).next_buffers as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(next_buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).use_time as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(use_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).sequence_number as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(sequence_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).change_stamp as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(change_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).pixel_left as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(pixel_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).pixel_top as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(pixel_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).left_col as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(left_col)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).top_line as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(top_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).pixel_width as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(pixel_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).pixel_height as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(pixel_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).old_pixel_width as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(old_pixel_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).old_pixel_height as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(old_pixel_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).old_body_pixel_width as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(old_body_pixel_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).old_body_pixel_height as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(old_body_pixel_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).total_cols as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(total_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).total_lines as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(total_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).hscroll as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(hscroll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).min_hscroll as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(min_hscroll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).hscroll_whole as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(hscroll_whole)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).last_modified as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(last_modified)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).last_overlay_modified as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(last_overlay_modified)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).last_point as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(last_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).base_line_number as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(base_line_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).base_line_pos as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(base_line_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).column_number_displayed as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(column_number_displayed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).nrows_scale_factor as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(nrows_scale_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).ncols_scale_factor as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(ncols_scale_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).cursor as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).phys_cursor as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(phys_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).output_cursor as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(output_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).last_cursor_vpos as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(last_cursor_vpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).phys_cursor_type as *const _ as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(phys_cursor_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).phys_cursor_width as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(phys_cursor_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).phys_cursor_ascent as *const _ as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(phys_cursor_ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).phys_cursor_height as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(phys_cursor_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).left_fringe_width as *const _ as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(left_fringe_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).right_fringe_width as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(right_fringe_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).left_margin_cols as *const _ as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(left_margin_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).right_margin_cols as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(right_margin_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).scroll_bar_width as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(scroll_bar_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).scroll_bar_height as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(scroll_bar_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).mode_line_height as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(mode_line_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).header_line_height as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(header_line_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).tab_line_height as *const _ as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(tab_line_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).window_end_pos as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(window_end_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).window_end_vpos as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(window_end_vpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).vscroll as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(vscroll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<window>())).window_end_bytepos as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(window),
            "::",
            stringify!(window_end_bytepos)
        )
    );
}
impl Default for window {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl window {
    #[inline]
    pub fn mini(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mini(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn horizontal(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_horizontal(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_mode_line(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_update_mode_line(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_had_star(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_last_had_star(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn start_at_line_beg(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_start_at_line_beg(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_start(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_start(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn optional_new_start(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_optional_new_start(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phys_cursor_on_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_phys_cursor_on_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cursor_off_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cursor_off_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_cursor_off_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_last_cursor_off_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn must_be_updated_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_must_be_updated_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pseudo_window_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pseudo_window_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fringes_outside_margins(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fringes_outside_margins(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fringes_persistent(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fringes_persistent(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scroll_bars_persistent(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scroll_bars_persistent(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn window_end_valid(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_window_end_valid(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redisplay(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redisplay(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn suspend_auto_hscroll(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_suspend_auto_hscroll(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mini: bool_bf,
        horizontal: bool_bf,
        update_mode_line: bool_bf,
        last_had_star: bool_bf,
        start_at_line_beg: bool_bf,
        force_start: bool_bf,
        optional_new_start: bool_bf,
        phys_cursor_on_p: bool_bf,
        cursor_off_p: bool_bf,
        last_cursor_off_p: bool_bf,
        must_be_updated_p: bool_bf,
        pseudo_window_p: bool_bf,
        fringes_outside_margins: bool_bf,
        fringes_persistent: bool_bf,
        scroll_bars_persistent: bool_bf,
        window_end_valid: bool_bf,
        redisplay: bool_bf,
        suspend_auto_hscroll: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mini: u8 = unsafe { ::std::mem::transmute(mini) };
            mini as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let horizontal: u8 = unsafe { ::std::mem::transmute(horizontal) };
            horizontal as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let update_mode_line: u8 = unsafe { ::std::mem::transmute(update_mode_line) };
            update_mode_line as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let last_had_star: u8 = unsafe { ::std::mem::transmute(last_had_star) };
            last_had_star as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let start_at_line_beg: u8 = unsafe { ::std::mem::transmute(start_at_line_beg) };
            start_at_line_beg as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let force_start: u8 = unsafe { ::std::mem::transmute(force_start) };
            force_start as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let optional_new_start: u8 = unsafe { ::std::mem::transmute(optional_new_start) };
            optional_new_start as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let phys_cursor_on_p: u8 = unsafe { ::std::mem::transmute(phys_cursor_on_p) };
            phys_cursor_on_p as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cursor_off_p: u8 = unsafe { ::std::mem::transmute(cursor_off_p) };
            cursor_off_p as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let last_cursor_off_p: u8 = unsafe { ::std::mem::transmute(last_cursor_off_p) };
            last_cursor_off_p as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let must_be_updated_p: u8 = unsafe { ::std::mem::transmute(must_be_updated_p) };
            must_be_updated_p as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let pseudo_window_p: u8 = unsafe { ::std::mem::transmute(pseudo_window_p) };
            pseudo_window_p as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fringes_outside_margins: u8 =
                unsafe { ::std::mem::transmute(fringes_outside_margins) };
            fringes_outside_margins as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fringes_persistent: u8 = unsafe { ::std::mem::transmute(fringes_persistent) };
            fringes_persistent as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scroll_bars_persistent: u8 =
                unsafe { ::std::mem::transmute(scroll_bars_persistent) };
            scroll_bars_persistent as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let window_end_valid: u8 = unsafe { ::std::mem::transmute(window_end_valid) };
            window_end_valid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let redisplay: u8 = unsafe { ::std::mem::transmute(redisplay) };
            redisplay as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let suspend_auto_hscroll: u8 = unsafe { ::std::mem::transmute(suspend_auto_hscroll) };
            suspend_auto_hscroll as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn WINDOWP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_WINDOW(x: Lisp_Object);
}
extern "C" {
    pub fn XWINDOW(a: Lisp_Object) -> *mut window;
}
extern "C" {
    pub fn wset_frame(w: *mut window, val: Lisp_Object);
}
extern "C" {
    pub fn wset_next(w: *mut window, val: Lisp_Object);
}
extern "C" {
    pub fn wset_prev(w: *mut window, val: Lisp_Object);
}
extern "C" {
    pub fn wset_redisplay_end_trigger(w: *mut window, val: Lisp_Object);
}
extern "C" {
    pub fn wset_mode_line_help_echo(w: *mut window, val: Lisp_Object);
}
extern "C" {
    pub fn wset_new_pixel(w: *mut window, val: Lisp_Object);
}
extern "C" {
    pub fn wset_vertical_scroll_bar(w: *mut window, val: Lisp_Object);
}
extern "C" {
    pub fn wset_horizontal_scroll_bar(w: *mut window, val: Lisp_Object);
}
extern "C" {
    pub fn wset_horizontal_scroll_bar_type(w: *mut window, val: Lisp_Object);
}
extern "C" {
    pub fn wset_prev_buffers(w: *mut window, val: Lisp_Object);
}
extern "C" {
    pub fn wset_next_buffers(w: *mut window, val: Lisp_Object);
}
extern "C" {
    #[link_name = "\u{1}selected_window"]
    pub static mut selected_window: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}window_select_count"]
    pub static mut window_select_count: EMACS_INT;
}
extern "C" {
    #[link_name = "\u{1}minibuf_window"]
    pub static mut minibuf_window: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}minibuf_selected_window"]
    pub static mut minibuf_selected_window: Lisp_Object;
}
extern "C" {
    pub fn make_window() -> Lisp_Object;
}
extern "C" {
    pub fn window_from_coordinates(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: *mut window_part::Type,
        arg5: bool,
        arg6: bool,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn resize_frame_windows(arg1: *mut frame, arg2: ::libc::c_int, arg3: bool);
}
extern "C" {
    pub fn restore_window_configuration(arg1: Lisp_Object);
}
extern "C" {
    pub fn delete_all_child_windows(arg1: Lisp_Object);
}
extern "C" {
    pub fn grow_mini_window(arg1: *mut window, arg2: ::libc::c_int);
}
extern "C" {
    pub fn shrink_mini_window(arg1: *mut window);
}
extern "C" {
    pub fn window_relative_x_coord(
        arg1: *mut window,
        arg2: window_part::Type,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn run_window_change_functions();
}
extern "C" {
    pub fn set_window_buffer(
        window: Lisp_Object,
        buffer: Lisp_Object,
        run_hooks_p: bool,
        keep_margins_p: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}echo_area_window"]
    pub static mut echo_area_window: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}update_mode_lines"]
    pub static mut update_mode_lines: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}windows_or_buffers_changed"]
    pub static mut windows_or_buffers_changed: ::libc::c_int;
}
extern "C" {
    pub fn wset_redisplay(w: *mut window);
}
extern "C" {
    pub fn fset_redisplay(f: *mut frame);
}
extern "C" {
    pub fn bset_redisplay(b: *mut buffer);
}
extern "C" {
    pub fn bset_update_mode_line(b: *mut buffer);
}
extern "C" {
    pub fn redisplay_other_windows();
}
extern "C" {
    pub fn get_phys_cursor_glyph(w: *mut window) -> *mut glyph;
}
extern "C" {
    #[link_name = "\u{1}Vwindow_list"]
    pub static mut Vwindow_list: Lisp_Object;
}
extern "C" {
    pub fn window_list() -> Lisp_Object;
}
extern "C" {
    pub fn window_parameter(arg1: *mut window, parameter: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn decode_live_window(arg1: Lisp_Object) -> *mut window;
}
extern "C" {
    pub fn decode_any_window(arg1: Lisp_Object) -> *mut window;
}
extern "C" {
    pub fn mark_window_cursors_off(arg1: *mut window);
}
extern "C" {
    pub fn window_wants_mode_line(arg1: *mut window) -> bool;
}
extern "C" {
    pub fn window_wants_header_line(arg1: *mut window) -> bool;
}
extern "C" {
    pub fn window_wants_tab_line(arg1: *mut window) -> bool;
}
extern "C" {
    pub fn window_internal_height(arg1: *mut window) -> ::libc::c_int;
}
extern "C" {
    pub fn window_body_width(w: *mut window, arg1: bool) -> ::libc::c_int;
}
pub mod margin_unit {
    pub type Type = u32;
    pub const MARGIN_IN_LINES: Type = 0;
    pub const MARGIN_IN_PIXELS: Type = 1;
}
extern "C" {
    pub fn window_scroll_margin(arg1: *mut window, arg2: margin_unit::Type) -> ::libc::c_int;
}
extern "C" {
    pub fn temp_output_buffer_show(arg1: Lisp_Object);
}
extern "C" {
    pub fn replace_buffer_in_windows(arg1: Lisp_Object);
}
extern "C" {
    pub fn replace_buffer_in_windows_safely(arg1: Lisp_Object);
}
extern "C" {
    pub fn sanitize_window_sizes(horizontal: Lisp_Object);
}
extern "C" {
    pub fn wset_buffer(arg1: *mut window, arg2: Lisp_Object);
}
extern "C" {
    pub fn window_outdated(arg1: *mut window) -> bool;
}
extern "C" {
    pub fn init_window_once();
}
extern "C" {
    pub fn init_window();
}
extern "C" {
    pub fn syms_of_window();
}
extern "C" {
    pub fn output_cursor_to(
        w: *mut window,
        vpos: ::libc::c_int,
        hpos: ::libc::c_int,
        y: ::libc::c_int,
        x: ::libc::c_int,
    );
}
pub mod vertical_scroll_bar_type {
    pub type Type = u32;
    pub const vertical_scroll_bar_none: Type = 0;
    pub const vertical_scroll_bar_left: Type = 1;
    pub const vertical_scroll_bar_right: Type = 2;
}
pub mod fullscreen_type {
    pub type Type = u32;
    pub const FULLSCREEN_NONE: Type = 0;
    pub const FULLSCREEN_WIDTH: Type = 1;
    pub const FULLSCREEN_HEIGHT: Type = 2;
    pub const FULLSCREEN_BOTH: Type = 3;
    pub const FULLSCREEN_MAXIMIZED: Type = 4;
}
pub mod z_group {
    pub type Type = u32;
    pub const z_group_none: Type = 0;
    pub const z_group_above: Type = 1;
    pub const z_group_below: Type = 2;
    pub const z_group_above_suspended: Type = 3;
}
pub mod internal_border_part {
    pub type Type = u32;
    pub const INTERNAL_BORDER_NONE: Type = 0;
    pub const INTERNAL_BORDER_LEFT_EDGE: Type = 1;
    pub const INTERNAL_BORDER_TOP_LEFT_CORNER: Type = 2;
    pub const INTERNAL_BORDER_TOP_EDGE: Type = 3;
    pub const INTERNAL_BORDER_TOP_RIGHT_CORNER: Type = 4;
    pub const INTERNAL_BORDER_RIGHT_EDGE: Type = 5;
    pub const INTERNAL_BORDER_BOTTOM_RIGHT_CORNER: Type = 6;
    pub const INTERNAL_BORDER_BOTTOM_EDGE: Type = 7;
    pub const INTERNAL_BORDER_BOTTOM_LEFT_CORNER: Type = 8;
}
#[repr(C)]
pub struct frame {
    pub header: vectorlike_header,
    pub name: Lisp_Object,
    pub icon_name: Lisp_Object,
    pub title: Lisp_Object,
    pub parent_frame: Lisp_Object,
    pub focus_frame: Lisp_Object,
    pub root_window: Lisp_Object,
    pub selected_window: Lisp_Object,
    pub old_selected_window: Lisp_Object,
    pub minibuffer_window: Lisp_Object,
    pub param_alist: Lisp_Object,
    pub scroll_bars: Lisp_Object,
    pub condemned_scroll_bars: Lisp_Object,
    pub menu_bar_items: Lisp_Object,
    pub face_alist: Lisp_Object,
    pub menu_bar_vector: Lisp_Object,
    pub buffer_predicate: Lisp_Object,
    pub buffer_list: Lisp_Object,
    pub buried_buffer_list: Lisp_Object,
    pub tab_bar_window: Lisp_Object,
    pub desired_tab_bar_string: Lisp_Object,
    pub current_tab_bar_string: Lisp_Object,
    pub tool_bar_window: Lisp_Object,
    pub desired_tool_bar_string: Lisp_Object,
    pub current_tool_bar_string: Lisp_Object,
    pub tab_bar_items: Lisp_Object,
    pub tool_bar_items: Lisp_Object,
    pub face_cache: *mut face_cache,
    pub last_tab_bar_item: ::libc::c_int,
    pub last_tool_bar_item: ::libc::c_int,
    pub menu_bar_items_used: ::libc::c_int,
    pub current_pool: *mut glyph_pool,
    pub desired_pool: *mut glyph_pool,
    pub desired_matrix: *mut glyph_matrix,
    pub current_matrix: *mut glyph_matrix,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize], u8>,
    pub change_stamp: ::libc::c_int,
    pub number_of_windows: isize,
    pub tab_bar_lines: ::libc::c_int,
    pub tab_bar_height: ::libc::c_int,
    pub n_tab_bar_rows: ::libc::c_int,
    pub n_tab_bar_items: ::libc::c_int,
    pub tool_bar_lines: ::libc::c_int,
    pub tool_bar_height: ::libc::c_int,
    pub n_tool_bar_rows: ::libc::c_int,
    pub n_tool_bar_items: ::libc::c_int,
    pub decode_mode_spec_buffer: *mut ::libc::c_char,
    pub insert_line_cost: *mut ::libc::c_int,
    pub delete_line_cost: *mut ::libc::c_int,
    pub insert_n_lines_cost: *mut ::libc::c_int,
    pub delete_n_lines_cost: *mut ::libc::c_int,
    pub text_cols: ::libc::c_int,
    pub text_lines: ::libc::c_int,
    pub total_cols: ::libc::c_int,
    pub total_lines: ::libc::c_int,
    pub text_width: ::libc::c_int,
    pub text_height: ::libc::c_int,
    pub new_width: ::libc::c_int,
    pub new_height: ::libc::c_int,
    pub left_pos: ::libc::c_int,
    pub top_pos: ::libc::c_int,
    pub pixel_width: ::libc::c_int,
    pub pixel_height: ::libc::c_int,
    pub win_gravity: ::libc::c_int,
    pub size_hint_flags: ::libc::c_int,
    pub border_width: ::libc::c_int,
    pub child_frame_border_width: ::libc::c_int,
    pub internal_border_width: ::libc::c_int,
    pub right_divider_width: ::libc::c_int,
    pub bottom_divider_width: ::libc::c_int,
    pub left_fringe_width: ::libc::c_int,
    pub right_fringe_width: ::libc::c_int,
    pub fringe_cols: ::libc::c_int,
    pub menu_bar_lines: ::libc::c_int,
    pub menu_bar_height: ::libc::c_int,
    pub column_width: ::libc::c_int,
    pub line_height: ::libc::c_int,
    pub terminal: *mut terminal,
    pub output_data: frame_output_data,
    pub font_driver_list: *mut font_driver_list,
    pub desired_cursor: text_cursor_kinds::Type,
    pub cursor_width: ::libc::c_int,
    pub blink_off_cursor: text_cursor_kinds::Type,
    pub blink_off_cursor_width: ::libc::c_int,
    pub config_scroll_bar_width: ::libc::c_int,
    pub config_scroll_bar_cols: ::libc::c_int,
    pub config_scroll_bar_height: ::libc::c_int,
    pub config_scroll_bar_lines: ::libc::c_int,
    pub cost_calculation_baud_rate: intmax_t,
    pub alpha: [f64; 2usize],
    pub gamma: f64,
    pub extra_line_spacing: ::libc::c_int,
    pub background_pixel: ::libc::c_ulong,
    pub foreground_pixel: ::libc::c_ulong,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union frame_output_data {
    pub tty: *mut tty_output,
    pub x: *mut x_output,
    pub w32: *mut w32_output,
    pub ns: *mut ns_output,
    pub wr: *mut wr_output,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_frame_output_data() {
    assert_eq!(
        ::std::mem::size_of::<frame_output_data>(),
        8usize,
        concat!("Size of: ", stringify!(frame_output_data))
    );
    assert_eq!(
        ::std::mem::align_of::<frame_output_data>(),
        8usize,
        concat!("Alignment of ", stringify!(frame_output_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame_output_data>())).tty as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frame_output_data),
            "::",
            stringify!(tty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame_output_data>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frame_output_data),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame_output_data>())).w32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frame_output_data),
            "::",
            stringify!(w32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame_output_data>())).ns as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frame_output_data),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame_output_data>())).wr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frame_output_data),
            "::",
            stringify!(wr)
        )
    );
}
impl Default for frame_output_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_frame() {
    assert_eq!(
        ::std::mem::size_of::<frame>(),
        584usize,
        concat!("Size of: ", stringify!(frame))
    );
    assert_eq!(
        ::std::mem::align_of::<frame>(),
        8usize,
        concat!("Alignment of ", stringify!(frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).icon_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(icon_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).title as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).parent_frame as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(parent_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).focus_frame as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(focus_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).root_window as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(root_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).selected_window as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(selected_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).old_selected_window as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(old_selected_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).minibuffer_window as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(minibuffer_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).param_alist as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(param_alist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).scroll_bars as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(scroll_bars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).condemned_scroll_bars as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(condemned_scroll_bars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).menu_bar_items as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(menu_bar_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).face_alist as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(face_alist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).menu_bar_vector as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(menu_bar_vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).buffer_predicate as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(buffer_predicate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).buffer_list as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(buffer_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).buried_buffer_list as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(buried_buffer_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).tab_bar_window as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(tab_bar_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).desired_tab_bar_string as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(desired_tab_bar_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).current_tab_bar_string as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(current_tab_bar_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).tool_bar_window as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(tool_bar_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).desired_tool_bar_string as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(desired_tool_bar_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).current_tool_bar_string as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(current_tool_bar_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).tab_bar_items as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(tab_bar_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).tool_bar_items as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(tool_bar_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).face_cache as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(face_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).last_tab_bar_item as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(last_tab_bar_item)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).last_tool_bar_item as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(last_tool_bar_item)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).menu_bar_items_used as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(menu_bar_items_used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).current_pool as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(current_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).desired_pool as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(desired_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).desired_matrix as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(desired_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).current_matrix as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(current_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).change_stamp as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(change_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).number_of_windows as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(number_of_windows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).tab_bar_lines as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(tab_bar_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).tab_bar_height as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(tab_bar_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).n_tab_bar_rows as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(n_tab_bar_rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).n_tab_bar_items as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(n_tab_bar_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).tool_bar_lines as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(tool_bar_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).tool_bar_height as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(tool_bar_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).n_tool_bar_rows as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(n_tool_bar_rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).n_tool_bar_items as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(n_tool_bar_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).decode_mode_spec_buffer as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(decode_mode_spec_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).insert_line_cost as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(insert_line_cost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).delete_line_cost as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(delete_line_cost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).insert_n_lines_cost as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(insert_n_lines_cost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).delete_n_lines_cost as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(delete_n_lines_cost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).text_cols as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(text_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).text_lines as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(text_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).total_cols as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(total_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).total_lines as *const _ as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(total_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).text_width as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(text_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).text_height as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(text_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).new_width as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(new_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).new_height as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(new_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).left_pos as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(left_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).top_pos as *const _ as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(top_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).pixel_width as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(pixel_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).pixel_height as *const _ as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(pixel_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).win_gravity as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).size_hint_flags as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(size_hint_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).border_width as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).child_frame_border_width as *const _ as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(child_frame_border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).internal_border_width as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(internal_border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).right_divider_width as *const _ as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(right_divider_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).bottom_divider_width as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(bottom_divider_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).left_fringe_width as *const _ as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(left_fringe_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).right_fringe_width as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(right_fringe_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).fringe_cols as *const _ as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(fringe_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).menu_bar_lines as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(menu_bar_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).menu_bar_height as *const _ as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(menu_bar_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).column_width as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(column_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).line_height as *const _ as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(line_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).terminal as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(terminal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).output_data as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(output_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).font_driver_list as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(font_driver_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).desired_cursor as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(desired_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).cursor_width as *const _ as usize },
        500usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(cursor_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).blink_off_cursor as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(blink_off_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).blink_off_cursor_width as *const _ as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(blink_off_cursor_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).config_scroll_bar_width as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(config_scroll_bar_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).config_scroll_bar_cols as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(config_scroll_bar_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).config_scroll_bar_height as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(config_scroll_bar_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).config_scroll_bar_lines as *const _ as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(config_scroll_bar_lines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<frame>())).cost_calculation_baud_rate as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(cost_calculation_baud_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).alpha as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).gamma as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(gamma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).extra_line_spacing as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(extra_line_spacing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).background_pixel as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(background_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frame>())).foreground_pixel as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(frame),
            "::",
            stringify!(foreground_pixel)
        )
    );
}
impl Default for frame {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl frame {
    #[inline]
    pub fn glyphs_initialized_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_glyphs_initialized_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resized_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_resized_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn default_face_done_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_default_face_done_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn already_hscrolled_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_already_hscrolled_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn updated_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_updated_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn minimize_tab_bar_window_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_minimize_tab_bar_window_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn minimize_tool_bar_window_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_minimize_tool_bar_window_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fonts_changed(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fonts_changed(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cursor_type_changed(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cursor_type_changed(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redisplay(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redisplay(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn visible(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_visible(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn iconified(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_iconified(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn garbaged(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_garbaged(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wants_modeline(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wants_modeline(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_raise(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_raise(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_lower(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_lower(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_split(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_split(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn explicit_name(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_explicit_name(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn window_change(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_window_change(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn window_state_change(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_window_state_change(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mouse_moved(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mouse_moved(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pointer_invisible(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pointer_invisible(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen_window_starts(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frozen_window_starts(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn output_method(&self) -> output_method {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_output_method(&mut self, val: output_method) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn tooltip(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tooltip(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn want_fullscreen(&self) -> fullscreen_type::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_want_fullscreen(&mut self, val: fullscreen_type::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn vertical_scroll_bar_type(&self) -> vertical_scroll_bar_type::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_vertical_scroll_bar_type(&mut self, val: vertical_scroll_bar_type::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn horizontal_scroll_bars(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_horizontal_scroll_bars(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn undecorated(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_undecorated(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn override_redirect(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_override_redirect(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_taskbar(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skip_taskbar(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_focus_on_map(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_focus_on_map(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_accept_focus(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_accept_focus(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn z_group(&self) -> z_group::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_z_group(&mut self, val: z_group::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn no_special_glyphs(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_special_glyphs(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_pixelwise(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_new_pixelwise(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_set_window_size(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_set_window_size(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn after_make_frame(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_after_make_frame(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tab_bar_redisplayed(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tab_bar_redisplayed(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tab_bar_resized(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tab_bar_resized(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tool_bar_redisplayed(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tool_bar_redisplayed(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tool_bar_resized(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tool_bar_resized(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inhibit_horizontal_resize(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inhibit_horizontal_resize(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inhibit_vertical_resize(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inhibit_vertical_resize(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn face_change(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_face_change(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inhibit_clear_image_cache(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inhibit_clear_image_cache(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        glyphs_initialized_p: bool_bf,
        resized_p: bool_bf,
        default_face_done_p: bool_bf,
        already_hscrolled_p: bool_bf,
        updated_p: bool_bf,
        minimize_tab_bar_window_p: bool_bf,
        minimize_tool_bar_window_p: bool_bf,
        fonts_changed: bool_bf,
        cursor_type_changed: bool_bf,
        redisplay: bool_bf,
        visible: ::libc::c_uint,
        iconified: bool_bf,
        garbaged: bool_bf,
        wants_modeline: bool_bf,
        auto_raise: bool_bf,
        auto_lower: bool_bf,
        no_split: bool_bf,
        explicit_name: bool_bf,
        window_change: bool_bf,
        window_state_change: bool_bf,
        mouse_moved: bool_bf,
        pointer_invisible: bool_bf,
        frozen_window_starts: bool_bf,
        output_method: output_method,
        tooltip: bool_bf,
        want_fullscreen: fullscreen_type::Type,
        vertical_scroll_bar_type: vertical_scroll_bar_type::Type,
        horizontal_scroll_bars: bool_bf,
        undecorated: bool_bf,
        override_redirect: bool_bf,
        skip_taskbar: bool_bf,
        no_focus_on_map: bool_bf,
        no_accept_focus: bool_bf,
        z_group: z_group::Type,
        no_special_glyphs: bool_bf,
        new_pixelwise: bool_bf,
        can_set_window_size: bool_bf,
        after_make_frame: bool_bf,
        tab_bar_redisplayed: bool_bf,
        tab_bar_resized: bool_bf,
        tool_bar_redisplayed: bool_bf,
        tool_bar_resized: bool_bf,
        inhibit_horizontal_resize: bool_bf,
        inhibit_vertical_resize: bool_bf,
        face_change: bool_bf,
        inhibit_clear_image_cache: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 7usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let glyphs_initialized_p: u8 = unsafe { ::std::mem::transmute(glyphs_initialized_p) };
            glyphs_initialized_p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let resized_p: u8 = unsafe { ::std::mem::transmute(resized_p) };
            resized_p as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let default_face_done_p: u8 = unsafe { ::std::mem::transmute(default_face_done_p) };
            default_face_done_p as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let already_hscrolled_p: u8 = unsafe { ::std::mem::transmute(already_hscrolled_p) };
            already_hscrolled_p as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let updated_p: u8 = unsafe { ::std::mem::transmute(updated_p) };
            updated_p as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let minimize_tab_bar_window_p: u8 =
                unsafe { ::std::mem::transmute(minimize_tab_bar_window_p) };
            minimize_tab_bar_window_p as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let minimize_tool_bar_window_p: u8 =
                unsafe { ::std::mem::transmute(minimize_tool_bar_window_p) };
            minimize_tool_bar_window_p as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let fonts_changed: u8 = unsafe { ::std::mem::transmute(fonts_changed) };
            fonts_changed as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let cursor_type_changed: u8 = unsafe { ::std::mem::transmute(cursor_type_changed) };
            cursor_type_changed as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let redisplay: u8 = unsafe { ::std::mem::transmute(redisplay) };
            redisplay as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let visible: u32 = unsafe { ::std::mem::transmute(visible) };
            visible as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let iconified: u8 = unsafe { ::std::mem::transmute(iconified) };
            iconified as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let garbaged: u8 = unsafe { ::std::mem::transmute(garbaged) };
            garbaged as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let wants_modeline: u8 = unsafe { ::std::mem::transmute(wants_modeline) };
            wants_modeline as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let auto_raise: u8 = unsafe { ::std::mem::transmute(auto_raise) };
            auto_raise as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let auto_lower: u8 = unsafe { ::std::mem::transmute(auto_lower) };
            auto_lower as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let no_split: u8 = unsafe { ::std::mem::transmute(no_split) };
            no_split as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let explicit_name: u8 = unsafe { ::std::mem::transmute(explicit_name) };
            explicit_name as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let window_change: u8 = unsafe { ::std::mem::transmute(window_change) };
            window_change as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let window_state_change: u8 = unsafe { ::std::mem::transmute(window_state_change) };
            window_state_change as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let mouse_moved: u8 = unsafe { ::std::mem::transmute(mouse_moved) };
            mouse_moved as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let pointer_invisible: u8 = unsafe { ::std::mem::transmute(pointer_invisible) };
            pointer_invisible as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let frozen_window_starts: u8 = unsafe { ::std::mem::transmute(frozen_window_starts) };
            frozen_window_starts as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let output_method: u32 = unsafe { ::std::mem::transmute(output_method) };
            output_method as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let tooltip: u8 = unsafe { ::std::mem::transmute(tooltip) };
            tooltip as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let want_fullscreen: u32 = unsafe { ::std::mem::transmute(want_fullscreen) };
            want_fullscreen as u64
        });
        __bindgen_bitfield_unit.set(32usize, 2u8, {
            let vertical_scroll_bar_type: u32 =
                unsafe { ::std::mem::transmute(vertical_scroll_bar_type) };
            vertical_scroll_bar_type as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let horizontal_scroll_bars: u8 =
                unsafe { ::std::mem::transmute(horizontal_scroll_bars) };
            horizontal_scroll_bars as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let undecorated: u8 = unsafe { ::std::mem::transmute(undecorated) };
            undecorated as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let override_redirect: u8 = unsafe { ::std::mem::transmute(override_redirect) };
            override_redirect as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let skip_taskbar: u8 = unsafe { ::std::mem::transmute(skip_taskbar) };
            skip_taskbar as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let no_focus_on_map: u8 = unsafe { ::std::mem::transmute(no_focus_on_map) };
            no_focus_on_map as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let no_accept_focus: u8 = unsafe { ::std::mem::transmute(no_accept_focus) };
            no_accept_focus as u64
        });
        __bindgen_bitfield_unit.set(40usize, 2u8, {
            let z_group: u32 = unsafe { ::std::mem::transmute(z_group) };
            z_group as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let no_special_glyphs: u8 = unsafe { ::std::mem::transmute(no_special_glyphs) };
            no_special_glyphs as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let new_pixelwise: u8 = unsafe { ::std::mem::transmute(new_pixelwise) };
            new_pixelwise as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let can_set_window_size: u8 = unsafe { ::std::mem::transmute(can_set_window_size) };
            can_set_window_size as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let after_make_frame: u8 = unsafe { ::std::mem::transmute(after_make_frame) };
            after_make_frame as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let tab_bar_redisplayed: u8 = unsafe { ::std::mem::transmute(tab_bar_redisplayed) };
            tab_bar_redisplayed as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let tab_bar_resized: u8 = unsafe { ::std::mem::transmute(tab_bar_resized) };
            tab_bar_resized as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let tool_bar_redisplayed: u8 = unsafe { ::std::mem::transmute(tool_bar_redisplayed) };
            tool_bar_redisplayed as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let tool_bar_resized: u8 = unsafe { ::std::mem::transmute(tool_bar_resized) };
            tool_bar_resized as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let inhibit_horizontal_resize: u8 =
                unsafe { ::std::mem::transmute(inhibit_horizontal_resize) };
            inhibit_horizontal_resize as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let inhibit_vertical_resize: u8 =
                unsafe { ::std::mem::transmute(inhibit_vertical_resize) };
            inhibit_vertical_resize as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let face_change: u8 = unsafe { ::std::mem::transmute(face_change) };
            face_change as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let inhibit_clear_image_cache: u8 =
                unsafe { ::std::mem::transmute(inhibit_clear_image_cache) };
            inhibit_clear_image_cache as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn fset_buffer_list(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_buried_buffer_list(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_condemned_scroll_bars(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_face_alist(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_parent_frame(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_focus_frame(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_icon_name(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_menu_bar_items(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_menu_bar_vector(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_name(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_param_alist(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_root_window(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_scroll_bars(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_selected_window(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_old_selected_window(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_title(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_tab_bar_items(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_tab_bar_window(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_current_tab_bar_string(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_desired_tab_bar_string(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_tool_bar_items(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_tool_bar_window(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_current_tool_bar_string(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn fset_desired_tool_bar_string(f: *mut frame, val: Lisp_Object);
}
extern "C" {
    pub fn NUMVAL(x: Lisp_Object) -> f64;
}
extern "C" {
    pub fn default_pixels_per_inch_x() -> f64;
}
extern "C" {
    pub fn default_pixels_per_inch_y() -> f64;
}
extern "C" {
    #[link_name = "\u{1}frame_garbaged"]
    pub static mut frame_garbaged: bool;
}
extern "C" {
    pub fn SET_FRAME_VISIBLE(f: *mut frame, v: ::libc::c_int);
}
extern "C" {
    #[link_name = "\u{1}selected_frame"]
    pub static mut selected_frame: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}old_selected_frame"]
    pub static mut old_selected_frame: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}frame_default_tab_bar_height"]
    pub static mut frame_default_tab_bar_height: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}frame_default_tool_bar_height"]
    pub static mut frame_default_tool_bar_height: ::libc::c_int;
}
extern "C" {
    pub fn decode_window_system_frame(arg1: Lisp_Object) -> *mut frame;
}
extern "C" {
    pub fn decode_live_frame(arg1: Lisp_Object) -> *mut frame;
}
extern "C" {
    pub fn decode_any_frame(arg1: Lisp_Object) -> *mut frame;
}
extern "C" {
    pub fn make_initial_frame() -> *mut frame;
}
extern "C" {
    pub fn make_frame(arg1: bool) -> *mut frame;
}
extern "C" {
    pub fn make_minibuffer_frame() -> *mut frame;
}
extern "C" {
    pub fn make_frame_without_minibuffer(
        arg1: Lisp_Object,
        arg2: *mut kboard,
        arg3: Lisp_Object,
    ) -> *mut frame;
}
extern "C" {
    pub fn display_available() -> bool;
}
extern "C" {
    pub fn window_system_available(f: *mut frame) -> bool;
}
extern "C" {
    pub fn check_window_system(arg1: *mut frame);
}
extern "C" {
    pub fn frame_make_pointer_invisible(arg1: *mut frame);
}
extern "C" {
    pub fn frame_make_pointer_visible(arg1: *mut frame);
}
extern "C" {
    pub fn delete_frame(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn frame_inhibit_resize(arg1: *mut frame, arg2: bool, arg3: Lisp_Object) -> bool;
}
extern "C" {
    pub fn adjust_frame_size(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
        arg5: bool,
        arg6: Lisp_Object,
    );
}
extern "C" {
    pub fn frame_size_history_add(
        f: *mut frame,
        fun_symbol: Lisp_Object,
        width: ::libc::c_int,
        height: ::libc::c_int,
        rest: Lisp_Object,
    );
}
extern "C" {
    pub fn mouse_position(arg1: bool) -> Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}Vframe_list"]
    pub static mut Vframe_list: Lisp_Object;
}
extern "C" {
    pub fn frame_dimension(x: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn FRAME_FRINGE_COLS(f: *mut frame) -> ::libc::c_int;
}
extern "C" {
    pub fn FRAME_LEFT_FRINGE_WIDTH(f: *mut frame) -> ::libc::c_int;
}
extern "C" {
    pub fn FRAME_RIGHT_FRINGE_WIDTH(f: *mut frame) -> ::libc::c_int;
}
extern "C" {
    pub fn FRAME_TOTAL_FRINGE_WIDTH(f: *mut frame) -> ::libc::c_int;
}
extern "C" {
    pub fn FRAME_CHILD_FRAME_BORDER_WIDTH(f: *mut frame) -> ::libc::c_int;
}
extern "C" {
    pub fn FRAME_INTERNAL_BORDER_WIDTH(f: *mut frame) -> ::libc::c_int;
}
extern "C" {
    pub fn FRAME_RIGHT_DIVIDER_WIDTH(f: *mut frame) -> ::libc::c_int;
}
extern "C" {
    pub fn FRAME_BOTTOM_DIVIDER_WIDTH(f: *mut frame) -> ::libc::c_int;
}
extern "C" {
    pub fn FACE_FROM_ID(f: *mut frame, id: ::libc::c_int) -> *mut face;
}
extern "C" {
    pub fn FACE_FROM_ID_OR_NULL(f: *mut frame, id: ::libc::c_int) -> *mut face;
}
extern "C" {
    pub fn IMAGE_FROM_ID(f: *mut frame, id: ::libc::c_int) -> *mut image;
}
extern "C" {
    pub fn IMAGE_OPT_FROM_ID(f: *mut frame, id: ::libc::c_int) -> *mut image;
}
extern "C" {
    pub fn gui_set_frame_parameters(arg1: *mut frame, arg2: Lisp_Object);
}
extern "C" {
    pub fn gui_set_fullscreen(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_line_spacing(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_screen_gamma(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_font(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_font_backend(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_left_fringe(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_right_fringe(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_border_width(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_right_divider_width(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_bottom_divider_width(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_visibility(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_autoraise(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_autolower(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_unsplittable(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_vertical_scroll_bars(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_horizontal_scroll_bars(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_scroll_bar_width(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_scroll_bar_height(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_figure_window_size(
        arg1: *mut frame,
        arg2: Lisp_Object,
        arg3: bool,
        arg4: bool,
        arg5: *mut ::libc::c_int,
        arg6: *mut ::libc::c_int,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn gui_set_alpha(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn gui_set_no_special_glyphs(arg1: *mut frame, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn validate_x_resource_name();
}
extern "C" {
    pub fn gui_display_get_resource(
        arg1: *mut Display_Info,
        attribute: Lisp_Object,
        class: Lisp_Object,
        component: Lisp_Object,
        subclass: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn set_frame_menubar(f: *mut frame, deep_p: bool);
}
extern "C" {
    pub fn frame_set_mouse_pixel_position(
        f: *mut frame,
        pix_x: ::libc::c_int,
        pix_y: ::libc::c_int,
    );
}
extern "C" {
    pub fn free_frame_menubar(arg1: *mut frame);
}
extern "C" {
    pub fn frame_ancestor_p(af: *mut frame, df: *mut frame) -> bool;
}
extern "C" {
    pub fn frame_internal_border_part(
        f: *mut frame,
        x: ::libc::c_int,
        y: ::libc::c_int,
    ) -> internal_border_part::Type;
}
extern "C" {
    pub fn gui_set_bitmap_icon(f: *mut frame);
}
extern "C" {
    pub fn flush_frame(f: *mut frame);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MonitorInfo {
    pub geom: Emacs_Rectangle,
    pub work: Emacs_Rectangle,
    pub mm_width: ::libc::c_int,
    pub mm_height: ::libc::c_int,
    pub name: *mut ::libc::c_char,
}
#[test]
fn bindgen_test_layout_MonitorInfo() {
    assert_eq!(
        ::std::mem::size_of::<MonitorInfo>(),
        48usize,
        concat!("Size of: ", stringify!(MonitorInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<MonitorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MonitorInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorInfo>())).geom as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorInfo),
            "::",
            stringify!(geom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorInfo>())).work as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorInfo),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorInfo>())).mm_width as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorInfo),
            "::",
            stringify!(mm_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorInfo>())).mm_height as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorInfo),
            "::",
            stringify!(mm_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonitorInfo>())).name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MonitorInfo),
            "::",
            stringify!(name)
        )
    );
}
impl Default for MonitorInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn free_monitors(monitors: *mut MonitorInfo, n_monitors: ::libc::c_int);
}
extern "C" {
    pub fn make_monitor_attribute_list(
        monitors: *mut MonitorInfo,
        n_monitors: ::libc::c_int,
        primary_monitor: ::libc::c_int,
        monitor_frames: Lisp_Object,
        source: *const ::libc::c_char,
    ) -> Lisp_Object;
}
pub mod gnutls_cipher_algorithm {
    pub type Type = u32;
    pub const GNUTLS_CIPHER_UNKNOWN: Type = 0;
    pub const GNUTLS_CIPHER_NULL: Type = 1;
    pub const GNUTLS_CIPHER_ARCFOUR_128: Type = 2;
    pub const GNUTLS_CIPHER_3DES_CBC: Type = 3;
    pub const GNUTLS_CIPHER_AES_128_CBC: Type = 4;
    pub const GNUTLS_CIPHER_AES_256_CBC: Type = 5;
    pub const GNUTLS_CIPHER_ARCFOUR_40: Type = 6;
    pub const GNUTLS_CIPHER_CAMELLIA_128_CBC: Type = 7;
    pub const GNUTLS_CIPHER_CAMELLIA_256_CBC: Type = 8;
    pub const GNUTLS_CIPHER_AES_192_CBC: Type = 9;
    pub const GNUTLS_CIPHER_AES_128_GCM: Type = 10;
    pub const GNUTLS_CIPHER_AES_256_GCM: Type = 11;
    pub const GNUTLS_CIPHER_CAMELLIA_192_CBC: Type = 12;
    pub const GNUTLS_CIPHER_SALSA20_256: Type = 13;
    pub const GNUTLS_CIPHER_ESTREAM_SALSA20_256: Type = 14;
    pub const GNUTLS_CIPHER_CAMELLIA_128_GCM: Type = 15;
    pub const GNUTLS_CIPHER_CAMELLIA_256_GCM: Type = 16;
    pub const GNUTLS_CIPHER_RC2_40_CBC: Type = 17;
    pub const GNUTLS_CIPHER_DES_CBC: Type = 18;
    pub const GNUTLS_CIPHER_AES_128_CCM: Type = 19;
    pub const GNUTLS_CIPHER_AES_256_CCM: Type = 20;
    pub const GNUTLS_CIPHER_AES_128_CCM_8: Type = 21;
    pub const GNUTLS_CIPHER_AES_256_CCM_8: Type = 22;
    pub const GNUTLS_CIPHER_CHACHA20_POLY1305: Type = 23;
    pub const GNUTLS_CIPHER_GOST28147_TC26Z_CFB: Type = 24;
    pub const GNUTLS_CIPHER_GOST28147_CPA_CFB: Type = 25;
    pub const GNUTLS_CIPHER_GOST28147_CPB_CFB: Type = 26;
    pub const GNUTLS_CIPHER_GOST28147_CPC_CFB: Type = 27;
    pub const GNUTLS_CIPHER_GOST28147_CPD_CFB: Type = 28;
    pub const GNUTLS_CIPHER_AES_128_CFB8: Type = 29;
    pub const GNUTLS_CIPHER_AES_192_CFB8: Type = 30;
    pub const GNUTLS_CIPHER_AES_256_CFB8: Type = 31;
    pub const GNUTLS_CIPHER_AES_128_XTS: Type = 32;
    pub const GNUTLS_CIPHER_AES_256_XTS: Type = 33;
    pub const GNUTLS_CIPHER_GOST28147_TC26Z_CNT: Type = 34;
    pub const GNUTLS_CIPHER_CHACHA20_64: Type = 35;
    pub const GNUTLS_CIPHER_CHACHA20_32: Type = 36;
    pub const GNUTLS_CIPHER_AES_128_SIV: Type = 37;
    pub const GNUTLS_CIPHER_AES_256_SIV: Type = 38;
    pub const GNUTLS_CIPHER_AES_192_GCM: Type = 39;
    pub const GNUTLS_CIPHER_MAGMA_CTR_ACPKM: Type = 40;
    pub const GNUTLS_CIPHER_KUZNYECHIK_CTR_ACPKM: Type = 41;
    pub const GNUTLS_CIPHER_IDEA_PGP_CFB: Type = 200;
    pub const GNUTLS_CIPHER_3DES_PGP_CFB: Type = 201;
    pub const GNUTLS_CIPHER_CAST5_PGP_CFB: Type = 202;
    pub const GNUTLS_CIPHER_BLOWFISH_PGP_CFB: Type = 203;
    pub const GNUTLS_CIPHER_SAFER_SK128_PGP_CFB: Type = 204;
    pub const GNUTLS_CIPHER_AES128_PGP_CFB: Type = 205;
    pub const GNUTLS_CIPHER_AES192_PGP_CFB: Type = 206;
    pub const GNUTLS_CIPHER_AES256_PGP_CFB: Type = 207;
    pub const GNUTLS_CIPHER_TWOFISH_PGP_CFB: Type = 208;
}
pub use self::gnutls_cipher_algorithm::Type as gnutls_cipher_algorithm_t;
pub mod gnutls_kx_algorithm_t {
    pub type Type = u32;
    pub const GNUTLS_KX_UNKNOWN: Type = 0;
    pub const GNUTLS_KX_RSA: Type = 1;
    pub const GNUTLS_KX_DHE_DSS: Type = 2;
    pub const GNUTLS_KX_DHE_RSA: Type = 3;
    pub const GNUTLS_KX_ANON_DH: Type = 4;
    pub const GNUTLS_KX_SRP: Type = 5;
    pub const GNUTLS_KX_RSA_EXPORT: Type = 6;
    pub const GNUTLS_KX_SRP_RSA: Type = 7;
    pub const GNUTLS_KX_SRP_DSS: Type = 8;
    pub const GNUTLS_KX_PSK: Type = 9;
    pub const GNUTLS_KX_DHE_PSK: Type = 10;
    pub const GNUTLS_KX_ANON_ECDH: Type = 11;
    pub const GNUTLS_KX_ECDHE_RSA: Type = 12;
    pub const GNUTLS_KX_ECDHE_ECDSA: Type = 13;
    pub const GNUTLS_KX_ECDHE_PSK: Type = 14;
    pub const GNUTLS_KX_RSA_PSK: Type = 15;
    pub const GNUTLS_KX_VKO_GOST_12: Type = 16;
}
pub mod gnutls_params_type_t {
    pub type Type = u32;
    pub const GNUTLS_PARAMS_RSA_EXPORT: Type = 1;
    pub const GNUTLS_PARAMS_DH: Type = 2;
    pub const GNUTLS_PARAMS_ECDH: Type = 3;
}
pub mod gnutls_credentials_type_t {
    pub type Type = u32;
    pub const GNUTLS_CRD_CERTIFICATE: Type = 1;
    pub const GNUTLS_CRD_ANON: Type = 2;
    pub const GNUTLS_CRD_SRP: Type = 3;
    pub const GNUTLS_CRD_PSK: Type = 4;
    pub const GNUTLS_CRD_IA: Type = 5;
}
pub mod gnutls_mac_algorithm_t {
    pub type Type = u32;
    pub const GNUTLS_MAC_UNKNOWN: Type = 0;
    pub const GNUTLS_MAC_NULL: Type = 1;
    pub const GNUTLS_MAC_MD5: Type = 2;
    pub const GNUTLS_MAC_SHA1: Type = 3;
    pub const GNUTLS_MAC_RMD160: Type = 4;
    pub const GNUTLS_MAC_MD2: Type = 5;
    pub const GNUTLS_MAC_SHA256: Type = 6;
    pub const GNUTLS_MAC_SHA384: Type = 7;
    pub const GNUTLS_MAC_SHA512: Type = 8;
    pub const GNUTLS_MAC_SHA224: Type = 9;
    pub const GNUTLS_MAC_SHA3_224: Type = 10;
    pub const GNUTLS_MAC_SHA3_256: Type = 11;
    pub const GNUTLS_MAC_SHA3_384: Type = 12;
    pub const GNUTLS_MAC_SHA3_512: Type = 13;
    pub const GNUTLS_MAC_MD5_SHA1: Type = 14;
    pub const GNUTLS_MAC_GOSTR_94: Type = 15;
    pub const GNUTLS_MAC_STREEBOG_256: Type = 16;
    pub const GNUTLS_MAC_STREEBOG_512: Type = 17;
    pub const GNUTLS_MAC_AEAD: Type = 200;
    pub const GNUTLS_MAC_UMAC_96: Type = 201;
    pub const GNUTLS_MAC_UMAC_128: Type = 202;
    pub const GNUTLS_MAC_AES_CMAC_128: Type = 203;
    pub const GNUTLS_MAC_AES_CMAC_256: Type = 204;
    pub const GNUTLS_MAC_AES_GMAC_128: Type = 205;
    pub const GNUTLS_MAC_AES_GMAC_192: Type = 206;
    pub const GNUTLS_MAC_AES_GMAC_256: Type = 207;
    pub const GNUTLS_MAC_GOST28147_TC26Z_IMIT: Type = 208;
    pub const GNUTLS_MAC_SHAKE_128: Type = 209;
    pub const GNUTLS_MAC_SHAKE_256: Type = 210;
    pub const GNUTLS_MAC_MAGMA_OMAC: Type = 211;
    pub const GNUTLS_MAC_KUZNYECHIK_OMAC: Type = 212;
}
pub mod gnutls_digest_algorithm_t {
    pub type Type = u32;
    pub const GNUTLS_DIG_UNKNOWN: Type = 0;
    pub const GNUTLS_DIG_NULL: Type = 1;
    pub const GNUTLS_DIG_MD5: Type = 2;
    pub const GNUTLS_DIG_SHA1: Type = 3;
    pub const GNUTLS_DIG_RMD160: Type = 4;
    pub const GNUTLS_DIG_MD2: Type = 5;
    pub const GNUTLS_DIG_SHA256: Type = 6;
    pub const GNUTLS_DIG_SHA384: Type = 7;
    pub const GNUTLS_DIG_SHA512: Type = 8;
    pub const GNUTLS_DIG_SHA224: Type = 9;
    pub const GNUTLS_DIG_SHA3_224: Type = 10;
    pub const GNUTLS_DIG_SHA3_256: Type = 11;
    pub const GNUTLS_DIG_SHA3_384: Type = 12;
    pub const GNUTLS_DIG_SHA3_512: Type = 13;
    pub const GNUTLS_DIG_MD5_SHA1: Type = 14;
    pub const GNUTLS_DIG_GOSTR_94: Type = 15;
    pub const GNUTLS_DIG_STREEBOG_256: Type = 16;
    pub const GNUTLS_DIG_STREEBOG_512: Type = 17;
    pub const GNUTLS_DIG_SHAKE_128: Type = 209;
    pub const GNUTLS_DIG_SHAKE_256: Type = 210;
}
pub mod gnutls_compression_method_t {
    pub type Type = u32;
    pub const GNUTLS_COMP_UNKNOWN: Type = 0;
    pub const GNUTLS_COMP_NULL: Type = 1;
    pub const GNUTLS_COMP_DEFLATE: Type = 2;
    pub const GNUTLS_COMP_ZLIB: Type = 2;
}
pub mod gnutls_init_flags_t {
    pub type Type = u32;
    pub const GNUTLS_SERVER: Type = 1;
    pub const GNUTLS_CLIENT: Type = 2;
    pub const GNUTLS_DATAGRAM: Type = 4;
    pub const GNUTLS_NONBLOCK: Type = 8;
    pub const GNUTLS_NO_EXTENSIONS: Type = 16;
    pub const GNUTLS_NO_REPLAY_PROTECTION: Type = 32;
    pub const GNUTLS_NO_SIGNAL: Type = 64;
    pub const GNUTLS_ALLOW_ID_CHANGE: Type = 128;
    pub const GNUTLS_ENABLE_FALSE_START: Type = 256;
    pub const GNUTLS_FORCE_CLIENT_CERT: Type = 512;
    pub const GNUTLS_NO_TICKETS: Type = 1024;
    pub const GNUTLS_KEY_SHARE_TOP: Type = 2048;
    pub const GNUTLS_KEY_SHARE_TOP2: Type = 4096;
    pub const GNUTLS_KEY_SHARE_TOP3: Type = 8192;
    pub const GNUTLS_POST_HANDSHAKE_AUTH: Type = 16384;
    pub const GNUTLS_NO_AUTO_REKEY: Type = 32768;
    pub const GNUTLS_SAFE_PADDING_CHECK: Type = 65536;
    pub const GNUTLS_ENABLE_EARLY_START: Type = 131072;
    pub const GNUTLS_ENABLE_RAWPK: Type = 262144;
    pub const GNUTLS_AUTO_REAUTH: Type = 524288;
    pub const GNUTLS_ENABLE_EARLY_DATA: Type = 1048576;
    pub const GNUTLS_NO_AUTO_SEND_TICKET: Type = 2097152;
}
pub mod gnutls_alert_level_t {
    pub type Type = u32;
    pub const GNUTLS_AL_WARNING: Type = 1;
    pub const GNUTLS_AL_FATAL: Type = 2;
}
pub mod gnutls_alert_description_t {
    pub type Type = u32;
    pub const GNUTLS_A_CLOSE_NOTIFY: Type = 0;
    pub const GNUTLS_A_UNEXPECTED_MESSAGE: Type = 10;
    pub const GNUTLS_A_BAD_RECORD_MAC: Type = 20;
    pub const GNUTLS_A_DECRYPTION_FAILED: Type = 21;
    pub const GNUTLS_A_RECORD_OVERFLOW: Type = 22;
    pub const GNUTLS_A_DECOMPRESSION_FAILURE: Type = 30;
    pub const GNUTLS_A_HANDSHAKE_FAILURE: Type = 40;
    pub const GNUTLS_A_SSL3_NO_CERTIFICATE: Type = 41;
    pub const GNUTLS_A_BAD_CERTIFICATE: Type = 42;
    pub const GNUTLS_A_UNSUPPORTED_CERTIFICATE: Type = 43;
    pub const GNUTLS_A_CERTIFICATE_REVOKED: Type = 44;
    pub const GNUTLS_A_CERTIFICATE_EXPIRED: Type = 45;
    pub const GNUTLS_A_CERTIFICATE_UNKNOWN: Type = 46;
    pub const GNUTLS_A_ILLEGAL_PARAMETER: Type = 47;
    pub const GNUTLS_A_UNKNOWN_CA: Type = 48;
    pub const GNUTLS_A_ACCESS_DENIED: Type = 49;
    pub const GNUTLS_A_DECODE_ERROR: Type = 50;
    pub const GNUTLS_A_DECRYPT_ERROR: Type = 51;
    pub const GNUTLS_A_EXPORT_RESTRICTION: Type = 60;
    pub const GNUTLS_A_PROTOCOL_VERSION: Type = 70;
    pub const GNUTLS_A_INSUFFICIENT_SECURITY: Type = 71;
    pub const GNUTLS_A_INTERNAL_ERROR: Type = 80;
    pub const GNUTLS_A_INAPPROPRIATE_FALLBACK: Type = 86;
    pub const GNUTLS_A_USER_CANCELED: Type = 90;
    pub const GNUTLS_A_NO_RENEGOTIATION: Type = 100;
    pub const GNUTLS_A_MISSING_EXTENSION: Type = 109;
    pub const GNUTLS_A_UNSUPPORTED_EXTENSION: Type = 110;
    pub const GNUTLS_A_CERTIFICATE_UNOBTAINABLE: Type = 111;
    pub const GNUTLS_A_UNRECOGNIZED_NAME: Type = 112;
    pub const GNUTLS_A_UNKNOWN_PSK_IDENTITY: Type = 115;
    pub const GNUTLS_A_CERTIFICATE_REQUIRED: Type = 116;
    pub const GNUTLS_A_NO_APPLICATION_PROTOCOL: Type = 120;
    pub const GNUTLS_A_MAX: Type = 120;
}
pub mod gnutls_handshake_description_t {
    pub type Type = u32;
    pub const GNUTLS_HANDSHAKE_HELLO_REQUEST: Type = 0;
    pub const GNUTLS_HANDSHAKE_CLIENT_HELLO: Type = 1;
    pub const GNUTLS_HANDSHAKE_SERVER_HELLO: Type = 2;
    pub const GNUTLS_HANDSHAKE_HELLO_VERIFY_REQUEST: Type = 3;
    pub const GNUTLS_HANDSHAKE_NEW_SESSION_TICKET: Type = 4;
    pub const GNUTLS_HANDSHAKE_END_OF_EARLY_DATA: Type = 5;
    pub const GNUTLS_HANDSHAKE_ENCRYPTED_EXTENSIONS: Type = 8;
    pub const GNUTLS_HANDSHAKE_CERTIFICATE_PKT: Type = 11;
    pub const GNUTLS_HANDSHAKE_SERVER_KEY_EXCHANGE: Type = 12;
    pub const GNUTLS_HANDSHAKE_CERTIFICATE_REQUEST: Type = 13;
    pub const GNUTLS_HANDSHAKE_SERVER_HELLO_DONE: Type = 14;
    pub const GNUTLS_HANDSHAKE_CERTIFICATE_VERIFY: Type = 15;
    pub const GNUTLS_HANDSHAKE_CLIENT_KEY_EXCHANGE: Type = 16;
    pub const GNUTLS_HANDSHAKE_FINISHED: Type = 20;
    pub const GNUTLS_HANDSHAKE_CERTIFICATE_STATUS: Type = 22;
    pub const GNUTLS_HANDSHAKE_SUPPLEMENTAL: Type = 23;
    pub const GNUTLS_HANDSHAKE_KEY_UPDATE: Type = 24;
    pub const GNUTLS_HANDSHAKE_CHANGE_CIPHER_SPEC: Type = 254;
    pub const GNUTLS_HANDSHAKE_CLIENT_HELLO_V2: Type = 1024;
    pub const GNUTLS_HANDSHAKE_HELLO_RETRY_REQUEST: Type = 1025;
}
extern "C" {
    pub fn gnutls_handshake_description_get_name(
        type_: gnutls_handshake_description_t::Type,
    ) -> *const ::libc::c_char;
}
pub mod gnutls_certificate_status_t {
    pub type Type = u32;
    pub const GNUTLS_CERT_INVALID: Type = 2;
    pub const GNUTLS_CERT_REVOKED: Type = 32;
    pub const GNUTLS_CERT_SIGNER_NOT_FOUND: Type = 64;
    pub const GNUTLS_CERT_SIGNER_NOT_CA: Type = 128;
    pub const GNUTLS_CERT_INSECURE_ALGORITHM: Type = 256;
    pub const GNUTLS_CERT_NOT_ACTIVATED: Type = 512;
    pub const GNUTLS_CERT_EXPIRED: Type = 1024;
    pub const GNUTLS_CERT_SIGNATURE_FAILURE: Type = 2048;
    pub const GNUTLS_CERT_REVOCATION_DATA_SUPERSEDED: Type = 4096;
    pub const GNUTLS_CERT_UNEXPECTED_OWNER: Type = 16384;
    pub const GNUTLS_CERT_REVOCATION_DATA_ISSUED_IN_FUTURE: Type = 32768;
    pub const GNUTLS_CERT_SIGNER_CONSTRAINTS_FAILURE: Type = 65536;
    pub const GNUTLS_CERT_MISMATCH: Type = 131072;
    pub const GNUTLS_CERT_PURPOSE_MISMATCH: Type = 262144;
    pub const GNUTLS_CERT_MISSING_OCSP_STATUS: Type = 524288;
    pub const GNUTLS_CERT_INVALID_OCSP_STATUS: Type = 1048576;
    pub const GNUTLS_CERT_UNKNOWN_CRIT_EXTENSIONS: Type = 2097152;
}
pub mod gnutls_certificate_request_t {
    pub type Type = u32;
    pub const GNUTLS_CERT_IGNORE: Type = 0;
    pub const GNUTLS_CERT_REQUEST: Type = 1;
    pub const GNUTLS_CERT_REQUIRE: Type = 2;
}
pub mod gnutls_openpgp_crt_status_t {
    pub type Type = u32;
    pub const GNUTLS_OPENPGP_CERT: Type = 0;
    pub const GNUTLS_OPENPGP_CERT_FINGERPRINT: Type = 1;
}
pub mod gnutls_close_request_t {
    pub type Type = u32;
    pub const GNUTLS_SHUT_RDWR: Type = 0;
    pub const GNUTLS_SHUT_WR: Type = 1;
}
pub mod gnutls_protocol_t {
    pub type Type = u32;
    pub const GNUTLS_SSL3: Type = 1;
    pub const GNUTLS_TLS1_0: Type = 2;
    pub const GNUTLS_TLS1: Type = 2;
    pub const GNUTLS_TLS1_1: Type = 3;
    pub const GNUTLS_TLS1_2: Type = 4;
    pub const GNUTLS_TLS1_3: Type = 5;
    pub const GNUTLS_DTLS0_9: Type = 200;
    pub const GNUTLS_DTLS1_0: Type = 201;
    pub const GNUTLS_DTLS1_2: Type = 202;
    pub const GNUTLS_DTLS_VERSION_MIN: Type = 200;
    pub const GNUTLS_DTLS_VERSION_MAX: Type = 202;
    pub const GNUTLS_TLS_VERSION_MAX: Type = 5;
    pub const GNUTLS_VERSION_UNKNOWN: Type = 255;
}
pub mod gnutls_certificate_type_t {
    pub type Type = u32;
    pub const GNUTLS_CRT_UNKNOWN: Type = 0;
    pub const GNUTLS_CRT_X509: Type = 1;
    pub const GNUTLS_CRT_OPENPGP: Type = 2;
    pub const GNUTLS_CRT_RAWPK: Type = 3;
    pub const GNUTLS_CRT_MAX: Type = 3;
}
pub mod gnutls_x509_crt_fmt_t {
    pub type Type = u32;
    pub const GNUTLS_X509_FMT_DER: Type = 0;
    pub const GNUTLS_X509_FMT_PEM: Type = 1;
}
pub mod gnutls_certificate_print_formats {
    pub type Type = u32;
    pub const GNUTLS_CRT_PRINT_FULL: Type = 0;
    pub const GNUTLS_CRT_PRINT_ONELINE: Type = 1;
    pub const GNUTLS_CRT_PRINT_UNSIGNED_FULL: Type = 2;
    pub const GNUTLS_CRT_PRINT_COMPACT: Type = 3;
    pub const GNUTLS_CRT_PRINT_FULL_NUMBERS: Type = 4;
}
pub use self::gnutls_certificate_print_formats::Type as gnutls_certificate_print_formats_t;
pub mod gnutls_pk_algorithm_t {
    pub type Type = u32;
    pub const GNUTLS_PK_UNKNOWN: Type = 0;
    pub const GNUTLS_PK_RSA: Type = 1;
    pub const GNUTLS_PK_DSA: Type = 2;
    pub const GNUTLS_PK_DH: Type = 3;
    pub const GNUTLS_PK_ECDSA: Type = 4;
    pub const GNUTLS_PK_ECDH_X25519: Type = 5;
    pub const GNUTLS_PK_RSA_PSS: Type = 6;
    pub const GNUTLS_PK_EDDSA_ED25519: Type = 7;
    pub const GNUTLS_PK_GOST_01: Type = 8;
    pub const GNUTLS_PK_GOST_12_256: Type = 9;
    pub const GNUTLS_PK_GOST_12_512: Type = 10;
    pub const GNUTLS_PK_ECDH_X448: Type = 11;
    pub const GNUTLS_PK_EDDSA_ED448: Type = 12;
    pub const GNUTLS_PK_MAX: Type = 12;
}
extern "C" {
    pub fn gnutls_pk_algorithm_get_name(
        algorithm: gnutls_pk_algorithm_t::Type,
    ) -> *const ::libc::c_char;
}
pub mod gnutls_sign_algorithm_t {
    pub type Type = u32;
    pub const GNUTLS_SIGN_UNKNOWN: Type = 0;
    pub const GNUTLS_SIGN_RSA_SHA1: Type = 1;
    pub const GNUTLS_SIGN_RSA_SHA: Type = 1;
    pub const GNUTLS_SIGN_DSA_SHA1: Type = 2;
    pub const GNUTLS_SIGN_DSA_SHA: Type = 2;
    pub const GNUTLS_SIGN_RSA_MD5: Type = 3;
    pub const GNUTLS_SIGN_RSA_MD2: Type = 4;
    pub const GNUTLS_SIGN_RSA_RMD160: Type = 5;
    pub const GNUTLS_SIGN_RSA_SHA256: Type = 6;
    pub const GNUTLS_SIGN_RSA_SHA384: Type = 7;
    pub const GNUTLS_SIGN_RSA_SHA512: Type = 8;
    pub const GNUTLS_SIGN_RSA_SHA224: Type = 9;
    pub const GNUTLS_SIGN_DSA_SHA224: Type = 10;
    pub const GNUTLS_SIGN_DSA_SHA256: Type = 11;
    pub const GNUTLS_SIGN_ECDSA_SHA1: Type = 12;
    pub const GNUTLS_SIGN_ECDSA_SHA224: Type = 13;
    pub const GNUTLS_SIGN_ECDSA_SHA256: Type = 14;
    pub const GNUTLS_SIGN_ECDSA_SHA384: Type = 15;
    pub const GNUTLS_SIGN_ECDSA_SHA512: Type = 16;
    pub const GNUTLS_SIGN_DSA_SHA384: Type = 17;
    pub const GNUTLS_SIGN_DSA_SHA512: Type = 18;
    pub const GNUTLS_SIGN_ECDSA_SHA3_224: Type = 20;
    pub const GNUTLS_SIGN_ECDSA_SHA3_256: Type = 21;
    pub const GNUTLS_SIGN_ECDSA_SHA3_384: Type = 22;
    pub const GNUTLS_SIGN_ECDSA_SHA3_512: Type = 23;
    pub const GNUTLS_SIGN_DSA_SHA3_224: Type = 24;
    pub const GNUTLS_SIGN_DSA_SHA3_256: Type = 25;
    pub const GNUTLS_SIGN_DSA_SHA3_384: Type = 26;
    pub const GNUTLS_SIGN_DSA_SHA3_512: Type = 27;
    pub const GNUTLS_SIGN_RSA_SHA3_224: Type = 28;
    pub const GNUTLS_SIGN_RSA_SHA3_256: Type = 29;
    pub const GNUTLS_SIGN_RSA_SHA3_384: Type = 30;
    pub const GNUTLS_SIGN_RSA_SHA3_512: Type = 31;
    pub const GNUTLS_SIGN_RSA_PSS_SHA256: Type = 32;
    pub const GNUTLS_SIGN_RSA_PSS_SHA384: Type = 33;
    pub const GNUTLS_SIGN_RSA_PSS_SHA512: Type = 34;
    pub const GNUTLS_SIGN_EDDSA_ED25519: Type = 35;
    pub const GNUTLS_SIGN_RSA_RAW: Type = 36;
    pub const GNUTLS_SIGN_ECDSA_SECP256R1_SHA256: Type = 37;
    pub const GNUTLS_SIGN_ECDSA_SECP384R1_SHA384: Type = 38;
    pub const GNUTLS_SIGN_ECDSA_SECP521R1_SHA512: Type = 39;
    pub const GNUTLS_SIGN_RSA_PSS_RSAE_SHA256: Type = 40;
    pub const GNUTLS_SIGN_RSA_PSS_RSAE_SHA384: Type = 41;
    pub const GNUTLS_SIGN_RSA_PSS_RSAE_SHA512: Type = 42;
    pub const GNUTLS_SIGN_GOST_94: Type = 43;
    pub const GNUTLS_SIGN_GOST_256: Type = 44;
    pub const GNUTLS_SIGN_GOST_512: Type = 45;
    pub const GNUTLS_SIGN_EDDSA_ED448: Type = 46;
    pub const GNUTLS_SIGN_MAX: Type = 46;
}
pub mod gnutls_ecc_curve_t {
    pub type Type = u32;
    pub const GNUTLS_ECC_CURVE_INVALID: Type = 0;
    pub const GNUTLS_ECC_CURVE_SECP224R1: Type = 1;
    pub const GNUTLS_ECC_CURVE_SECP256R1: Type = 2;
    pub const GNUTLS_ECC_CURVE_SECP384R1: Type = 3;
    pub const GNUTLS_ECC_CURVE_SECP521R1: Type = 4;
    pub const GNUTLS_ECC_CURVE_SECP192R1: Type = 5;
    pub const GNUTLS_ECC_CURVE_X25519: Type = 6;
    pub const GNUTLS_ECC_CURVE_ED25519: Type = 7;
    pub const GNUTLS_ECC_CURVE_GOST256CPA: Type = 8;
    pub const GNUTLS_ECC_CURVE_GOST256CPB: Type = 9;
    pub const GNUTLS_ECC_CURVE_GOST256CPC: Type = 10;
    pub const GNUTLS_ECC_CURVE_GOST256CPXA: Type = 11;
    pub const GNUTLS_ECC_CURVE_GOST256CPXB: Type = 12;
    pub const GNUTLS_ECC_CURVE_GOST512A: Type = 13;
    pub const GNUTLS_ECC_CURVE_GOST512B: Type = 14;
    pub const GNUTLS_ECC_CURVE_GOST512C: Type = 15;
    pub const GNUTLS_ECC_CURVE_GOST256A: Type = 16;
    pub const GNUTLS_ECC_CURVE_GOST256B: Type = 17;
    pub const GNUTLS_ECC_CURVE_GOST256C: Type = 18;
    pub const GNUTLS_ECC_CURVE_GOST256D: Type = 19;
    pub const GNUTLS_ECC_CURVE_X448: Type = 20;
    pub const GNUTLS_ECC_CURVE_ED448: Type = 21;
    pub const GNUTLS_ECC_CURVE_MAX: Type = 21;
}
pub mod gnutls_group_t {
    pub type Type = u32;
    pub const GNUTLS_GROUP_INVALID: Type = 0;
    pub const GNUTLS_GROUP_SECP192R1: Type = 5;
    pub const GNUTLS_GROUP_SECP224R1: Type = 1;
    pub const GNUTLS_GROUP_SECP256R1: Type = 2;
    pub const GNUTLS_GROUP_SECP384R1: Type = 3;
    pub const GNUTLS_GROUP_SECP521R1: Type = 4;
    pub const GNUTLS_GROUP_X25519: Type = 6;
    pub const GNUTLS_GROUP_X448: Type = 20;
    pub const GNUTLS_GROUP_GC256A: Type = 16;
    pub const GNUTLS_GROUP_GC256B: Type = 17;
    pub const GNUTLS_GROUP_GC256C: Type = 18;
    pub const GNUTLS_GROUP_GC256D: Type = 19;
    pub const GNUTLS_GROUP_GC512A: Type = 13;
    pub const GNUTLS_GROUP_GC512B: Type = 14;
    pub const GNUTLS_GROUP_GC512C: Type = 15;
    pub const GNUTLS_GROUP_FFDHE2048: Type = 256;
    pub const GNUTLS_GROUP_FFDHE3072: Type = 257;
    pub const GNUTLS_GROUP_FFDHE4096: Type = 258;
    pub const GNUTLS_GROUP_FFDHE8192: Type = 259;
    pub const GNUTLS_GROUP_FFDHE6144: Type = 260;
    pub const GNUTLS_GROUP_MAX: Type = 260;
}
pub mod gnutls_sec_param_t {
    pub type Type = u32;
    pub const GNUTLS_SEC_PARAM_UNKNOWN: Type = 0;
    pub const GNUTLS_SEC_PARAM_INSECURE: Type = 5;
    pub const GNUTLS_SEC_PARAM_EXPORT: Type = 10;
    pub const GNUTLS_SEC_PARAM_VERY_WEAK: Type = 15;
    pub const GNUTLS_SEC_PARAM_WEAK: Type = 20;
    pub const GNUTLS_SEC_PARAM_LOW: Type = 25;
    pub const GNUTLS_SEC_PARAM_LEGACY: Type = 30;
    pub const GNUTLS_SEC_PARAM_MEDIUM: Type = 35;
    pub const GNUTLS_SEC_PARAM_HIGH: Type = 40;
    pub const GNUTLS_SEC_PARAM_ULTRA: Type = 45;
    pub const GNUTLS_SEC_PARAM_FUTURE: Type = 50;
    pub const GNUTLS_SEC_PARAM_MAX: Type = 50;
}
pub mod gnutls_channel_binding_t {
    pub type Type = u32;
    pub const GNUTLS_CB_TLS_UNIQUE: Type = 0;
}
pub mod gnutls_gost_paramset_t {
    pub type Type = u32;
    pub const GNUTLS_GOST_PARAMSET_UNKNOWN: Type = 0;
    pub const GNUTLS_GOST_PARAMSET_TC26_Z: Type = 1;
    pub const GNUTLS_GOST_PARAMSET_CP_A: Type = 2;
    pub const GNUTLS_GOST_PARAMSET_CP_B: Type = 3;
    pub const GNUTLS_GOST_PARAMSET_CP_C: Type = 4;
    pub const GNUTLS_GOST_PARAMSET_CP_D: Type = 5;
}
pub mod gnutls_ctype_target_t {
    pub type Type = u32;
    pub const GNUTLS_CTYPE_CLIENT: Type = 0;
    pub const GNUTLS_CTYPE_SERVER: Type = 1;
    pub const GNUTLS_CTYPE_OURS: Type = 2;
    pub const GNUTLS_CTYPE_PEERS: Type = 3;
}
pub type gnutls_transport_ptr_t = *mut ::libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_session_int {
    _unused: [u8; 0],
}
pub type gnutls_session_t = *mut gnutls_session_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_dh_params_int {
    _unused: [u8; 0],
}
pub type gnutls_dh_params_t = *mut gnutls_dh_params_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_privkey_int {
    _unused: [u8; 0],
}
pub type gnutls_rsa_params_t = *mut gnutls_x509_privkey_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_priority_st {
    _unused: [u8; 0],
}
pub type gnutls_priority_t = *mut gnutls_priority_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_datum_t {
    pub data: *mut ::libc::c_uchar,
    pub size: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_gnutls_datum_t() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_datum_t>(),
        16usize,
        concat!("Size of: ", stringify!(gnutls_datum_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_datum_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_datum_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_datum_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_datum_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_datum_t>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_datum_t),
            "::",
            stringify!(size)
        )
    );
}
impl Default for gnutls_datum_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnutls_params_st {
    pub type_: gnutls_params_type_t::Type,
    pub params: gnutls_params_st_params,
    pub deinit: ::libc::c_int,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union gnutls_params_st_params {
    pub dh: gnutls_dh_params_t,
    pub rsa_export: gnutls_rsa_params_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_gnutls_params_st_params() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_params_st_params>(),
        8usize,
        concat!("Size of: ", stringify!(gnutls_params_st_params))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_params_st_params>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_params_st_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_params_st_params>())).dh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st_params),
            "::",
            stringify!(dh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_params_st_params>())).rsa_export as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st_params),
            "::",
            stringify!(rsa_export)
        )
    );
}
impl Default for gnutls_params_st_params {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_gnutls_params_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_params_st>(),
        24usize,
        concat!("Size of: ", stringify!(gnutls_params_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_params_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_params_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_params_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_params_st>())).params as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_params_st>())).deinit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st),
            "::",
            stringify!(deinit)
        )
    );
}
impl Default for gnutls_params_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type gnutls_params_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        arg2: gnutls_params_type_t::Type,
        arg3: *mut gnutls_params_st,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_init(session: *mut gnutls_session_t, flags: ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_deinit(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_bye(
        session: gnutls_session_t,
        how: gnutls_close_request_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_handshake(session: gnutls_session_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_reauth(session: gnutls_session_t, flags: ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_handshake_set_timeout(session: gnutls_session_t, ms: ::libc::c_uint);
}
extern "C" {
    pub fn gnutls_rehandshake(session: gnutls_session_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_key_update(
        session: gnutls_session_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_alert_get(session: gnutls_session_t) -> gnutls_alert_description_t::Type;
}
extern "C" {
    pub fn gnutls_alert_send(
        session: gnutls_session_t,
        level: gnutls_alert_level_t::Type,
        desc: gnutls_alert_description_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_alert_send_appropriate(
        session: gnutls_session_t,
        err: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_alert_get_name(alert: gnutls_alert_description_t::Type) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_alert_get_strname(
        alert: gnutls_alert_description_t::Type,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_pk_bits_to_sec_param(
        algo: gnutls_pk_algorithm_t::Type,
        bits: ::libc::c_uint,
    ) -> gnutls_sec_param_t::Type;
}
extern "C" {
    pub fn gnutls_sec_param_get_name(param: gnutls_sec_param_t::Type) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_sec_param_to_pk_bits(
        algo: gnutls_pk_algorithm_t::Type,
        param: gnutls_sec_param_t::Type,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_sec_param_to_symmetric_bits(param: gnutls_sec_param_t::Type) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_name(curve: gnutls_ecc_curve_t::Type) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_oid(curve: gnutls_ecc_curve_t::Type) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_group_get_name(group: gnutls_group_t::Type) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_size(curve: gnutls_ecc_curve_t::Type) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_ecc_curve_get(session: gnutls_session_t) -> gnutls_ecc_curve_t::Type;
}
extern "C" {
    pub fn gnutls_group_get(session: gnutls_session_t) -> gnutls_group_t::Type;
}
extern "C" {
    pub fn gnutls_cipher_get(session: gnutls_session_t) -> gnutls_cipher_algorithm_t;
}
extern "C" {
    pub fn gnutls_kx_get(session: gnutls_session_t) -> gnutls_kx_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_mac_get(session: gnutls_session_t) -> gnutls_mac_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_prf_hash_get(session: gnutls_session_t) -> gnutls_digest_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_certificate_type_get(
        session: gnutls_session_t,
    ) -> gnutls_certificate_type_t::Type;
}
extern "C" {
    pub fn gnutls_certificate_type_get2(
        session: gnutls_session_t,
        target: gnutls_ctype_target_t::Type,
    ) -> gnutls_certificate_type_t::Type;
}
extern "C" {
    pub fn gnutls_sign_algorithm_get(session: gnutls_session_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_sign_algorithm_get_client(session: gnutls_session_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_sign_algorithm_get_requested(
        session: gnutls_session_t,
        indx: usize,
        algo: *mut gnutls_sign_algorithm_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_cipher_get_name(algorithm: gnutls_cipher_algorithm_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_mac_get_name(algorithm: gnutls_mac_algorithm_t::Type) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_digest_get_name(
        algorithm: gnutls_digest_algorithm_t::Type,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_digest_get_oid(
        algorithm: gnutls_digest_algorithm_t::Type,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_kx_get_name(algorithm: gnutls_kx_algorithm_t::Type) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_certificate_type_get_name(
        type_: gnutls_certificate_type_t::Type,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_pk_get_name(algorithm: gnutls_pk_algorithm_t::Type) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_pk_get_oid(algorithm: gnutls_pk_algorithm_t::Type) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_sign_get_name(algorithm: gnutls_sign_algorithm_t::Type) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_sign_get_oid(sign: gnutls_sign_algorithm_t::Type) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_gost_paramset_get_name(
        param: gnutls_gost_paramset_t::Type,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_gost_paramset_get_oid(
        param: gnutls_gost_paramset_t::Type,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_cipher_get_key_size(algorithm: gnutls_cipher_algorithm_t) -> usize;
}
extern "C" {
    pub fn gnutls_mac_get_key_size(algorithm: gnutls_mac_algorithm_t::Type) -> usize;
}
extern "C" {
    pub fn gnutls_sign_is_secure(algorithm: gnutls_sign_algorithm_t::Type) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_sign_is_secure2(
        algorithm: gnutls_sign_algorithm_t::Type,
        flags: ::libc::c_uint,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_sign_get_hash_algorithm(
        sign: gnutls_sign_algorithm_t::Type,
    ) -> gnutls_digest_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_sign_get_pk_algorithm(
        sign: gnutls_sign_algorithm_t::Type,
    ) -> gnutls_pk_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_pk_to_sign(
        pk: gnutls_pk_algorithm_t::Type,
        hash: gnutls_digest_algorithm_t::Type,
    ) -> gnutls_sign_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_sign_supports_pk_algorithm(
        sign: gnutls_sign_algorithm_t::Type,
        pk: gnutls_pk_algorithm_t::Type,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_mac_get_id(name: *const ::libc::c_char) -> gnutls_mac_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_digest_get_id(name: *const ::libc::c_char) -> gnutls_digest_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_cipher_get_id(name: *const ::libc::c_char) -> gnutls_cipher_algorithm_t;
}
extern "C" {
    pub fn gnutls_kx_get_id(name: *const ::libc::c_char) -> gnutls_kx_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_protocol_get_id(name: *const ::libc::c_char) -> gnutls_protocol_t::Type;
}
extern "C" {
    pub fn gnutls_certificate_type_get_id(
        name: *const ::libc::c_char,
    ) -> gnutls_certificate_type_t::Type;
}
extern "C" {
    pub fn gnutls_pk_get_id(name: *const ::libc::c_char) -> gnutls_pk_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_sign_get_id(name: *const ::libc::c_char) -> gnutls_sign_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_id(name: *const ::libc::c_char) -> gnutls_ecc_curve_t::Type;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_pk(curve: gnutls_ecc_curve_t::Type) -> gnutls_pk_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_group_get_id(name: *const ::libc::c_char) -> gnutls_group_t::Type;
}
extern "C" {
    pub fn gnutls_oid_to_digest(oid: *const ::libc::c_char) -> gnutls_digest_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_oid_to_mac(oid: *const ::libc::c_char) -> gnutls_mac_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_oid_to_pk(oid: *const ::libc::c_char) -> gnutls_pk_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_oid_to_sign(oid: *const ::libc::c_char) -> gnutls_sign_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_oid_to_ecc_curve(oid: *const ::libc::c_char) -> gnutls_ecc_curve_t::Type;
}
extern "C" {
    pub fn gnutls_oid_to_gost_paramset(oid: *const ::libc::c_char) -> gnutls_gost_paramset_t::Type;
}
extern "C" {
    pub fn gnutls_ecc_curve_list() -> *const gnutls_ecc_curve_t::Type;
}
extern "C" {
    pub fn gnutls_group_list() -> *const gnutls_group_t::Type;
}
extern "C" {
    pub fn gnutls_cipher_list() -> *const gnutls_cipher_algorithm_t;
}
extern "C" {
    pub fn gnutls_mac_list() -> *const gnutls_mac_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_digest_list() -> *const gnutls_digest_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_protocol_list() -> *const gnutls_protocol_t::Type;
}
extern "C" {
    pub fn gnutls_certificate_type_list() -> *const gnutls_certificate_type_t::Type;
}
extern "C" {
    pub fn gnutls_kx_list() -> *const gnutls_kx_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_pk_list() -> *const gnutls_pk_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_sign_list() -> *const gnutls_sign_algorithm_t::Type;
}
extern "C" {
    pub fn gnutls_cipher_suite_info(
        idx: usize,
        cs_id: *mut ::libc::c_uchar,
        kx: *mut gnutls_kx_algorithm_t::Type,
        cipher: *mut gnutls_cipher_algorithm_t,
        mac: *mut gnutls_mac_algorithm_t::Type,
        min_version: *mut gnutls_protocol_t::Type,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_error_is_fatal(error: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_error_to_alert(err: ::libc::c_int, level: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_perror(error: ::libc::c_int);
}
extern "C" {
    pub fn gnutls_strerror(error: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_strerror_name(error: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_handshake_set_private_extensions(session: gnutls_session_t, allow: ::libc::c_int);
}
extern "C" {
    pub fn gnutls_handshake_set_random(
        session: gnutls_session_t,
        random: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_handshake_get_last_out(
        session: gnutls_session_t,
    ) -> gnutls_handshake_description_t::Type;
}
extern "C" {
    pub fn gnutls_handshake_get_last_in(
        session: gnutls_session_t,
    ) -> gnutls_handshake_description_t::Type;
}
extern "C" {
    pub fn gnutls_heartbeat_ping(
        session: gnutls_session_t,
        data_size: usize,
        max_tries: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_heartbeat_pong(session: gnutls_session_t, flags: ::libc::c_uint)
        -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_record_set_timeout(session: gnutls_session_t, ms: ::libc::c_uint);
}
extern "C" {
    pub fn gnutls_record_disable_padding(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_record_cork(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_record_uncork(session: gnutls_session_t, flags: ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_record_discard_queued(session: gnutls_session_t) -> usize;
}
extern "C" {
    pub fn gnutls_record_get_state(
        session: gnutls_session_t,
        read: ::libc::c_uint,
        mac_key: *mut gnutls_datum_t,
        IV: *mut gnutls_datum_t,
        cipher_key: *mut gnutls_datum_t,
        seq_number: *mut ::libc::c_uchar,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_record_set_state(
        session: gnutls_session_t,
        read: ::libc::c_uint,
        seq_number: *const ::libc::c_uchar,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gnutls_range_st {
    pub low: usize,
    pub high: usize,
}
#[test]
fn bindgen_test_layout_gnutls_range_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_range_st>(),
        16usize,
        concat!("Size of: ", stringify!(gnutls_range_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_range_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_range_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_range_st>())).low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_range_st),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_range_st>())).high as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_range_st),
            "::",
            stringify!(high)
        )
    );
}
extern "C" {
    pub fn gnutls_range_split(
        session: gnutls_session_t,
        orig: *const gnutls_range_st,
        small_range: *mut gnutls_range_st,
        rem_range: *mut gnutls_range_st,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_record_send(
        session: gnutls_session_t,
        data: *const ::libc::c_void,
        data_size: usize,
    ) -> isize;
}
extern "C" {
    pub fn gnutls_record_send2(
        session: gnutls_session_t,
        data: *const ::libc::c_void,
        data_size: usize,
        pad: usize,
        flags: ::libc::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn gnutls_record_send_range(
        session: gnutls_session_t,
        data: *const ::libc::c_void,
        data_size: usize,
        range: *const gnutls_range_st,
    ) -> isize;
}
extern "C" {
    pub fn gnutls_record_recv(
        session: gnutls_session_t,
        data: *mut ::libc::c_void,
        data_size: usize,
    ) -> isize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbuffer_st {
    _unused: [u8; 0],
}
pub type gnutls_packet_t = *mut mbuffer_st;
extern "C" {
    pub fn gnutls_record_recv_packet(
        session: gnutls_session_t,
        packet: *mut gnutls_packet_t,
    ) -> isize;
}
extern "C" {
    pub fn gnutls_packet_get(
        packet: gnutls_packet_t,
        data: *mut gnutls_datum_t,
        sequence: *mut ::libc::c_uchar,
    );
}
extern "C" {
    pub fn gnutls_packet_deinit(packet: gnutls_packet_t);
}
extern "C" {
    pub fn gnutls_record_recv_seq(
        session: gnutls_session_t,
        data: *mut ::libc::c_void,
        data_size: usize,
        seq: *mut ::libc::c_uchar,
    ) -> isize;
}
extern "C" {
    pub fn gnutls_record_overhead_size(session: gnutls_session_t) -> usize;
}
extern "C" {
    pub fn gnutls_est_record_overhead_size(
        version: gnutls_protocol_t::Type,
        cipher: gnutls_cipher_algorithm_t,
        mac: gnutls_mac_algorithm_t::Type,
        comp: gnutls_compression_method_t::Type,
        flags: ::libc::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn gnutls_session_enable_compatibility_mode(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_record_can_use_length_hiding(session: gnutls_session_t) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_record_get_direction(session: gnutls_session_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_record_get_max_size(session: gnutls_session_t) -> usize;
}
extern "C" {
    pub fn gnutls_record_set_max_size(session: gnutls_session_t, size: usize) -> isize;
}
extern "C" {
    pub fn gnutls_record_set_max_recv_size(session: gnutls_session_t, size: usize) -> isize;
}
extern "C" {
    pub fn gnutls_record_check_pending(session: gnutls_session_t) -> usize;
}
extern "C" {
    pub fn gnutls_record_check_corked(session: gnutls_session_t) -> usize;
}
extern "C" {
    pub fn gnutls_record_get_max_early_data_size(session: gnutls_session_t) -> usize;
}
extern "C" {
    pub fn gnutls_record_set_max_early_data_size(
        session: gnutls_session_t,
        size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_record_send_early_data(
        session: gnutls_session_t,
        data: *const ::libc::c_void,
        length: usize,
    ) -> isize;
}
extern "C" {
    pub fn gnutls_record_recv_early_data(
        session: gnutls_session_t,
        data: *mut ::libc::c_void,
        data_size: usize,
    ) -> isize;
}
extern "C" {
    pub fn gnutls_session_force_valid(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_prf(
        session: gnutls_session_t,
        label_size: usize,
        label: *const ::libc::c_char,
        server_random_first: ::libc::c_int,
        extra_size: usize,
        extra: *const ::libc::c_char,
        outsize: usize,
        out: *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_prf_rfc5705(
        session: gnutls_session_t,
        label_size: usize,
        label: *const ::libc::c_char,
        context_size: usize,
        context: *const ::libc::c_char,
        outsize: usize,
        out: *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_prf_early(
        session: gnutls_session_t,
        label_size: usize,
        label: *const ::libc::c_char,
        context_size: usize,
        context: *const ::libc::c_char,
        outsize: usize,
        out: *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_prf_raw(
        session: gnutls_session_t,
        label_size: usize,
        label: *const ::libc::c_char,
        seed_size: usize,
        seed: *const ::libc::c_char,
        outsize: usize,
        out: *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
pub mod gnutls_server_name_type_t {
    pub type Type = u32;
    pub const GNUTLS_NAME_DNS: Type = 1;
}
extern "C" {
    pub fn gnutls_server_name_set(
        session: gnutls_session_t,
        type_: gnutls_server_name_type_t::Type,
        name: *const ::libc::c_void,
        name_length: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_server_name_get(
        session: gnutls_session_t,
        data: *mut ::libc::c_void,
        data_length: *mut usize,
        type_: *mut ::libc::c_uint,
        indx: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_heartbeat_get_timeout(session: gnutls_session_t) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_heartbeat_set_timeouts(
        session: gnutls_session_t,
        retrans_timeout: ::libc::c_uint,
        total_timeout: ::libc::c_uint,
    );
}
extern "C" {
    pub fn gnutls_heartbeat_enable(session: gnutls_session_t, type_: ::libc::c_uint);
}
extern "C" {
    pub fn gnutls_heartbeat_allowed(
        session: gnutls_session_t,
        type_: ::libc::c_uint,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_safe_renegotiation_status(session: gnutls_session_t) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_session_ext_master_secret_status(session: gnutls_session_t) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_session_etm_status(session: gnutls_session_t) -> ::libc::c_uint;
}
pub mod gnutls_session_flags_t {
    pub type Type = u32;
    pub const GNUTLS_SFLAGS_SAFE_RENEGOTIATION: Type = 1;
    pub const GNUTLS_SFLAGS_EXT_MASTER_SECRET: Type = 2;
    pub const GNUTLS_SFLAGS_ETM: Type = 4;
    pub const GNUTLS_SFLAGS_HB_LOCAL_SEND: Type = 8;
    pub const GNUTLS_SFLAGS_HB_PEER_SEND: Type = 16;
    pub const GNUTLS_SFLAGS_FALSE_START: Type = 32;
    pub const GNUTLS_SFLAGS_RFC7919: Type = 64;
    pub const GNUTLS_SFLAGS_SESSION_TICKET: Type = 128;
    pub const GNUTLS_SFLAGS_POST_HANDSHAKE_AUTH: Type = 256;
    pub const GNUTLS_SFLAGS_EARLY_START: Type = 512;
    pub const GNUTLS_SFLAGS_EARLY_DATA: Type = 1024;
    pub const GNUTLS_SFLAGS_CLI_REQUESTED_OCSP: Type = 2048;
    pub const GNUTLS_SFLAGS_SERV_REQUESTED_OCSP: Type = 4096;
}
extern "C" {
    pub fn gnutls_session_get_flags(session: gnutls_session_t) -> ::libc::c_uint;
}
pub mod gnutls_supplemental_data_format_type_t {
    pub type Type = u32;
    pub const GNUTLS_SUPPLEMENTAL_UNKNOWN: Type = 0;
}
extern "C" {
    pub fn gnutls_supplemental_get_name(
        type_: gnutls_supplemental_data_format_type_t::Type,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_session_ticket_key_generate(key: *mut gnutls_datum_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_ticket_enable_client(session: gnutls_session_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_ticket_enable_server(
        session: gnutls_session_t,
        key: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_ticket_send(
        session: gnutls_session_t,
        nr: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
pub mod gnutls_srtp_profile_t {
    pub type Type = u32;
    pub const GNUTLS_SRTP_AES128_CM_HMAC_SHA1_80: Type = 1;
    pub const GNUTLS_SRTP_AES128_CM_HMAC_SHA1_32: Type = 2;
    pub const GNUTLS_SRTP_NULL_HMAC_SHA1_80: Type = 5;
    pub const GNUTLS_SRTP_NULL_HMAC_SHA1_32: Type = 6;
}
extern "C" {
    pub fn gnutls_srtp_set_profile(
        session: gnutls_session_t,
        profile: gnutls_srtp_profile_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srtp_set_profile_direct(
        session: gnutls_session_t,
        profiles: *const ::libc::c_char,
        err_pos: *mut *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srtp_get_selected_profile(
        session: gnutls_session_t,
        profile: *mut gnutls_srtp_profile_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srtp_get_profile_name(
        profile: gnutls_srtp_profile_t::Type,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_srtp_get_profile_id(
        name: *const ::libc::c_char,
        profile: *mut gnutls_srtp_profile_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srtp_get_keys(
        session: gnutls_session_t,
        key_material: *mut ::libc::c_void,
        key_material_size: ::libc::c_uint,
        client_key: *mut gnutls_datum_t,
        client_salt: *mut gnutls_datum_t,
        server_key: *mut gnutls_datum_t,
        server_salt: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srtp_set_mki(
        session: gnutls_session_t,
        mki: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srtp_get_mki(
        session: gnutls_session_t,
        mki: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
pub mod gnutls_alpn_flags_t {
    pub type Type = u32;
    pub const GNUTLS_ALPN_MANDATORY: Type = 1;
    pub const GNUTLS_ALPN_SERVER_PRECEDENCE: Type = 2;
}
extern "C" {
    pub fn gnutls_alpn_get_selected_protocol(
        session: gnutls_session_t,
        protocol: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_alpn_set_protocols(
        session: gnutls_session_t,
        protocols: *const gnutls_datum_t,
        protocols_size: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_key_generate(key: *mut gnutls_datum_t, key_size: ::libc::c_uint)
        -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_init(
        priority_cache: *mut gnutls_priority_t,
        priorities: *const ::libc::c_char,
        err_pos: *mut *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_init2(
        priority_cache: *mut gnutls_priority_t,
        priorities: *const ::libc::c_char,
        err_pos: *mut *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_deinit(priority_cache: gnutls_priority_t);
}
extern "C" {
    pub fn gnutls_priority_get_cipher_suite_index(
        pcache: gnutls_priority_t,
        idx: ::libc::c_uint,
        sidx: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_string_list(
        iter: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_priority_set(
        session: gnutls_session_t,
        priority: gnutls_priority_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_set_direct(
        session: gnutls_session_t,
        priorities: *const ::libc::c_char,
        err_pos: *mut *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_certificate_type_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_certificate_type_list2(
        pcache: gnutls_priority_t,
        list: *mut *const ::libc::c_uint,
        target: gnutls_ctype_target_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_sign_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_protocol_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_ecc_curve_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_group_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_kx_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_cipher_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_priority_mac_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_get_system_config_file() -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_set_default_priority(session: gnutls_session_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_set_default_priority_append(
        session: gnutls_session_t,
        add_prio: *const ::libc::c_char,
        err_pos: *mut *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_cipher_suite_get_name(
        kx_algorithm: gnutls_kx_algorithm_t::Type,
        cipher_algorithm: gnutls_cipher_algorithm_t,
        mac_algorithm: gnutls_mac_algorithm_t::Type,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_protocol_get_version(session: gnutls_session_t) -> gnutls_protocol_t::Type;
}
extern "C" {
    pub fn gnutls_protocol_get_name(version: gnutls_protocol_t::Type) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_session_set_data(
        session: gnutls_session_t,
        session_data: *const ::libc::c_void,
        session_data_size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_get_data(
        session: gnutls_session_t,
        session_data: *mut ::libc::c_void,
        session_data_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_get_data2(
        session: gnutls_session_t,
        data: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_get_random(
        session: gnutls_session_t,
        client: *mut gnutls_datum_t,
        server: *mut gnutls_datum_t,
    );
}
extern "C" {
    pub fn gnutls_session_get_master_secret(session: gnutls_session_t, secret: *mut gnutls_datum_t);
}
extern "C" {
    pub fn gnutls_session_get_desc(session: gnutls_session_t) -> *mut ::libc::c_char;
}
pub type gnutls_certificate_verify_function =
    ::std::option::Option<unsafe extern "C" fn(arg1: gnutls_session_t) -> ::libc::c_int>;
extern "C" {
    pub fn gnutls_session_set_verify_function(
        session: gnutls_session_t,
        func: gnutls_certificate_verify_function,
    );
}
pub mod gnutls_vdata_types_t {
    pub type Type = u32;
    pub const GNUTLS_DT_UNKNOWN: Type = 0;
    pub const GNUTLS_DT_DNS_HOSTNAME: Type = 1;
    pub const GNUTLS_DT_KEY_PURPOSE_OID: Type = 2;
    pub const GNUTLS_DT_RFC822NAME: Type = 3;
    pub const GNUTLS_DT_IP_ADDRESS: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_typed_vdata_st {
    pub type_: gnutls_vdata_types_t::Type,
    pub data: *mut ::libc::c_uchar,
    pub size: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_gnutls_typed_vdata_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_typed_vdata_st>(),
        24usize,
        concat!("Size of: ", stringify!(gnutls_typed_vdata_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_typed_vdata_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_typed_vdata_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_typed_vdata_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_typed_vdata_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_typed_vdata_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_typed_vdata_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_typed_vdata_st>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_typed_vdata_st),
            "::",
            stringify!(size)
        )
    );
}
impl Default for gnutls_typed_vdata_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn gnutls_session_set_verify_cert(
        session: gnutls_session_t,
        hostname: *const ::libc::c_char,
        flags: ::libc::c_uint,
    );
}
extern "C" {
    pub fn gnutls_session_set_verify_cert2(
        session: gnutls_session_t,
        data: *mut gnutls_typed_vdata_st,
        elements: ::libc::c_uint,
        flags: ::libc::c_uint,
    );
}
extern "C" {
    pub fn gnutls_session_get_verify_cert_status(arg1: gnutls_session_t) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_session_set_premaster(
        session: gnutls_session_t,
        entity: ::libc::c_uint,
        version: gnutls_protocol_t::Type,
        kx: gnutls_kx_algorithm_t::Type,
        cipher: gnutls_cipher_algorithm_t,
        mac: gnutls_mac_algorithm_t::Type,
        comp: gnutls_compression_method_t::Type,
        master: *const gnutls_datum_t,
        session_id: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_get_id(
        session: gnutls_session_t,
        session_id: *mut ::libc::c_void,
        session_id_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_get_id2(
        session: gnutls_session_t,
        session_id: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_set_id(
        session: gnutls_session_t,
        sid: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_channel_binding(
        session: gnutls_session_t,
        cbtype: gnutls_channel_binding_t::Type,
        cb: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_is_resumed(session: gnutls_session_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_resumption_requested(session: gnutls_session_t) -> ::libc::c_int;
}
pub type gnutls_db_store_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::libc::c_void,
        key: gnutls_datum_t,
        data: gnutls_datum_t,
    ) -> ::libc::c_int,
>;
pub type gnutls_db_remove_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::libc::c_void, key: gnutls_datum_t) -> ::libc::c_int,
>;
pub type gnutls_db_retr_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::libc::c_void, key: gnutls_datum_t) -> gnutls_datum_t,
>;
extern "C" {
    pub fn gnutls_db_set_cache_expiration(session: gnutls_session_t, seconds: ::libc::c_int);
}
extern "C" {
    pub fn gnutls_db_get_default_cache_expiration() -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_db_remove_session(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_db_set_retrieve_function(
        session: gnutls_session_t,
        retr_func: gnutls_db_retr_func,
    );
}
extern "C" {
    pub fn gnutls_db_set_remove_function(
        session: gnutls_session_t,
        rem_func: gnutls_db_remove_func,
    );
}
extern "C" {
    pub fn gnutls_db_set_store_function(
        session: gnutls_session_t,
        store_func: gnutls_db_store_func,
    );
}
extern "C" {
    pub fn gnutls_db_set_ptr(session: gnutls_session_t, ptr: *mut ::libc::c_void);
}
extern "C" {
    pub fn gnutls_db_get_ptr(session: gnutls_session_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn gnutls_db_check_entry(
        session: gnutls_session_t,
        session_entry: gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_db_check_entry_time(entry: *mut gnutls_datum_t) -> time_t;
}
extern "C" {
    pub fn gnutls_db_check_entry_expire_time(entry: *mut gnutls_datum_t) -> time_t;
}
pub type gnutls_handshake_hook_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        htype: ::libc::c_uint,
        when: ::libc::c_uint,
        incoming: ::libc::c_uint,
        msg: *const gnutls_datum_t,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_handshake_set_hook_function(
        session: gnutls_session_t,
        htype: ::libc::c_uint,
        when: ::libc::c_int,
        func: gnutls_handshake_hook_func,
    );
}
pub type gnutls_handshake_simple_hook_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: gnutls_session_t) -> ::libc::c_int>;
extern "C" {
    pub fn gnutls_handshake_set_post_client_hello_function(
        session: gnutls_session_t,
        func: gnutls_handshake_simple_hook_func,
    );
}
extern "C" {
    pub fn gnutls_handshake_set_max_packet_length(session: gnutls_session_t, max: usize);
}
extern "C" {
    pub fn gnutls_check_version(req_version: *const ::libc::c_char) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_credentials_clear(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_credentials_set(
        session: gnutls_session_t,
        type_: gnutls_credentials_type_t::Type,
        cred: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_credentials_get(
        session: gnutls_session_t,
        type_: gnutls_credentials_type_t::Type,
        cred: *mut *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_pubkey_st {
    _unused: [u8; 0],
}
pub type gnutls_pubkey_t = *mut gnutls_pubkey_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_privkey_st {
    _unused: [u8; 0],
}
pub type gnutls_privkey_t = *mut gnutls_privkey_st;
pub type gnutls_x509_privkey_t = *mut gnutls_x509_privkey_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_crl_int {
    _unused: [u8; 0],
}
pub type gnutls_x509_crl_t = *mut gnutls_x509_crl_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_crt_int {
    _unused: [u8; 0],
}
pub type gnutls_x509_crt_t = *mut gnutls_x509_crt_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_crq_int {
    _unused: [u8; 0],
}
pub type gnutls_x509_crq_t = *mut gnutls_x509_crq_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_openpgp_keyring_int {
    _unused: [u8; 0],
}
pub type gnutls_openpgp_keyring_t = *mut gnutls_openpgp_keyring_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_certificate_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_certificate_credentials_t = *mut gnutls_certificate_credentials_st;
pub type gnutls_certificate_server_credentials = gnutls_certificate_credentials_t;
pub type gnutls_certificate_client_credentials = gnutls_certificate_credentials_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_anon_server_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_anon_server_credentials_t = *mut gnutls_anon_server_credentials_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_anon_client_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_anon_client_credentials_t = *mut gnutls_anon_client_credentials_st;
extern "C" {
    pub fn gnutls_anon_free_server_credentials(sc: gnutls_anon_server_credentials_t);
}
extern "C" {
    pub fn gnutls_anon_allocate_server_credentials(
        sc: *mut gnutls_anon_server_credentials_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_anon_set_server_dh_params(
        res: gnutls_anon_server_credentials_t,
        dh_params: gnutls_dh_params_t,
    );
}
extern "C" {
    pub fn gnutls_anon_set_server_known_dh_params(
        res: gnutls_anon_server_credentials_t,
        sec_param: gnutls_sec_param_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_anon_set_server_params_function(
        res: gnutls_anon_server_credentials_t,
        func: gnutls_params_function,
    );
}
extern "C" {
    pub fn gnutls_anon_free_client_credentials(sc: gnutls_anon_client_credentials_t);
}
extern "C" {
    pub fn gnutls_anon_allocate_client_credentials(
        sc: *mut gnutls_anon_client_credentials_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_free_credentials(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_allocate_credentials(
        res: *mut gnutls_certificate_credentials_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_get_issuer(
        sc: gnutls_certificate_credentials_t,
        cert: gnutls_x509_crt_t,
        issuer: *mut gnutls_x509_crt_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_get_crt_raw(
        sc: gnutls_certificate_credentials_t,
        idx1: ::libc::c_uint,
        idx2: ::libc::c_uint,
        cert: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_free_keys(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_free_cas(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_free_ca_names(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_free_crls(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_set_dh_params(
        res: gnutls_certificate_credentials_t,
        dh_params: gnutls_dh_params_t,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_known_dh_params(
        res: gnutls_certificate_credentials_t,
        sec_param: gnutls_sec_param_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_verify_flags(
        res: gnutls_certificate_credentials_t,
        flags: ::libc::c_uint,
    );
}
extern "C" {
    pub fn gnutls_certificate_get_verify_flags(
        res: gnutls_certificate_credentials_t,
    ) -> ::libc::c_uint;
}
pub mod gnutls_certificate_flags {
    pub type Type = u32;
    pub const GNUTLS_CERTIFICATE_SKIP_KEY_CERT_MATCH: Type = 1;
    pub const GNUTLS_CERTIFICATE_API_V2: Type = 2;
    pub const GNUTLS_CERTIFICATE_SKIP_OCSP_RESPONSE_CHECK: Type = 4;
    pub const GNUTLS_CERTIFICATE_VERIFY_CRLS: Type = 8;
}
extern "C" {
    pub fn gnutls_certificate_set_flags(
        arg1: gnutls_certificate_credentials_t,
        flags: ::libc::c_uint,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_verify_limits(
        res: gnutls_certificate_credentials_t,
        max_bits: ::libc::c_uint,
        max_depth: ::libc::c_uint,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_x509_system_trust(
        cred: gnutls_certificate_credentials_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_trust_file(
        cred: gnutls_certificate_credentials_t,
        cafile: *const ::libc::c_char,
        type_: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_trust_dir(
        cred: gnutls_certificate_credentials_t,
        ca_dir: *const ::libc::c_char,
        type_: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_trust_mem(
        res: gnutls_certificate_credentials_t,
        ca: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_crl_file(
        res: gnutls_certificate_credentials_t,
        crlfile: *const ::libc::c_char,
        type_: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_crl_mem(
        res: gnutls_certificate_credentials_t,
        CRL: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key_file(
        res: gnutls_certificate_credentials_t,
        certfile: *const ::libc::c_char,
        keyfile: *const ::libc::c_char,
        type_: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key_file2(
        res: gnutls_certificate_credentials_t,
        certfile: *const ::libc::c_char,
        keyfile: *const ::libc::c_char,
        type_: gnutls_x509_crt_fmt_t::Type,
        pass: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key_mem(
        res: gnutls_certificate_credentials_t,
        cert: *const gnutls_datum_t,
        key: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key_mem2(
        res: gnutls_certificate_credentials_t,
        cert: *const gnutls_datum_t,
        key: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t::Type,
        pass: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_send_x509_rdn_sequence(
        session: gnutls_session_t,
        status: ::libc::c_int,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_x509_simple_pkcs12_file(
        res: gnutls_certificate_credentials_t,
        pkcs12file: *const ::libc::c_char,
        type_: gnutls_x509_crt_fmt_t::Type,
        password: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_simple_pkcs12_mem(
        res: gnutls_certificate_credentials_t,
        p12blob: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t::Type,
        password: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key(
        res: gnutls_certificate_credentials_t,
        cert_list: *mut gnutls_x509_crt_t,
        cert_list_size: ::libc::c_int,
        key: gnutls_x509_privkey_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_trust(
        res: gnutls_certificate_credentials_t,
        ca_list: *mut gnutls_x509_crt_t,
        ca_list_size: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_crl(
        res: gnutls_certificate_credentials_t,
        crl_list: *mut gnutls_x509_crl_t,
        crl_list_size: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_get_x509_key(
        res: gnutls_certificate_credentials_t,
        index: ::libc::c_uint,
        key: *mut gnutls_x509_privkey_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_get_x509_crt(
        res: gnutls_certificate_credentials_t,
        index: ::libc::c_uint,
        crt_list: *mut *mut gnutls_x509_crt_t,
        crt_list_size: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
pub type gnutls_status_request_ocsp_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        ptr: *mut ::libc::c_void,
        ocsp_response: *mut gnutls_datum_t,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_function(
        res: gnutls_certificate_credentials_t,
        ocsp_func: gnutls_status_request_ocsp_func,
        ptr: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_function2(
        res: gnutls_certificate_credentials_t,
        idx: ::libc::c_uint,
        ocsp_func: gnutls_status_request_ocsp_func,
        ptr: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_file(
        res: gnutls_certificate_credentials_t,
        response_file: *const ::libc::c_char,
        idx: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_file2(
        res: gnutls_certificate_credentials_t,
        response_file: *const ::libc::c_char,
        idx: ::libc::c_uint,
        fmt: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_mem(
        res: gnutls_certificate_credentials_t,
        resp: *const gnutls_datum_t,
        idx: ::libc::c_uint,
        fmt: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_ocsp_data_st {
    pub version: ::libc::c_uint,
    pub response: gnutls_datum_t,
    pub exptime: time_t,
    pub padding: [::libc::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_gnutls_ocsp_data_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_ocsp_data_st>(),
        64usize,
        concat!("Size of: ", stringify!(gnutls_ocsp_data_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_ocsp_data_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_ocsp_data_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_ocsp_data_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_ocsp_data_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_ocsp_data_st>())).response as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_ocsp_data_st),
            "::",
            stringify!(response)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_ocsp_data_st>())).exptime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_ocsp_data_st),
            "::",
            stringify!(exptime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_ocsp_data_st>())).padding as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_ocsp_data_st),
            "::",
            stringify!(padding)
        )
    );
}
impl Default for gnutls_ocsp_data_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn gnutls_certificate_get_ocsp_expiration(
        sc: gnutls_certificate_credentials_t,
        idx: ::libc::c_uint,
        oidx: ::libc::c_int,
        flags: ::libc::c_uint,
    ) -> time_t;
}
extern "C" {
    pub fn gnutls_ocsp_status_request_enable_client(
        session: gnutls_session_t,
        responder_id: *mut gnutls_datum_t,
        responder_id_size: usize,
        request_extensions: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_ocsp_status_request_get(
        session: gnutls_session_t,
        response: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_ocsp_status_request_is_checked(
        session: gnutls_session_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_ocsp_status_request_get2(
        session: gnutls_session_t,
        idx: ::libc::c_uint,
        response: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_rawpk_key_mem(
        cred: gnutls_certificate_credentials_t,
        spki: *const gnutls_datum_t,
        pkey: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
        pass: *const ::libc::c_char,
        key_usage: ::libc::c_uint,
        names: *mut *const ::libc::c_char,
        names_length: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_rawpk_key_file(
        cred: gnutls_certificate_credentials_t,
        rawpkfile: *const ::libc::c_char,
        privkeyfile: *const ::libc::c_char,
        format: gnutls_x509_crt_fmt_t::Type,
        pass: *const ::libc::c_char,
        key_usage: ::libc::c_uint,
        names: *mut *const ::libc::c_char,
        names_length: ::libc::c_uint,
        privkey_flags: ::libc::c_uint,
        pkcs11_flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_global_init() -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_global_deinit();
}
pub type gnutls_time_func = ::std::option::Option<unsafe extern "C" fn(t: *mut time_t) -> time_t>;
pub type mutex_init_func =
    ::std::option::Option<unsafe extern "C" fn(mutex: *mut *mut ::libc::c_void) -> ::libc::c_int>;
pub type mutex_lock_func =
    ::std::option::Option<unsafe extern "C" fn(mutex: *mut *mut ::libc::c_void) -> ::libc::c_int>;
pub type mutex_unlock_func =
    ::std::option::Option<unsafe extern "C" fn(mutex: *mut *mut ::libc::c_void) -> ::libc::c_int>;
pub type mutex_deinit_func =
    ::std::option::Option<unsafe extern "C" fn(mutex: *mut *mut ::libc::c_void) -> ::libc::c_int>;
extern "C" {
    pub fn gnutls_global_set_mutex(
        init: mutex_init_func,
        deinit: mutex_deinit_func,
        lock: mutex_lock_func,
        unlock: mutex_unlock_func,
    );
}
pub type gnutls_alloc_function =
    ::std::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::libc::c_void>;
pub type gnutls_calloc_function =
    ::std::option::Option<unsafe extern "C" fn(arg1: usize, arg2: usize) -> *mut ::libc::c_void>;
pub type gnutls_is_secure_function =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::libc::c_void) -> ::libc::c_int>;
pub type gnutls_free_function =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>;
pub type gnutls_realloc_function = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::libc::c_void, arg2: usize) -> *mut ::libc::c_void,
>;
extern "C" {
    pub fn gnutls_global_set_time_function(time_func: gnutls_time_func);
}
extern "C" {
    #[link_name = "\u{1}gnutls_malloc"]
    pub static mut gnutls_malloc: gnutls_alloc_function;
}
extern "C" {
    #[link_name = "\u{1}gnutls_realloc"]
    pub static mut gnutls_realloc: gnutls_realloc_function;
}
extern "C" {
    #[link_name = "\u{1}gnutls_calloc"]
    pub static mut gnutls_calloc: gnutls_calloc_function;
}
extern "C" {
    #[link_name = "\u{1}gnutls_free"]
    pub static mut gnutls_free: gnutls_free_function;
}
extern "C" {
    #[link_name = "\u{1}gnutls_strdup"]
    pub static mut gnutls_strdup: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::libc::c_char) -> *mut ::libc::c_char,
    >;
}
extern "C" {
    pub fn gnutls_memset(data: *mut ::libc::c_void, c: ::libc::c_int, size: usize);
}
extern "C" {
    pub fn gnutls_memcmp(
        s1: *const ::libc::c_void,
        s2: *const ::libc::c_void,
        n: usize,
    ) -> ::libc::c_int;
}
pub type gnutls_log_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int, arg2: *const ::libc::c_char)>;
pub type gnutls_audit_log_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: gnutls_session_t, arg2: *const ::libc::c_char),
>;
extern "C" {
    pub fn gnutls_global_set_log_function(log_func: gnutls_log_func);
}
extern "C" {
    pub fn gnutls_global_set_audit_log_function(log_func: gnutls_audit_log_func);
}
extern "C" {
    pub fn gnutls_global_set_log_level(level: ::libc::c_int);
}
pub type gnutls_keylog_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        label: *const ::libc::c_char,
        secret: *const gnutls_datum_t,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_session_get_keylog_function(session: gnutls_session_t) -> gnutls_keylog_func;
}
extern "C" {
    pub fn gnutls_session_set_keylog_function(session: gnutls_session_t, func: gnutls_keylog_func);
}
extern "C" {
    pub fn gnutls_dh_params_init(dh_params: *mut gnutls_dh_params_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_deinit(dh_params: gnutls_dh_params_t);
}
extern "C" {
    pub fn gnutls_dh_params_import_raw(
        dh_params: gnutls_dh_params_t,
        prime: *const gnutls_datum_t,
        generator: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_import_dsa(
        dh_params: gnutls_dh_params_t,
        key: gnutls_x509_privkey_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_import_raw2(
        dh_params: gnutls_dh_params_t,
        prime: *const gnutls_datum_t,
        generator: *const gnutls_datum_t,
        key_bits: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_import_raw3(
        dh_params: gnutls_dh_params_t,
        prime: *const gnutls_datum_t,
        q: *const gnutls_datum_t,
        generator: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_import_pkcs3(
        params: gnutls_dh_params_t,
        pkcs3_params: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_generate2(
        params: gnutls_dh_params_t,
        bits: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_export_pkcs3(
        params: gnutls_dh_params_t,
        format: gnutls_x509_crt_fmt_t::Type,
        params_data: *mut ::libc::c_uchar,
        params_data_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_export2_pkcs3(
        params: gnutls_dh_params_t,
        format: gnutls_x509_crt_fmt_t::Type,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_export_raw(
        params: gnutls_dh_params_t,
        prime: *mut gnutls_datum_t,
        generator: *mut gnutls_datum_t,
        bits: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_cpy(dst: gnutls_dh_params_t, src: gnutls_dh_params_t) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::libc::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for iovec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn readv(__fd: ::libc::c_int, __iovec: *const iovec, __count: ::libc::c_int) -> isize;
}
extern "C" {
    pub fn writev(__fd: ::libc::c_int, __iovec: *const iovec, __count: ::libc::c_int) -> isize;
}
extern "C" {
    pub fn preadv(
        __fd: ::libc::c_int,
        __iovec: *const iovec,
        __count: ::libc::c_int,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwritev(
        __fd: ::libc::c_int,
        __iovec: *const iovec,
        __count: ::libc::c_int,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn preadv64(
        __fd: ::libc::c_int,
        __iovec: *const iovec,
        __count: ::libc::c_int,
        __offset: __off64_t,
    ) -> isize;
}
extern "C" {
    pub fn pwritev64(
        __fd: ::libc::c_int,
        __iovec: *const iovec,
        __count: ::libc::c_int,
        __offset: __off64_t,
    ) -> isize;
}
extern "C" {
    pub fn preadv2(
        __fp: ::libc::c_int,
        __iovec: *const iovec,
        __count: ::libc::c_int,
        __offset: __off_t,
        ___flags: ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn pwritev2(
        __fd: ::libc::c_int,
        __iodev: *const iovec,
        __count: ::libc::c_int,
        __offset: __off_t,
        __flags: ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn preadv64v2(
        __fp: ::libc::c_int,
        __iovec: *const iovec,
        __count: ::libc::c_int,
        __offset: __off64_t,
        ___flags: ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn pwritev64v2(
        __fd: ::libc::c_int,
        __iodev: *const iovec,
        __count: ::libc::c_int,
        __offset: __off64_t,
        __flags: ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn process_vm_readv(
        __pid: pid_t,
        __lvec: *const iovec,
        __liovcnt: ::libc::c_ulong,
        __rvec: *const iovec,
        __riovcnt: ::libc::c_ulong,
        __flags: ::libc::c_ulong,
    ) -> isize;
}
extern "C" {
    pub fn process_vm_writev(
        __pid: pid_t,
        __lvec: *const iovec,
        __liovcnt: ::libc::c_ulong,
        __rvec: *const iovec,
        __riovcnt: ::libc::c_ulong,
        __flags: ::libc::c_ulong,
    ) -> isize;
}
pub type giovec_t = iovec;
pub type gnutls_pull_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_transport_ptr_t,
        arg2: *mut ::libc::c_void,
        arg3: usize,
    ) -> isize,
>;
pub type gnutls_push_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_transport_ptr_t,
        arg2: *const ::libc::c_void,
        arg3: usize,
    ) -> isize,
>;
extern "C" {
    pub fn gnutls_system_recv_timeout(
        ptr: gnutls_transport_ptr_t,
        ms: ::libc::c_uint,
    ) -> ::libc::c_int;
}
pub type gnutls_pull_timeout_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: gnutls_transport_ptr_t, ms: ::libc::c_uint) -> ::libc::c_int,
>;
pub type gnutls_vec_push_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_transport_ptr_t,
        iov: *const giovec_t,
        iovcnt: ::libc::c_int,
    ) -> isize,
>;
pub type gnutls_errno_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: gnutls_transport_ptr_t) -> ::libc::c_int>;
extern "C" {
    pub fn gnutls_transport_set_int2(session: gnutls_session_t, r: ::libc::c_int, s: ::libc::c_int);
}
extern "C" {
    pub fn gnutls_transport_get_int2(
        session: gnutls_session_t,
        r: *mut ::libc::c_int,
        s: *mut ::libc::c_int,
    );
}
extern "C" {
    pub fn gnutls_transport_get_int(session: gnutls_session_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_transport_set_ptr(session: gnutls_session_t, ptr: gnutls_transport_ptr_t);
}
extern "C" {
    pub fn gnutls_transport_set_ptr2(
        session: gnutls_session_t,
        recv_ptr: gnutls_transport_ptr_t,
        send_ptr: gnutls_transport_ptr_t,
    );
}
extern "C" {
    pub fn gnutls_transport_get_ptr(session: gnutls_session_t) -> gnutls_transport_ptr_t;
}
extern "C" {
    pub fn gnutls_transport_get_ptr2(
        session: gnutls_session_t,
        recv_ptr: *mut gnutls_transport_ptr_t,
        send_ptr: *mut gnutls_transport_ptr_t,
    );
}
extern "C" {
    pub fn gnutls_transport_set_vec_push_function(
        session: gnutls_session_t,
        vec_func: gnutls_vec_push_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_push_function(
        session: gnutls_session_t,
        push_func: gnutls_push_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_pull_function(
        session: gnutls_session_t,
        pull_func: gnutls_pull_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_pull_timeout_function(
        session: gnutls_session_t,
        func: gnutls_pull_timeout_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_errno_function(
        session: gnutls_session_t,
        errno_func: gnutls_errno_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_errno(session: gnutls_session_t, err: ::libc::c_int);
}
extern "C" {
    pub fn gnutls_session_set_ptr(session: gnutls_session_t, ptr: *mut ::libc::c_void);
}
extern "C" {
    pub fn gnutls_session_get_ptr(session: gnutls_session_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn gnutls_openpgp_send_cert(
        session: gnutls_session_t,
        status: gnutls_openpgp_crt_status_t::Type,
    );
}
extern "C" {
    pub fn gnutls_fingerprint(
        algo: gnutls_digest_algorithm_t::Type,
        data: *const gnutls_datum_t,
        result: *mut ::libc::c_void,
        result_size: *mut usize,
    ) -> ::libc::c_int;
}
pub mod gnutls_random_art {
    pub type Type = u32;
    pub const GNUTLS_RANDOM_ART_OPENSSH: Type = 1;
}
pub use self::gnutls_random_art::Type as gnutls_random_art_t;
extern "C" {
    pub fn gnutls_random_art(
        type_: gnutls_random_art_t,
        key_type: *const ::libc::c_char,
        key_size: ::libc::c_uint,
        fpr: *mut ::libc::c_void,
        fpr_size: usize,
        art: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_idna_map(
        input: *const ::libc::c_char,
        ilen: ::libc::c_uint,
        out: *mut gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_idna_reverse_map(
        input: *const ::libc::c_char,
        ilen: ::libc::c_uint,
        out: *mut gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_srp_server_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_srp_server_credentials_t = *mut gnutls_srp_server_credentials_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_srp_client_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_srp_client_credentials_t = *mut gnutls_srp_client_credentials_st;
extern "C" {
    pub fn gnutls_srp_free_client_credentials(sc: gnutls_srp_client_credentials_t);
}
extern "C" {
    pub fn gnutls_srp_allocate_client_credentials(
        sc: *mut gnutls_srp_client_credentials_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srp_set_client_credentials(
        res: gnutls_srp_client_credentials_t,
        username: *const ::libc::c_char,
        password: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srp_free_server_credentials(sc: gnutls_srp_server_credentials_t);
}
extern "C" {
    pub fn gnutls_srp_allocate_server_credentials(
        sc: *mut gnutls_srp_server_credentials_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srp_set_server_credentials_file(
        res: gnutls_srp_server_credentials_t,
        password_file: *const ::libc::c_char,
        password_conf_file: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srp_server_get_username(session: gnutls_session_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_srp_set_prime_bits(session: gnutls_session_t, bits: ::libc::c_uint);
}
extern "C" {
    pub fn gnutls_srp_verifier(
        username: *const ::libc::c_char,
        password: *const ::libc::c_char,
        salt: *const gnutls_datum_t,
        generator: *const gnutls_datum_t,
        prime: *const gnutls_datum_t,
        res: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}gnutls_srp_8192_group_prime"]
    pub static gnutls_srp_8192_group_prime: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_srp_8192_group_generator"]
    pub static gnutls_srp_8192_group_generator: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_srp_4096_group_prime"]
    pub static gnutls_srp_4096_group_prime: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_srp_4096_group_generator"]
    pub static gnutls_srp_4096_group_generator: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_srp_3072_group_prime"]
    pub static gnutls_srp_3072_group_prime: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_srp_3072_group_generator"]
    pub static gnutls_srp_3072_group_generator: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_srp_2048_group_prime"]
    pub static gnutls_srp_2048_group_prime: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_srp_2048_group_generator"]
    pub static gnutls_srp_2048_group_generator: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_srp_1536_group_prime"]
    pub static gnutls_srp_1536_group_prime: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_srp_1536_group_generator"]
    pub static gnutls_srp_1536_group_generator: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_srp_1024_group_prime"]
    pub static gnutls_srp_1024_group_prime: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_srp_1024_group_generator"]
    pub static gnutls_srp_1024_group_generator: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_8192_group_prime"]
    pub static gnutls_ffdhe_8192_group_prime: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_8192_group_q"]
    pub static gnutls_ffdhe_8192_group_q: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_8192_group_generator"]
    pub static gnutls_ffdhe_8192_group_generator: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_8192_key_bits"]
    pub static gnutls_ffdhe_8192_key_bits: ::libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_6144_group_prime"]
    pub static gnutls_ffdhe_6144_group_prime: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_6144_group_q"]
    pub static gnutls_ffdhe_6144_group_q: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_6144_group_generator"]
    pub static gnutls_ffdhe_6144_group_generator: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_6144_key_bits"]
    pub static gnutls_ffdhe_6144_key_bits: ::libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_4096_group_prime"]
    pub static gnutls_ffdhe_4096_group_prime: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_4096_group_q"]
    pub static gnutls_ffdhe_4096_group_q: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_4096_group_generator"]
    pub static gnutls_ffdhe_4096_group_generator: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_4096_key_bits"]
    pub static gnutls_ffdhe_4096_key_bits: ::libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_3072_group_prime"]
    pub static gnutls_ffdhe_3072_group_prime: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_3072_group_q"]
    pub static gnutls_ffdhe_3072_group_q: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_3072_group_generator"]
    pub static gnutls_ffdhe_3072_group_generator: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_3072_key_bits"]
    pub static gnutls_ffdhe_3072_key_bits: ::libc::c_uint;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_2048_group_prime"]
    pub static gnutls_ffdhe_2048_group_prime: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_2048_group_q"]
    pub static gnutls_ffdhe_2048_group_q: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_2048_group_generator"]
    pub static gnutls_ffdhe_2048_group_generator: gnutls_datum_t;
}
extern "C" {
    #[link_name = "\u{1}gnutls_ffdhe_2048_key_bits"]
    pub static gnutls_ffdhe_2048_key_bits: ::libc::c_uint;
}
pub type gnutls_srp_server_credentials_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *const ::libc::c_char,
        salt: *mut gnutls_datum_t,
        verifier: *mut gnutls_datum_t,
        generator: *mut gnutls_datum_t,
        prime: *mut gnutls_datum_t,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_srp_set_server_credentials_function(
        cred: gnutls_srp_server_credentials_t,
        func: gnutls_srp_server_credentials_function,
    );
}
pub type gnutls_srp_client_credentials_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        arg2: *mut *mut ::libc::c_char,
        arg3: *mut *mut ::libc::c_char,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_srp_set_client_credentials_function(
        cred: gnutls_srp_client_credentials_t,
        func: gnutls_srp_client_credentials_function,
    );
}
extern "C" {
    pub fn gnutls_srp_base64_encode(
        data: *const gnutls_datum_t,
        result: *mut ::libc::c_char,
        result_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srp_base64_encode2(
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srp_base64_decode(
        b64_data: *const gnutls_datum_t,
        result: *mut ::libc::c_char,
        result_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srp_base64_decode2(
        b64_data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_srp_set_server_fake_salt_seed(
        sc: gnutls_srp_server_credentials_t,
        seed: *const gnutls_datum_t,
        salt_length: ::libc::c_uint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_psk_server_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_psk_server_credentials_t = *mut gnutls_psk_server_credentials_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_psk_client_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_psk_client_credentials_t = *mut gnutls_psk_client_credentials_st;
pub mod gnutls_psk_key_flags {
    pub type Type = u32;
    pub const GNUTLS_PSK_KEY_RAW: Type = 0;
    pub const GNUTLS_PSK_KEY_HEX: Type = 1;
}
extern "C" {
    pub fn gnutls_psk_free_client_credentials(sc: gnutls_psk_client_credentials_t);
}
extern "C" {
    pub fn gnutls_psk_allocate_client_credentials(
        sc: *mut gnutls_psk_client_credentials_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_client_credentials(
        res: gnutls_psk_client_credentials_t,
        username: *const ::libc::c_char,
        key: *const gnutls_datum_t,
        flags: gnutls_psk_key_flags::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_client_credentials2(
        res: gnutls_psk_client_credentials_t,
        username: *const gnutls_datum_t,
        key: *const gnutls_datum_t,
        flags: gnutls_psk_key_flags::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_psk_free_server_credentials(sc: gnutls_psk_server_credentials_t);
}
extern "C" {
    pub fn gnutls_psk_allocate_server_credentials(
        sc: *mut gnutls_psk_server_credentials_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_server_credentials_file(
        res: gnutls_psk_server_credentials_t,
        password_file: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_server_credentials_hint(
        res: gnutls_psk_server_credentials_t,
        hint: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_psk_server_get_username(session: gnutls_session_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_psk_server_get_username2(
        session: gnutls_session_t,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_psk_client_get_hint(session: gnutls_session_t) -> *const ::libc::c_char;
}
pub type gnutls_psk_server_credentials_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *const ::libc::c_char,
        key: *mut gnutls_datum_t,
    ) -> ::libc::c_int,
>;
pub type gnutls_psk_server_credentials_function2 = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *const gnutls_datum_t,
        key: *mut gnutls_datum_t,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_psk_set_server_credentials_function(
        cred: gnutls_psk_server_credentials_t,
        func: gnutls_psk_server_credentials_function,
    );
}
extern "C" {
    pub fn gnutls_psk_set_server_credentials_function2(
        cred: gnutls_psk_server_credentials_t,
        func: gnutls_psk_server_credentials_function2,
    );
}
pub type gnutls_psk_client_credentials_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *mut *mut ::libc::c_char,
        key: *mut gnutls_datum_t,
    ) -> ::libc::c_int,
>;
pub type gnutls_psk_client_credentials_function2 = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *mut gnutls_datum_t,
        key: *mut gnutls_datum_t,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_psk_set_client_credentials_function(
        cred: gnutls_psk_client_credentials_t,
        func: gnutls_psk_client_credentials_function,
    );
}
extern "C" {
    pub fn gnutls_psk_set_client_credentials_function2(
        cred: gnutls_psk_client_credentials_t,
        func: gnutls_psk_client_credentials_function2,
    );
}
extern "C" {
    pub fn gnutls_hex_encode(
        data: *const gnutls_datum_t,
        result: *mut ::libc::c_char,
        result_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_hex_decode(
        hex_data: *const gnutls_datum_t,
        result: *mut ::libc::c_void,
        result_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_hex_encode2(
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_hex_decode2(
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_server_dh_params(
        res: gnutls_psk_server_credentials_t,
        dh_params: gnutls_dh_params_t,
    );
}
extern "C" {
    pub fn gnutls_psk_set_server_known_dh_params(
        res: gnutls_psk_server_credentials_t,
        sec_param: gnutls_sec_param_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_server_params_function(
        res: gnutls_psk_server_credentials_t,
        func: gnutls_params_function,
    );
}
pub mod gnutls_x509_subject_alt_name_t {
    pub type Type = u32;
    pub const GNUTLS_SAN_DNSNAME: Type = 1;
    pub const GNUTLS_SAN_RFC822NAME: Type = 2;
    pub const GNUTLS_SAN_URI: Type = 3;
    pub const GNUTLS_SAN_IPADDRESS: Type = 4;
    pub const GNUTLS_SAN_OTHERNAME: Type = 5;
    pub const GNUTLS_SAN_DN: Type = 6;
    pub const GNUTLS_SAN_REGISTERED_ID: Type = 7;
    pub const GNUTLS_SAN_MAX: Type = 7;
    pub const GNUTLS_SAN_OTHERNAME_XMPP: Type = 1000;
    pub const GNUTLS_SAN_OTHERNAME_KRB5PRINCIPAL: Type = 1001;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_openpgp_crt_int {
    _unused: [u8; 0],
}
pub type gnutls_openpgp_crt_t = *mut gnutls_openpgp_crt_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_openpgp_privkey_int {
    _unused: [u8; 0],
}
pub type gnutls_openpgp_privkey_t = *mut gnutls_openpgp_privkey_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_pkcs11_privkey_st {
    _unused: [u8; 0],
}
pub type gnutls_pkcs11_privkey_t = *mut gnutls_pkcs11_privkey_st;
pub mod gnutls_privkey_type_t {
    pub type Type = u32;
    pub const GNUTLS_PRIVKEY_X509: Type = 0;
    pub const GNUTLS_PRIVKEY_OPENPGP: Type = 1;
    pub const GNUTLS_PRIVKEY_PKCS11: Type = 2;
    pub const GNUTLS_PRIVKEY_EXT: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnutls_retr2_st {
    pub cert_type: gnutls_certificate_type_t::Type,
    pub key_type: gnutls_privkey_type_t::Type,
    pub cert: gnutls_retr2_st__bindgen_ty_1,
    pub ncerts: ::libc::c_uint,
    pub key: gnutls_retr2_st__bindgen_ty_2,
    pub deinit_all: ::libc::c_uint,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union gnutls_retr2_st__bindgen_ty_1 {
    pub x509: *mut gnutls_x509_crt_t,
    pub pgp: gnutls_openpgp_crt_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_gnutls_retr2_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_retr2_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(gnutls_retr2_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_retr2_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_retr2_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_1>())).x509 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_1),
            "::",
            stringify!(x509)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_1>())).pgp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_1),
            "::",
            stringify!(pgp)
        )
    );
}
impl Default for gnutls_retr2_st__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union gnutls_retr2_st__bindgen_ty_2 {
    pub x509: gnutls_x509_privkey_t,
    pub pgp: gnutls_openpgp_privkey_t,
    pub pkcs11: gnutls_pkcs11_privkey_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_gnutls_retr2_st__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_retr2_st__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(gnutls_retr2_st__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_retr2_st__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_retr2_st__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_2>())).x509 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_2),
            "::",
            stringify!(x509)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_2>())).pgp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_2),
            "::",
            stringify!(pgp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_2>())).pkcs11 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_2),
            "::",
            stringify!(pkcs11)
        )
    );
}
impl Default for gnutls_retr2_st__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_gnutls_retr2_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_retr2_st>(),
        40usize,
        concat!("Size of: ", stringify!(gnutls_retr2_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_retr2_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_retr2_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).cert_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(cert_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).key_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(key_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).cert as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).ncerts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(ncerts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).deinit_all as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(deinit_all)
        )
    );
}
impl Default for gnutls_retr2_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn gnutls_auth_get_type(session: gnutls_session_t) -> gnutls_credentials_type_t::Type;
}
extern "C" {
    pub fn gnutls_auth_server_get_type(
        session: gnutls_session_t,
    ) -> gnutls_credentials_type_t::Type;
}
extern "C" {
    pub fn gnutls_auth_client_get_type(
        session: gnutls_session_t,
    ) -> gnutls_credentials_type_t::Type;
}
extern "C" {
    pub fn gnutls_dh_set_prime_bits(session: gnutls_session_t, bits: ::libc::c_uint);
}
extern "C" {
    pub fn gnutls_dh_get_secret_bits(session: gnutls_session_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_get_peers_public_bits(session: gnutls_session_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_get_prime_bits(session: gnutls_session_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_get_group(
        session: gnutls_session_t,
        raw_gen: *mut gnutls_datum_t,
        raw_prime: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_dh_get_pubkey(
        session: gnutls_session_t,
        raw_key: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
pub type gnutls_certificate_retrieve_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        req_ca_rdn: *const gnutls_datum_t,
        nreqs: ::libc::c_int,
        pk_algos: *const gnutls_pk_algorithm_t::Type,
        pk_algos_length: ::libc::c_int,
        arg2: *mut gnutls_retr2_st,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_certificate_set_retrieve_function(
        cred: gnutls_certificate_credentials_t,
        func: gnutls_certificate_retrieve_function,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_verify_function(
        cred: gnutls_certificate_credentials_t,
        func: gnutls_certificate_verify_function,
    );
}
extern "C" {
    pub fn gnutls_certificate_server_set_request(
        session: gnutls_session_t,
        req: gnutls_certificate_request_t::Type,
    );
}
extern "C" {
    pub fn gnutls_certificate_get_peers(
        session: gnutls_session_t,
        list_size: *mut ::libc::c_uint,
    ) -> *const gnutls_datum_t;
}
extern "C" {
    pub fn gnutls_certificate_get_ours(session: gnutls_session_t) -> *const gnutls_datum_t;
}
extern "C" {
    pub fn gnutls_certificate_get_peers_subkey_id(
        session: gnutls_session_t,
        id: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_activation_time_peers(session: gnutls_session_t) -> time_t;
}
extern "C" {
    pub fn gnutls_certificate_expiration_time_peers(session: gnutls_session_t) -> time_t;
}
extern "C" {
    pub fn gnutls_certificate_client_get_request_status(
        session: gnutls_session_t,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_certificate_verify_peers2(
        session: gnutls_session_t,
        status: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_verify_peers3(
        session: gnutls_session_t,
        hostname: *const ::libc::c_char,
        status: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_verify_peers(
        session: gnutls_session_t,
        data: *mut gnutls_typed_vdata_st,
        elements: ::libc::c_uint,
        status: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_verification_status_print(
        status: ::libc::c_uint,
        type_: gnutls_certificate_type_t::Type,
        out: *mut gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pem_base64_encode(
        msg: *const ::libc::c_char,
        data: *const gnutls_datum_t,
        result: *mut ::libc::c_char,
        result_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pem_base64_decode(
        header: *const ::libc::c_char,
        b64_data: *const gnutls_datum_t,
        result: *mut ::libc::c_uchar,
        result_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pem_base64_encode2(
        msg: *const ::libc::c_char,
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pem_base64_decode2(
        header: *const ::libc::c_char,
        b64_data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_base64_encode2(
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_base64_decode2(
        b64_data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_params_function(
        res: gnutls_certificate_credentials_t,
        func: gnutls_params_function,
    );
}
extern "C" {
    pub fn gnutls_anon_set_params_function(
        res: gnutls_anon_server_credentials_t,
        func: gnutls_params_function,
    );
}
extern "C" {
    pub fn gnutls_psk_set_params_function(
        res: gnutls_psk_server_credentials_t,
        func: gnutls_params_function,
    );
}
extern "C" {
    pub fn gnutls_hex2bin(
        hex_data: *const ::libc::c_char,
        hex_size: usize,
        bin_data: *mut ::libc::c_void,
        bin_size: *mut usize,
    ) -> ::libc::c_int;
}
pub type gnutls_tdb_store_func = ::std::option::Option<
    unsafe extern "C" fn(
        db_name: *const ::libc::c_char,
        host: *const ::libc::c_char,
        service: *const ::libc::c_char,
        expiration: time_t,
        pubkey: *const gnutls_datum_t,
    ) -> ::libc::c_int,
>;
pub type gnutls_tdb_store_commitment_func = ::std::option::Option<
    unsafe extern "C" fn(
        db_name: *const ::libc::c_char,
        host: *const ::libc::c_char,
        service: *const ::libc::c_char,
        expiration: time_t,
        hash_algo: gnutls_digest_algorithm_t::Type,
        hash: *const gnutls_datum_t,
    ) -> ::libc::c_int,
>;
pub type gnutls_tdb_verify_func = ::std::option::Option<
    unsafe extern "C" fn(
        db_name: *const ::libc::c_char,
        host: *const ::libc::c_char,
        service: *const ::libc::c_char,
        pubkey: *const gnutls_datum_t,
    ) -> ::libc::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_tdb_int {
    _unused: [u8; 0],
}
pub type gnutls_tdb_t = *mut gnutls_tdb_int;
extern "C" {
    pub fn gnutls_tdb_init(tdb: *mut gnutls_tdb_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_tdb_set_store_func(tdb: gnutls_tdb_t, store: gnutls_tdb_store_func);
}
extern "C" {
    pub fn gnutls_tdb_set_store_commitment_func(
        tdb: gnutls_tdb_t,
        cstore: gnutls_tdb_store_commitment_func,
    );
}
extern "C" {
    pub fn gnutls_tdb_set_verify_func(tdb: gnutls_tdb_t, verify: gnutls_tdb_verify_func);
}
extern "C" {
    pub fn gnutls_tdb_deinit(tdb: gnutls_tdb_t);
}
extern "C" {
    pub fn gnutls_verify_stored_pubkey(
        db_name: *const ::libc::c_char,
        tdb: gnutls_tdb_t,
        host: *const ::libc::c_char,
        service: *const ::libc::c_char,
        cert_type: gnutls_certificate_type_t::Type,
        cert: *const gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_store_commitment(
        db_name: *const ::libc::c_char,
        tdb: gnutls_tdb_t,
        host: *const ::libc::c_char,
        service: *const ::libc::c_char,
        hash_algo: gnutls_digest_algorithm_t::Type,
        hash: *const gnutls_datum_t,
        expiration: time_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_store_pubkey(
        db_name: *const ::libc::c_char,
        tdb: gnutls_tdb_t,
        host: *const ::libc::c_char,
        service: *const ::libc::c_char,
        cert_type: gnutls_certificate_type_t::Type,
        cert: *const gnutls_datum_t,
        expiration: time_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_load_file(
        filename: *const ::libc::c_char,
        data: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_url_is_supported(url: *const ::libc::c_char) -> ::libc::c_uint;
}
pub mod gnutls_pin_flag_t {
    pub type Type = u32;
    pub const GNUTLS_PIN_USER: Type = 1;
    pub const GNUTLS_PIN_SO: Type = 2;
    pub const GNUTLS_PIN_FINAL_TRY: Type = 4;
    pub const GNUTLS_PIN_COUNT_LOW: Type = 8;
    pub const GNUTLS_PIN_CONTEXT_SPECIFIC: Type = 16;
    pub const GNUTLS_PIN_WRONG: Type = 32;
}
pub type gnutls_pin_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::libc::c_void,
        attempt: ::libc::c_int,
        token_url: *const ::libc::c_char,
        token_label: *const ::libc::c_char,
        flags: ::libc::c_uint,
        pin: *mut ::libc::c_char,
        pin_max: usize,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_certificate_set_pin_function(
        arg1: gnutls_certificate_credentials_t,
        fn_: gnutls_pin_callback_t,
        userdata: *mut ::libc::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_buffer_st {
    _unused: [u8; 0],
}
pub type gnutls_buffer_t = *mut gnutls_buffer_st;
extern "C" {
    pub fn gnutls_buffer_append_data(
        arg1: gnutls_buffer_t,
        data: *const ::libc::c_void,
        data_size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_utf8_password_normalize(
        password: *const ::libc::c_uchar,
        password_len: ::libc::c_uint,
        out: *mut gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
pub type gnutls_ext_priv_data_t = *mut ::libc::c_void;
extern "C" {
    pub fn gnutls_ext_set_data(
        session: gnutls_session_t,
        type_: ::libc::c_uint,
        arg1: gnutls_ext_priv_data_t,
    );
}
extern "C" {
    pub fn gnutls_ext_get_data(
        session: gnutls_session_t,
        type_: ::libc::c_uint,
        arg1: *mut gnutls_ext_priv_data_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_ext_get_current_msg(session: gnutls_session_t) -> ::libc::c_uint;
}
pub type gnutls_ext_recv_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        data: *const ::libc::c_uchar,
        len: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_ext_send_func = ::std::option::Option<
    unsafe extern "C" fn(session: gnutls_session_t, extdata: gnutls_buffer_t) -> ::libc::c_int,
>;
pub type gnutls_ext_deinit_data_func =
    ::std::option::Option<unsafe extern "C" fn(data: gnutls_ext_priv_data_t)>;
pub type gnutls_ext_pack_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: gnutls_ext_priv_data_t,
        packed_data: gnutls_buffer_t,
    ) -> ::libc::c_int,
>;
pub type gnutls_ext_unpack_func = ::std::option::Option<
    unsafe extern "C" fn(
        packed_data: gnutls_buffer_t,
        data: *mut gnutls_ext_priv_data_t,
    ) -> ::libc::c_int,
>;
pub type gnutls_ext_raw_process_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        tls_id: ::libc::c_uint,
        data: *const ::libc::c_uchar,
        data_size: ::libc::c_uint,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_ext_raw_parse(
        ctx: *mut ::libc::c_void,
        cb: gnutls_ext_raw_process_func,
        data: *const gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
pub mod gnutls_ext_parse_type_t {
    pub type Type = u32;
    pub const GNUTLS_EXT_ANY: Type = 0;
    pub const GNUTLS_EXT_APPLICATION: Type = 1;
    pub const GNUTLS_EXT_TLS: Type = 2;
    pub const GNUTLS_EXT_MANDATORY: Type = 3;
    pub const GNUTLS_EXT_NONE: Type = 4;
    pub const GNUTLS_EXT_VERSION_NEG: Type = 5;
}
pub mod gnutls_ext_flags_t {
    pub type Type = u32;
    pub const GNUTLS_EXT_FLAG_OVERRIDE_INTERNAL: Type = 1;
    pub const GNUTLS_EXT_FLAG_CLIENT_HELLO: Type = 2;
    pub const GNUTLS_EXT_FLAG_TLS12_SERVER_HELLO: Type = 4;
    pub const GNUTLS_EXT_FLAG_TLS13_SERVER_HELLO: Type = 8;
    pub const GNUTLS_EXT_FLAG_EE: Type = 16;
    pub const GNUTLS_EXT_FLAG_HRR: Type = 32;
    pub const GNUTLS_EXT_FLAG_IGNORE_CLIENT_REQUEST: Type = 64;
    pub const GNUTLS_EXT_FLAG_TLS: Type = 128;
    pub const GNUTLS_EXT_FLAG_DTLS: Type = 256;
}
extern "C" {
    pub fn gnutls_ext_register(
        name: *const ::libc::c_char,
        type_: ::libc::c_int,
        parse_point: gnutls_ext_parse_type_t::Type,
        recv_func: gnutls_ext_recv_func,
        send_func: gnutls_ext_send_func,
        deinit_func: gnutls_ext_deinit_data_func,
        pack_func: gnutls_ext_pack_func,
        unpack_func: gnutls_ext_unpack_func,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_ext_register(
        arg1: gnutls_session_t,
        name: *const ::libc::c_char,
        type_: ::libc::c_int,
        parse_point: gnutls_ext_parse_type_t::Type,
        recv_func: gnutls_ext_recv_func,
        send_func: gnutls_ext_send_func,
        deinit_func: gnutls_ext_deinit_data_func,
        pack_func: gnutls_ext_pack_func,
        unpack_func: gnutls_ext_unpack_func,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_ext_get_name(ext: ::libc::c_uint) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_ext_get_name2(
        session: gnutls_session_t,
        tls_id: ::libc::c_uint,
        parse_point: gnutls_ext_parse_type_t::Type,
    ) -> *const ::libc::c_char;
}
pub type gnutls_supp_recv_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        data: *const ::libc::c_uchar,
        data_size: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_supp_send_func = ::std::option::Option<
    unsafe extern "C" fn(session: gnutls_session_t, buf: gnutls_buffer_t) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_supplemental_register(
        name: *const ::libc::c_char,
        type_: gnutls_supplemental_data_format_type_t::Type,
        supp_recv_func: gnutls_supp_recv_func,
        supp_send_func: gnutls_supp_send_func,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_session_supplemental_register(
        session: gnutls_session_t,
        name: *const ::libc::c_char,
        type_: gnutls_supplemental_data_format_type_t::Type,
        supp_recv_func: gnutls_supp_recv_func,
        supp_send_func: gnutls_supp_send_func,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_supplemental_recv(
        session: gnutls_session_t,
        do_recv_supplemental: ::libc::c_uint,
    );
}
extern "C" {
    pub fn gnutls_supplemental_send(
        session: gnutls_session_t,
        do_send_supplemental: ::libc::c_uint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_anti_replay_st {
    _unused: [u8; 0],
}
pub type gnutls_anti_replay_t = *mut gnutls_anti_replay_st;
extern "C" {
    pub fn gnutls_anti_replay_init(anti_replay: *mut gnutls_anti_replay_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_anti_replay_deinit(anti_replay: gnutls_anti_replay_t);
}
extern "C" {
    pub fn gnutls_anti_replay_set_window(anti_replay: gnutls_anti_replay_t, window: ::libc::c_uint);
}
extern "C" {
    pub fn gnutls_anti_replay_enable(session: gnutls_session_t, anti_replay: gnutls_anti_replay_t);
}
pub type gnutls_db_add_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::libc::c_void,
        exp_time: time_t,
        key: *const gnutls_datum_t,
        data: *const gnutls_datum_t,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_anti_replay_set_add_function(
        arg1: gnutls_anti_replay_t,
        add_func: gnutls_db_add_func,
    );
}
extern "C" {
    pub fn gnutls_anti_replay_set_ptr(arg1: gnutls_anti_replay_t, ptr: *mut ::libc::c_void);
}
pub mod gnutls_record_encryption_level_t {
    pub type Type = u32;
    pub const GNUTLS_ENCRYPTION_LEVEL_INITIAL: Type = 0;
    pub const GNUTLS_ENCRYPTION_LEVEL_EARLY: Type = 1;
    pub const GNUTLS_ENCRYPTION_LEVEL_HANDSHAKE: Type = 2;
    pub const GNUTLS_ENCRYPTION_LEVEL_APPLICATION: Type = 3;
}
pub type gnutls_handshake_read_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        level: gnutls_record_encryption_level_t::Type,
        htype: gnutls_handshake_description_t::Type,
        data: *const ::libc::c_void,
        data_size: usize,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_handshake_set_read_function(
        session: gnutls_session_t,
        func: gnutls_handshake_read_func,
    );
}
extern "C" {
    pub fn gnutls_handshake_write(
        session: gnutls_session_t,
        level: gnutls_record_encryption_level_t::Type,
        data: *const ::libc::c_void,
        data_size: usize,
    ) -> ::libc::c_int;
}
pub type gnutls_handshake_secret_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        level: gnutls_record_encryption_level_t::Type,
        secret_read: *const ::libc::c_void,
        secret_write: *const ::libc::c_void,
        secret_size: usize,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_handshake_set_secret_function(
        session: gnutls_session_t,
        func: gnutls_handshake_secret_func,
    );
}
pub type gnutls_alert_read_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        level: gnutls_record_encryption_level_t::Type,
        alert_level: gnutls_alert_level_t::Type,
        alert_desc: gnutls_alert_description_t::Type,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_alert_set_read_function(session: gnutls_session_t, func: gnutls_alert_read_func);
}
extern "C" {
    pub fn gnutls_fips140_mode_enabled() -> ::libc::c_uint;
}
pub mod gnutls_fips_mode_t {
    pub type Type = u32;
    pub const GNUTLS_FIPS140_DISABLED: Type = 0;
    pub const GNUTLS_FIPS140_STRICT: Type = 1;
    pub const GNUTLS_FIPS140_SELFTESTS: Type = 2;
    pub const GNUTLS_FIPS140_LAX: Type = 3;
    pub const GNUTLS_FIPS140_LOG: Type = 4;
}
extern "C" {
    pub fn gnutls_fips140_set_mode(mode: gnutls_fips_mode_t::Type, flags: ::libc::c_uint);
}
pub type gnutls_connection_end_t = ::libc::c_uint;
pub use self::gnutls_compression_method_t::Type as gnutls_compression_method;
pub use self::gnutls_digest_algorithm_t::Type as gnutls_digest_algorithm;
pub use self::gnutls_kx_algorithm_t::Type as gnutls_kx_algorithm;
pub use self::gnutls_mac_algorithm_t::Type as gnutls_mac_algorithm;
pub type gnutls_connection_end = gnutls_connection_end_t;
pub use self::gnutls_certificate_request_t::Type as gnutls_certificate_request;
pub use self::gnutls_certificate_status_t::Type as gnutls_certificate_status;
pub use self::gnutls_close_request_t::Type as gnutls_close_request;
pub use self::gnutls_pk_algorithm_t::Type as gnutls_pk_algorithm;
pub use self::gnutls_sign_algorithm_t::Type as gnutls_sign_algorithm;
pub use self::gnutls_x509_crt_fmt_t::Type as gnutls_x509_crt_fmt;
pub type gnutls_session = gnutls_session_t;
pub use self::gnutls_alert_description_t::Type as gnutls_alert_description;
pub use self::gnutls_alert_level_t::Type as gnutls_alert_level;
pub use self::gnutls_x509_subject_alt_name_t::Type as gnutls_x509_subject_alt_name;
pub type gnutls_openpgp_privkey = gnutls_openpgp_privkey_t;
pub type gnutls_openpgp_keyring = gnutls_openpgp_keyring_t;
pub type gnutls_x509_crt = gnutls_x509_crt_t;
pub type gnutls_x509_privkey = gnutls_x509_privkey_t;
pub type gnutls_x509_crl = gnutls_x509_crl_t;
pub type gnutls_x509_crq = gnutls_x509_crq_t;
pub type gnutls_certificate_credentials = gnutls_certificate_credentials_t;
pub type gnutls_anon_server_credentials = gnutls_anon_server_credentials_t;
pub type gnutls_anon_client_credentials = gnutls_anon_client_credentials_t;
pub type gnutls_srp_client_credentials = gnutls_srp_client_credentials_t;
pub type gnutls_srp_server_credentials = gnutls_srp_server_credentials_t;
pub type gnutls_dh_params = gnutls_dh_params_t;
pub type gnutls_rsa_params = gnutls_rsa_params_t;
pub use self::gnutls_certificate_type_t::Type as gnutls_certificate_type;
pub use self::gnutls_credentials_type_t::Type as gnutls_credentials_type;
pub use self::gnutls_params_type_t::Type as gnutls_params_type;
pub type gnutls_datum = gnutls_datum_t;
pub type gnutls_transport_ptr = gnutls_transport_ptr_t;
pub use self::gnutls_openpgp_crt_status_t::Type as gnutls_openpgp_key_status_t;
pub type gnutls_openpgp_key_t = gnutls_openpgp_crt_t;
extern "C" {
    pub fn gnutls_x509_privkey_sign_hash(
        key: gnutls_x509_privkey_t,
        hash: *const gnutls_datum_t,
        signature: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_openpgp_privkey_sign_hash(
        key: gnutls_openpgp_privkey_t,
        hash: *const gnutls_datum_t,
        signature: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_preferred_hash_algorithm(
        crt: gnutls_x509_crt_t,
        hash: *mut gnutls_digest_algorithm_t::Type,
        mand: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_global_set_mem_functions(
        alloc_func: gnutls_alloc_function,
        secure_alloc_func: gnutls_alloc_function,
        is_secure_func: gnutls_is_secure_function,
        realloc_func: gnutls_realloc_function,
        free_func: gnutls_free_function,
    );
}
extern "C" {
    pub fn gnutls_compression_get(session: gnutls_session_t) -> gnutls_compression_method_t::Type;
}
extern "C" {
    pub fn gnutls_compression_get_name(
        algorithm: gnutls_compression_method_t::Type,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_compression_get_id(
        name: *const ::libc::c_char,
    ) -> gnutls_compression_method_t::Type;
}
extern "C" {
    pub fn gnutls_compression_list() -> *const gnutls_compression_method_t::Type;
}
extern "C" {
    pub fn gnutls_priority_compression_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::libc::c_uint,
    ) -> ::libc::c_int;
}
pub mod gnutls_certificate_import_flags {
    pub type Type = u32;
    pub const GNUTLS_X509_CRT_LIST_IMPORT_FAIL_IF_EXCEED: Type = 1;
    pub const GNUTLS_X509_CRT_LIST_FAIL_IF_UNSORTED: Type = 2;
    pub const GNUTLS_X509_CRT_LIST_SORT: Type = 4;
}
extern "C" {
    pub fn gnutls_x509_crt_init(cert: *mut gnutls_x509_crt_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_deinit(cert: gnutls_x509_crt_t);
}
pub mod gnutls_x509_crt_flags {
    pub type Type = u32;
    pub const GNUTLS_X509_CRT_FLAG_IGNORE_SANITY: Type = 1;
}
extern "C" {
    pub fn gnutls_x509_crt_set_flags(cert: gnutls_x509_crt_t, flags: ::libc::c_uint);
}
extern "C" {
    pub fn gnutls_x509_crt_equals(
        cert1: gnutls_x509_crt_t,
        cert2: gnutls_x509_crt_t,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_x509_crt_equals2(
        cert1: gnutls_x509_crt_t,
        der: *const gnutls_datum_t,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_x509_crt_import(
        cert: gnutls_x509_crt_t,
        data: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_list_import2(
        certs: *mut *mut gnutls_x509_crt_t,
        size: *mut ::libc::c_uint,
        data: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_list_import(
        certs: *mut gnutls_x509_crt_t,
        cert_max: *mut ::libc::c_uint,
        data: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_import_url(
        crt: gnutls_x509_crt_t,
        url: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_list_import_url(
        certs: *mut *mut gnutls_x509_crt_t,
        size: *mut ::libc::c_uint,
        url: *const ::libc::c_char,
        pin_fn: gnutls_pin_callback_t,
        pin_fn_userdata: *mut ::libc::c_void,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_export(
        cert: gnutls_x509_crt_t,
        format: gnutls_x509_crt_fmt_t::Type,
        output_data: *mut ::libc::c_void,
        output_data_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_export2(
        cert: gnutls_x509_crt_t,
        format: gnutls_x509_crt_fmt_t::Type,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_private_key_usage_period(
        cert: gnutls_x509_crt_t,
        activation: *mut time_t,
        expiration: *mut time_t,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_issuer_dn(
        cert: gnutls_x509_crt_t,
        buf: *mut ::libc::c_char,
        buf_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_issuer_dn2(
        cert: gnutls_x509_crt_t,
        dn: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_issuer_dn3(
        cert: gnutls_x509_crt_t,
        dn: *mut gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_issuer_dn_oid(
        cert: gnutls_x509_crt_t,
        indx: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        oid_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_issuer_dn_by_oid(
        cert: gnutls_x509_crt_t,
        oid: *const ::libc::c_char,
        indx: ::libc::c_uint,
        raw_flag: ::libc::c_uint,
        buf: *mut ::libc::c_void,
        buf_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_dn(
        cert: gnutls_x509_crt_t,
        buf: *mut ::libc::c_char,
        buf_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_dn2(
        cert: gnutls_x509_crt_t,
        dn: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_dn3(
        cert: gnutls_x509_crt_t,
        dn: *mut gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_dn_oid(
        cert: gnutls_x509_crt_t,
        indx: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        oid_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_dn_by_oid(
        cert: gnutls_x509_crt_t,
        oid: *const ::libc::c_char,
        indx: ::libc::c_uint,
        raw_flag: ::libc::c_uint,
        buf: *mut ::libc::c_void,
        buf_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_check_hostname(
        cert: gnutls_x509_crt_t,
        hostname: *const ::libc::c_char,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_x509_crt_check_hostname2(
        cert: gnutls_x509_crt_t,
        hostname: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_x509_crt_check_email(
        cert: gnutls_x509_crt_t,
        email: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_x509_crt_check_ip(
        cert: gnutls_x509_crt_t,
        ip: *const ::libc::c_uchar,
        ip_size: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_x509_crt_get_signature_algorithm(cert: gnutls_x509_crt_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_signature(
        cert: gnutls_x509_crt_t,
        sig: *mut ::libc::c_char,
        sizeof_sig: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_version(cert: gnutls_x509_crt_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_pk_oid(
        cert: gnutls_x509_crt_t,
        oid: *mut ::libc::c_char,
        oid_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_signature_oid(
        cert: gnutls_x509_crt_t,
        oid: *mut ::libc::c_char,
        oid_size: *mut usize,
    ) -> ::libc::c_int;
}
pub mod gnutls_keyid_flags_t {
    pub type Type = u32;
    pub const GNUTLS_KEYID_USE_SHA1: Type = 0;
    pub const GNUTLS_KEYID_USE_SHA256: Type = 1;
    pub const GNUTLS_KEYID_USE_SHA512: Type = 2;
    pub const GNUTLS_KEYID_USE_BEST_KNOWN: Type = 1073741824;
}
extern "C" {
    pub fn gnutls_x509_crt_get_key_id(
        crt: gnutls_x509_crt_t,
        flags: ::libc::c_uint,
        output_data: *mut ::libc::c_uchar,
        output_data_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_private_key_usage_period(
        crt: gnutls_x509_crt_t,
        activation: time_t,
        expiration: time_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_authority_key_id(
        cert: gnutls_x509_crt_t,
        id: *const ::libc::c_void,
        id_size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_authority_key_id(
        cert: gnutls_x509_crt_t,
        id: *mut ::libc::c_void,
        id_size: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_authority_key_gn_serial(
        cert: gnutls_x509_crt_t,
        seq: ::libc::c_uint,
        alt: *mut ::libc::c_void,
        alt_size: *mut usize,
        alt_type: *mut ::libc::c_uint,
        serial: *mut ::libc::c_void,
        serial_size: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_subject_key_id(
        cert: gnutls_x509_crt_t,
        ret: *mut ::libc::c_void,
        ret_size: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_subject_unique_id(
        crt: gnutls_x509_crt_t,
        buf: *mut ::libc::c_char,
        buf_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_issuer_unique_id(
        crt: gnutls_x509_crt_t,
        buf: *mut ::libc::c_char,
        buf_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_pin_function(
        crt: gnutls_x509_crt_t,
        fn_: gnutls_pin_callback_t,
        userdata: *mut ::libc::c_void,
    );
}
pub mod gnutls_info_access_what_t {
    pub type Type = u32;
    pub const GNUTLS_IA_ACCESSMETHOD_OID: Type = 1;
    pub const GNUTLS_IA_ACCESSLOCATION_GENERALNAME_TYPE: Type = 2;
    pub const GNUTLS_IA_URI: Type = 106;
    pub const GNUTLS_IA_UNKNOWN: Type = 10000;
    pub const GNUTLS_IA_OCSP_URI: Type = 10006;
    pub const GNUTLS_IA_CAISSUERS_URI: Type = 10106;
}
extern "C" {
    pub fn gnutls_x509_crt_get_authority_info_access(
        crt: gnutls_x509_crt_t,
        seq: ::libc::c_uint,
        what: ::libc::c_int,
        data: *mut gnutls_datum_t,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_name_constraints_st {
    _unused: [u8; 0],
}
pub type gnutls_x509_name_constraints_t = *mut gnutls_name_constraints_st;
extern "C" {
    pub fn gnutls_x509_name_constraints_check(
        nc: gnutls_x509_name_constraints_t,
        type_: gnutls_x509_subject_alt_name_t::Type,
        name: *const gnutls_datum_t,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_x509_name_constraints_check_crt(
        nc: gnutls_x509_name_constraints_t,
        type_: gnutls_x509_subject_alt_name_t::Type,
        crt: gnutls_x509_crt_t,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_x509_name_constraints_init(
        nc: *mut gnutls_x509_name_constraints_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_name_constraints_deinit(nc: gnutls_x509_name_constraints_t);
}
extern "C" {
    pub fn gnutls_x509_crt_get_name_constraints(
        crt: gnutls_x509_crt_t,
        nc: gnutls_x509_name_constraints_t,
        flags: ::libc::c_uint,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_name_constraints_add_permitted(
        nc: gnutls_x509_name_constraints_t,
        type_: gnutls_x509_subject_alt_name_t::Type,
        name: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_name_constraints_add_excluded(
        nc: gnutls_x509_name_constraints_t,
        type_: gnutls_x509_subject_alt_name_t::Type,
        name: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_name_constraints(
        crt: gnutls_x509_crt_t,
        nc: gnutls_x509_name_constraints_t,
        critical: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_name_constraints_get_permitted(
        nc: gnutls_x509_name_constraints_t,
        idx: ::libc::c_uint,
        type_: *mut ::libc::c_uint,
        name: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_name_constraints_get_excluded(
        nc: gnutls_x509_name_constraints_t,
        idx: ::libc::c_uint,
        type_: *mut ::libc::c_uint,
        name: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_cidr_to_rfc5280(
        cidr: *const ::libc::c_char,
        cidr_rfc5280: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
pub mod gnutls_x509_crl_reason_flags_t {
    pub type Type = u32;
    pub const GNUTLS_CRL_REASON_UNSPECIFIED: Type = 0;
    pub const GNUTLS_CRL_REASON_PRIVILEGE_WITHDRAWN: Type = 1;
    pub const GNUTLS_CRL_REASON_CERTIFICATE_HOLD: Type = 2;
    pub const GNUTLS_CRL_REASON_CESSATION_OF_OPERATION: Type = 4;
    pub const GNUTLS_CRL_REASON_SUPERSEDED: Type = 8;
    pub const GNUTLS_CRL_REASON_AFFILIATION_CHANGED: Type = 16;
    pub const GNUTLS_CRL_REASON_CA_COMPROMISE: Type = 32;
    pub const GNUTLS_CRL_REASON_KEY_COMPROMISE: Type = 64;
    pub const GNUTLS_CRL_REASON_UNUSED: Type = 128;
    pub const GNUTLS_CRL_REASON_AA_COMPROMISE: Type = 32768;
}
extern "C" {
    pub fn gnutls_x509_crt_get_crl_dist_points(
        cert: gnutls_x509_crt_t,
        seq: ::libc::c_uint,
        ret: *mut ::libc::c_void,
        ret_size: *mut usize,
        reason_flags: *mut ::libc::c_uint,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_crl_dist_points2(
        crt: gnutls_x509_crt_t,
        type_: gnutls_x509_subject_alt_name_t::Type,
        data: *const ::libc::c_void,
        data_size: ::libc::c_uint,
        reason_flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_crl_dist_points(
        crt: gnutls_x509_crt_t,
        type_: gnutls_x509_subject_alt_name_t::Type,
        data_string: *const ::libc::c_void,
        reason_flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_cpy_crl_dist_points(
        dst: gnutls_x509_crt_t,
        src: gnutls_x509_crt_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_sign(
        crl: gnutls_x509_crl_t,
        issuer: gnutls_x509_crt_t,
        issuer_key: gnutls_x509_privkey_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_sign2(
        crl: gnutls_x509_crl_t,
        issuer: gnutls_x509_crt_t,
        issuer_key: gnutls_x509_privkey_t,
        dig: gnutls_digest_algorithm_t::Type,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_activation_time(cert: gnutls_x509_crt_t) -> time_t;
}
extern "C" {
    pub fn gnutls_x509_crt_get_expiration_time(cert: gnutls_x509_crt_t) -> time_t;
}
extern "C" {
    pub fn gnutls_x509_crt_get_serial(
        cert: gnutls_x509_crt_t,
        result: *mut ::libc::c_void,
        result_size: *mut usize,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_spki_st {
    _unused: [u8; 0],
}
pub type gnutls_x509_spki_t = *mut gnutls_x509_spki_st;
extern "C" {
    pub fn gnutls_x509_spki_init(spki: *mut gnutls_x509_spki_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_spki_deinit(spki: gnutls_x509_spki_t);
}
extern "C" {
    pub fn gnutls_x509_spki_get_rsa_pss_params(
        spki: gnutls_x509_spki_t,
        dig: *mut gnutls_digest_algorithm_t::Type,
        salt_size: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_spki_set_rsa_pss_params(
        spki: gnutls_x509_spki_t,
        dig: gnutls_digest_algorithm_t::Type,
        salt_size: ::libc::c_uint,
    );
}
extern "C" {
    pub fn gnutls_x509_crt_get_pk_algorithm(
        cert: gnutls_x509_crt_t,
        bits: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_spki(
        crt: gnutls_x509_crt_t,
        spki: gnutls_x509_spki_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_spki(
        cert: gnutls_x509_crt_t,
        spki: gnutls_x509_spki_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_pk_rsa_raw(
        crt: gnutls_x509_crt_t,
        m: *mut gnutls_datum_t,
        e: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_pk_dsa_raw(
        crt: gnutls_x509_crt_t,
        p: *mut gnutls_datum_t,
        q: *mut gnutls_datum_t,
        g: *mut gnutls_datum_t,
        y: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_pk_ecc_raw(
        crt: gnutls_x509_crt_t,
        curve: *mut gnutls_ecc_curve_t::Type,
        x: *mut gnutls_datum_t,
        y: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_pk_gost_raw(
        crt: gnutls_x509_crt_t,
        curve: *mut gnutls_ecc_curve_t::Type,
        digest: *mut gnutls_digest_algorithm_t::Type,
        paramset: *mut gnutls_gost_paramset_t::Type,
        x: *mut gnutls_datum_t,
        y: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_subject_alt_name(
        cert: gnutls_x509_crt_t,
        seq: ::libc::c_uint,
        san: *mut ::libc::c_void,
        san_size: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_subject_alt_name2(
        cert: gnutls_x509_crt_t,
        seq: ::libc::c_uint,
        san: *mut ::libc::c_void,
        san_size: *mut usize,
        san_type: *mut ::libc::c_uint,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_subject_alt_othername_oid(
        cert: gnutls_x509_crt_t,
        seq: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        oid_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_issuer_alt_name(
        cert: gnutls_x509_crt_t,
        seq: ::libc::c_uint,
        ian: *mut ::libc::c_void,
        ian_size: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_issuer_alt_name2(
        cert: gnutls_x509_crt_t,
        seq: ::libc::c_uint,
        ian: *mut ::libc::c_void,
        ian_size: *mut usize,
        ian_type: *mut ::libc::c_uint,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_issuer_alt_othername_oid(
        cert: gnutls_x509_crt_t,
        seq: ::libc::c_uint,
        ret: *mut ::libc::c_void,
        ret_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_ca_status(
        cert: gnutls_x509_crt_t,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_basic_constraints(
        cert: gnutls_x509_crt_t,
        critical: *mut ::libc::c_uint,
        ca: *mut ::libc::c_uint,
        pathlen: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_key_usage(
        cert: gnutls_x509_crt_t,
        key_usage: *mut ::libc::c_uint,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_key_usage(
        crt: gnutls_x509_crt_t,
        usage: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_authority_info_access(
        crt: gnutls_x509_crt_t,
        what: ::libc::c_int,
        data: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_inhibit_anypolicy(
        cert: gnutls_x509_crt_t,
        skipcerts: *mut ::libc::c_uint,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_inhibit_anypolicy(
        crt: gnutls_x509_crt_t,
        skipcerts: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_proxy(
        cert: gnutls_x509_crt_t,
        critical: *mut ::libc::c_uint,
        pathlen: *mut ::libc::c_int,
        policyLanguage: *mut *mut ::libc::c_char,
        policy: *mut *mut ::libc::c_char,
        sizeof_policy: *mut usize,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_tlsfeatures_st {
    _unused: [u8; 0],
}
pub type gnutls_x509_tlsfeatures_t = *mut gnutls_x509_tlsfeatures_st;
extern "C" {
    pub fn gnutls_x509_tlsfeatures_init(features: *mut gnutls_x509_tlsfeatures_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_tlsfeatures_deinit(arg1: gnutls_x509_tlsfeatures_t);
}
extern "C" {
    pub fn gnutls_x509_tlsfeatures_get(
        f: gnutls_x509_tlsfeatures_t,
        idx: ::libc::c_uint,
        feature: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_tlsfeatures(
        crt: gnutls_x509_crt_t,
        features: gnutls_x509_tlsfeatures_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_tlsfeatures(
        cert: gnutls_x509_crt_t,
        features: gnutls_x509_tlsfeatures_t,
        flags: ::libc::c_uint,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_tlsfeatures_check_crt(
        feat: gnutls_x509_tlsfeatures_t,
        crt: gnutls_x509_crt_t,
    ) -> ::libc::c_uint;
}
pub mod gnutls_x509_qualifier_t {
    pub type Type = u32;
    pub const GNUTLS_X509_QUALIFIER_UNKNOWN: Type = 0;
    pub const GNUTLS_X509_QUALIFIER_URI: Type = 1;
    pub const GNUTLS_X509_QUALIFIER_NOTICE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_policy_st {
    pub oid: *mut ::libc::c_char,
    pub qualifiers: ::libc::c_uint,
    pub qualifier: [gnutls_x509_policy_st__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_policy_st__bindgen_ty_1 {
    pub type_: gnutls_x509_qualifier_t::Type,
    pub data: *mut ::libc::c_char,
    pub size: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_gnutls_x509_policy_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_x509_policy_st__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(gnutls_x509_policy_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_x509_policy_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(gnutls_x509_policy_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_x509_policy_st__bindgen_ty_1>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_x509_policy_st__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_x509_policy_st__bindgen_ty_1>())).data as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_x509_policy_st__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_x509_policy_st__bindgen_ty_1>())).size as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_x509_policy_st__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
impl Default for gnutls_x509_policy_st__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_gnutls_x509_policy_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_x509_policy_st>(),
        208usize,
        concat!("Size of: ", stringify!(gnutls_x509_policy_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_x509_policy_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_x509_policy_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_x509_policy_st>())).oid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_x509_policy_st),
            "::",
            stringify!(oid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_x509_policy_st>())).qualifiers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_x509_policy_st),
            "::",
            stringify!(qualifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_x509_policy_st>())).qualifier as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_x509_policy_st),
            "::",
            stringify!(qualifier)
        )
    );
}
impl Default for gnutls_x509_policy_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn gnutls_x509_policy_release(policy: *mut gnutls_x509_policy_st);
}
extern "C" {
    pub fn gnutls_x509_crt_get_policy(
        crt: gnutls_x509_crt_t,
        indx: ::libc::c_uint,
        policy: *mut gnutls_x509_policy_st,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_policy(
        crt: gnutls_x509_crt_t,
        policy: *const gnutls_x509_policy_st,
        critical: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_dn_oid_known(oid: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_dn_oid_name(
        oid: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_x509_crt_get_extension_oid(
        cert: gnutls_x509_crt_t,
        indx: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        oid_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_extension_by_oid(
        cert: gnutls_x509_crt_t,
        oid: *const ::libc::c_char,
        indx: ::libc::c_uint,
        buf: *mut ::libc::c_void,
        buf_size: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_signature_algorithm(crq: gnutls_x509_crq_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_extension_by_oid2(
        crq: gnutls_x509_crq_t,
        oid: *const ::libc::c_char,
        indx: ::libc::c_uint,
        output: *mut gnutls_datum_t,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_extension_info(
        cert: gnutls_x509_crt_t,
        indx: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        oid_size: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_extension_data(
        cert: gnutls_x509_crt_t,
        indx: ::libc::c_uint,
        data: *mut ::libc::c_void,
        sizeof_data: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_extension_data2(
        cert: gnutls_x509_crt_t,
        indx: ::libc::c_uint,
        data: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_extension_by_oid(
        crt: gnutls_x509_crt_t,
        oid: *const ::libc::c_char,
        buf: *const ::libc::c_void,
        sizeof_buf: usize,
        critical: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_dn(
        crt: gnutls_x509_crt_t,
        dn: *const ::libc::c_char,
        err: *mut *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_dn_by_oid(
        crt: gnutls_x509_crt_t,
        oid: *const ::libc::c_char,
        raw_flag: ::libc::c_uint,
        name: *const ::libc::c_void,
        sizeof_name: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_issuer_dn_by_oid(
        crt: gnutls_x509_crt_t,
        oid: *const ::libc::c_char,
        raw_flag: ::libc::c_uint,
        name: *const ::libc::c_void,
        sizeof_name: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_issuer_dn(
        crt: gnutls_x509_crt_t,
        dn: *const ::libc::c_char,
        err: *mut *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_version(
        crt: gnutls_x509_crt_t,
        version: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_key(
        crt: gnutls_x509_crt_t,
        key: gnutls_x509_privkey_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_ca_status(
        crt: gnutls_x509_crt_t,
        ca: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_basic_constraints(
        crt: gnutls_x509_crt_t,
        ca: ::libc::c_uint,
        pathLenConstraint: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_subject_unique_id(
        cert: gnutls_x509_crt_t,
        id: *const ::libc::c_void,
        id_size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_issuer_unique_id(
        cert: gnutls_x509_crt_t,
        id: *const ::libc::c_void,
        id_size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_subject_alternative_name(
        crt: gnutls_x509_crt_t,
        type_: gnutls_x509_subject_alt_name_t::Type,
        data_string: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_subject_alt_name(
        crt: gnutls_x509_crt_t,
        type_: gnutls_x509_subject_alt_name_t::Type,
        data: *const ::libc::c_void,
        data_size: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_subject_alt_othername(
        crt: gnutls_x509_crt_t,
        oid: *const ::libc::c_char,
        data: *const ::libc::c_void,
        data_size: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_issuer_alt_name(
        crt: gnutls_x509_crt_t,
        type_: gnutls_x509_subject_alt_name_t::Type,
        data: *const ::libc::c_void,
        data_size: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_issuer_alt_othername(
        crt: gnutls_x509_crt_t,
        oid: *const ::libc::c_char,
        data: *const ::libc::c_void,
        data_size: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_sign(
        crt: gnutls_x509_crt_t,
        issuer: gnutls_x509_crt_t,
        issuer_key: gnutls_x509_privkey_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_sign2(
        crt: gnutls_x509_crt_t,
        issuer: gnutls_x509_crt_t,
        issuer_key: gnutls_x509_privkey_t,
        dig: gnutls_digest_algorithm_t::Type,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_activation_time(
        cert: gnutls_x509_crt_t,
        act_time: time_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_expiration_time(
        cert: gnutls_x509_crt_t,
        exp_time: time_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_serial(
        cert: gnutls_x509_crt_t,
        serial: *const ::libc::c_void,
        serial_size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_subject_key_id(
        cert: gnutls_x509_crt_t,
        id: *const ::libc::c_void,
        id_size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_proxy_dn(
        crt: gnutls_x509_crt_t,
        eecrt: gnutls_x509_crt_t,
        raw_flag: ::libc::c_uint,
        name: *const ::libc::c_void,
        sizeof_name: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_proxy(
        crt: gnutls_x509_crt_t,
        pathLenConstraint: ::libc::c_int,
        policyLanguage: *const ::libc::c_char,
        policy: *const ::libc::c_char,
        sizeof_policy: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_print(
        cert: gnutls_x509_crt_t,
        format: gnutls_certificate_print_formats_t,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_print(
        crl: gnutls_x509_crl_t,
        format: gnutls_certificate_print_formats_t,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_raw_issuer_dn(
        cert: gnutls_x509_crt_t,
        start: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_raw_dn(
        cert: gnutls_x509_crt_t,
        start: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_rdn_get(
        idn: *const gnutls_datum_t,
        buf: *mut ::libc::c_char,
        sizeof_buf: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_rdn_get2(
        idn: *const gnutls_datum_t,
        str: *mut gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_rdn_get_oid(
        idn: *const gnutls_datum_t,
        indx: ::libc::c_uint,
        buf: *mut ::libc::c_void,
        sizeof_buf: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_rdn_get_by_oid(
        idn: *const gnutls_datum_t,
        oid: *const ::libc::c_char,
        indx: ::libc::c_uint,
        raw_flag: ::libc::c_uint,
        buf: *mut ::libc::c_void,
        sizeof_buf: *mut usize,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_dn_st {
    _unused: [u8; 0],
}
pub type gnutls_x509_dn_t = *mut gnutls_x509_dn_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_ava_st {
    pub oid: gnutls_datum_t,
    pub value: gnutls_datum_t,
    pub value_tag: ::libc::c_ulong,
}
#[test]
fn bindgen_test_layout_gnutls_x509_ava_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_x509_ava_st>(),
        40usize,
        concat!("Size of: ", stringify!(gnutls_x509_ava_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_x509_ava_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_x509_ava_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_x509_ava_st>())).oid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_x509_ava_st),
            "::",
            stringify!(oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_x509_ava_st>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_x509_ava_st),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_x509_ava_st>())).value_tag as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_x509_ava_st),
            "::",
            stringify!(value_tag)
        )
    );
}
impl Default for gnutls_x509_ava_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn gnutls_x509_crt_get_subject(
        cert: gnutls_x509_crt_t,
        dn: *mut gnutls_x509_dn_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_issuer(
        cert: gnutls_x509_crt_t,
        dn: *mut gnutls_x509_dn_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_dn_get_rdn_ava(
        dn: gnutls_x509_dn_t,
        irdn: ::libc::c_int,
        iava: ::libc::c_int,
        ava: *mut gnutls_x509_ava_st,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_dn_get_str(dn: gnutls_x509_dn_t, str: *mut gnutls_datum_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_dn_get_str2(
        dn: gnutls_x509_dn_t,
        str: *mut gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_dn_set_str(
        dn: gnutls_x509_dn_t,
        str: *const ::libc::c_char,
        err: *mut *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_dn_init(dn: *mut gnutls_x509_dn_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_dn_import(
        dn: gnutls_x509_dn_t,
        data: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_dn_export(
        dn: gnutls_x509_dn_t,
        format: gnutls_x509_crt_fmt_t::Type,
        output_data: *mut ::libc::c_void,
        output_data_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_dn_export2(
        dn: gnutls_x509_dn_t,
        format: gnutls_x509_crt_fmt_t::Type,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_dn_deinit(dn: gnutls_x509_dn_t);
}
extern "C" {
    pub fn gnutls_x509_crl_init(crl: *mut gnutls_x509_crl_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_deinit(crl: gnutls_x509_crl_t);
}
extern "C" {
    pub fn gnutls_x509_crl_import(
        crl: gnutls_x509_crl_t,
        data: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_export(
        crl: gnutls_x509_crl_t,
        format: gnutls_x509_crt_fmt_t::Type,
        output_data: *mut ::libc::c_void,
        output_data_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_export2(
        crl: gnutls_x509_crl_t,
        format: gnutls_x509_crt_fmt_t::Type,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_raw_issuer_dn(
        crl: gnutls_x509_crl_t,
        dn: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_issuer_dn(
        crl: gnutls_x509_crl_t,
        buf: *mut ::libc::c_char,
        sizeof_buf: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_issuer_dn2(
        crl: gnutls_x509_crl_t,
        dn: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_issuer_dn3(
        crl: gnutls_x509_crl_t,
        dn: *mut gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_issuer_dn_by_oid(
        crl: gnutls_x509_crl_t,
        oid: *const ::libc::c_char,
        indx: ::libc::c_uint,
        raw_flag: ::libc::c_uint,
        buf: *mut ::libc::c_void,
        sizeof_buf: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_dn_oid(
        crl: gnutls_x509_crl_t,
        indx: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        sizeof_oid: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_signature_algorithm(crl: gnutls_x509_crl_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_signature(
        crl: gnutls_x509_crl_t,
        sig: *mut ::libc::c_char,
        sizeof_sig: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_version(crl: gnutls_x509_crl_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_signature_oid(
        crl: gnutls_x509_crl_t,
        oid: *mut ::libc::c_char,
        oid_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_this_update(crl: gnutls_x509_crl_t) -> time_t;
}
extern "C" {
    pub fn gnutls_x509_crl_get_next_update(crl: gnutls_x509_crl_t) -> time_t;
}
extern "C" {
    pub fn gnutls_x509_crl_get_crt_count(crl: gnutls_x509_crl_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_crt_serial(
        crl: gnutls_x509_crl_t,
        indx: ::libc::c_uint,
        serial: *mut ::libc::c_uchar,
        serial_size: *mut usize,
        t: *mut time_t,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_crl_iter {
    _unused: [u8; 0],
}
pub type gnutls_x509_crl_iter_t = *mut gnutls_x509_crl_iter;
extern "C" {
    pub fn gnutls_x509_crl_iter_crt_serial(
        crl: gnutls_x509_crl_t,
        arg1: *mut gnutls_x509_crl_iter_t,
        serial: *mut ::libc::c_uchar,
        serial_size: *mut usize,
        t: *mut time_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_iter_deinit(arg1: gnutls_x509_crl_iter_t);
}
extern "C" {
    pub fn gnutls_x509_crl_check_issuer(
        crl: gnutls_x509_crl_t,
        issuer: gnutls_x509_crt_t,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_x509_crl_list_import2(
        crls: *mut *mut gnutls_x509_crl_t,
        size: *mut ::libc::c_uint,
        data: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_list_import(
        crls: *mut gnutls_x509_crl_t,
        crl_max: *mut ::libc::c_uint,
        data: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_set_version(
        crl: gnutls_x509_crl_t,
        version: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_set_this_update(
        crl: gnutls_x509_crl_t,
        act_time: time_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_set_next_update(
        crl: gnutls_x509_crl_t,
        exp_time: time_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_set_crt_serial(
        crl: gnutls_x509_crl_t,
        serial: *const ::libc::c_void,
        serial_size: usize,
        revocation_time: time_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_set_crt(
        crl: gnutls_x509_crl_t,
        crt: gnutls_x509_crt_t,
        revocation_time: time_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_authority_key_id(
        crl: gnutls_x509_crl_t,
        id: *mut ::libc::c_void,
        id_size: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_authority_key_gn_serial(
        crl: gnutls_x509_crl_t,
        seq: ::libc::c_uint,
        alt: *mut ::libc::c_void,
        alt_size: *mut usize,
        alt_type: *mut ::libc::c_uint,
        serial: *mut ::libc::c_void,
        serial_size: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_number(
        crl: gnutls_x509_crl_t,
        ret: *mut ::libc::c_void,
        ret_size: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_extension_oid(
        crl: gnutls_x509_crl_t,
        indx: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        sizeof_oid: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_extension_info(
        crl: gnutls_x509_crl_t,
        indx: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        sizeof_oid: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_extension_data(
        crl: gnutls_x509_crl_t,
        indx: ::libc::c_uint,
        data: *mut ::libc::c_void,
        sizeof_data: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_get_extension_data2(
        crl: gnutls_x509_crl_t,
        indx: ::libc::c_uint,
        data: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_set_authority_key_id(
        crl: gnutls_x509_crl_t,
        id: *const ::libc::c_void,
        id_size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_set_number(
        crl: gnutls_x509_crl_t,
        nr: *const ::libc::c_void,
        nr_size: usize,
    ) -> ::libc::c_int;
}
pub mod gnutls_certificate_verify_flags {
    pub type Type = u32;
    pub const GNUTLS_VERIFY_DISABLE_CA_SIGN: Type = 1;
    pub const GNUTLS_VERIFY_DO_NOT_ALLOW_IP_MATCHES: Type = 2;
    pub const GNUTLS_VERIFY_DO_NOT_ALLOW_SAME: Type = 4;
    pub const GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT: Type = 8;
    pub const GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD2: Type = 16;
    pub const GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5: Type = 32;
    pub const GNUTLS_VERIFY_DISABLE_TIME_CHECKS: Type = 64;
    pub const GNUTLS_VERIFY_DISABLE_TRUSTED_TIME_CHECKS: Type = 128;
    pub const GNUTLS_VERIFY_DO_NOT_ALLOW_X509_V1_CA_CRT: Type = 256;
    pub const GNUTLS_VERIFY_DISABLE_CRL_CHECKS: Type = 512;
    pub const GNUTLS_VERIFY_ALLOW_UNSORTED_CHAIN: Type = 1024;
    pub const GNUTLS_VERIFY_DO_NOT_ALLOW_UNSORTED_CHAIN: Type = 2048;
    pub const GNUTLS_VERIFY_DO_NOT_ALLOW_WILDCARDS: Type = 4096;
    pub const GNUTLS_VERIFY_USE_TLS1_RSA: Type = 8192;
    pub const GNUTLS_VERIFY_IGNORE_UNKNOWN_CRIT_EXTENSIONS: Type = 16384;
    pub const GNUTLS_VERIFY_ALLOW_SIGN_WITH_SHA1: Type = 32768;
}
pub mod gnutls_certificate_verification_profiles_t {
    pub type Type = u32;
    pub const GNUTLS_PROFILE_UNKNOWN: Type = 0;
    pub const GNUTLS_PROFILE_VERY_WEAK: Type = 1;
    pub const GNUTLS_PROFILE_LOW: Type = 2;
    pub const GNUTLS_PROFILE_LEGACY: Type = 4;
    pub const GNUTLS_PROFILE_MEDIUM: Type = 5;
    pub const GNUTLS_PROFILE_HIGH: Type = 6;
    pub const GNUTLS_PROFILE_ULTRA: Type = 7;
    pub const GNUTLS_PROFILE_FUTURE: Type = 8;
    pub const GNUTLS_PROFILE_SUITEB128: Type = 32;
    pub const GNUTLS_PROFILE_SUITEB192: Type = 33;
}
extern "C" {
    pub fn gnutls_certificate_verification_profile_get_name(
        id: gnutls_certificate_verification_profiles_t::Type,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_certificate_verification_profile_get_id(
        name: *const ::libc::c_char,
    ) -> gnutls_certificate_verification_profiles_t::Type;
}
extern "C" {
    pub fn gnutls_x509_crt_check_issuer(
        cert: gnutls_x509_crt_t,
        issuer: gnutls_x509_crt_t,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_x509_crt_list_verify(
        cert_list: *const gnutls_x509_crt_t,
        cert_list_length: ::libc::c_uint,
        CA_list: *const gnutls_x509_crt_t,
        CA_list_length: ::libc::c_uint,
        CRL_list: *const gnutls_x509_crl_t,
        CRL_list_length: ::libc::c_uint,
        flags: ::libc::c_uint,
        verify: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_verify(
        cert: gnutls_x509_crt_t,
        CA_list: *const gnutls_x509_crt_t,
        CA_list_length: ::libc::c_uint,
        flags: ::libc::c_uint,
        verify: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crl_verify(
        crl: gnutls_x509_crl_t,
        CA_list: *const gnutls_x509_crt_t,
        CA_list_length: ::libc::c_uint,
        flags: ::libc::c_uint,
        verify: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_verify_data2(
        crt: gnutls_x509_crt_t,
        algo: gnutls_sign_algorithm_t::Type,
        flags: ::libc::c_uint,
        data: *const gnutls_datum_t,
        signature: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_check_revocation(
        cert: gnutls_x509_crt_t,
        crl_list: *const gnutls_x509_crl_t,
        crl_list_length: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_fingerprint(
        cert: gnutls_x509_crt_t,
        algo: gnutls_digest_algorithm_t::Type,
        buf: *mut ::libc::c_void,
        buf_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_key_purpose_oid(
        cert: gnutls_x509_crt_t,
        indx: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        oid_size: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_key_purpose_oid(
        cert: gnutls_x509_crt_t,
        oid: *const ::libc::c_void,
        critical: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_check_key_purpose(
        cert: gnutls_x509_crt_t,
        purpose: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_uint;
}
pub mod gnutls_pkcs_encrypt_flags_t {
    pub type Type = u32;
    pub const GNUTLS_PKCS_PLAIN: Type = 1;
    pub const GNUTLS_PKCS_PKCS12_3DES: Type = 2;
    pub const GNUTLS_PKCS_PKCS12_ARCFOUR: Type = 4;
    pub const GNUTLS_PKCS_PKCS12_RC2_40: Type = 8;
    pub const GNUTLS_PKCS_PBES2_3DES: Type = 16;
    pub const GNUTLS_PKCS_PBES2_AES_128: Type = 32;
    pub const GNUTLS_PKCS_PBES2_AES_192: Type = 64;
    pub const GNUTLS_PKCS_PBES2_AES_256: Type = 128;
    pub const GNUTLS_PKCS_NULL_PASSWORD: Type = 256;
    pub const GNUTLS_PKCS_PBES2_DES: Type = 512;
    pub const GNUTLS_PKCS_PBES1_DES_MD5: Type = 1024;
    pub const GNUTLS_PKCS_PBES2_GOST_TC26Z: Type = 2048;
    pub const GNUTLS_PKCS_PBES2_GOST_CPA: Type = 4096;
    pub const GNUTLS_PKCS_PBES2_GOST_CPB: Type = 8192;
    pub const GNUTLS_PKCS_PBES2_GOST_CPC: Type = 16384;
    pub const GNUTLS_PKCS_PBES2_GOST_CPD: Type = 32768;
}
extern "C" {
    pub fn gnutls_pkcs_schema_get_name(schema: ::libc::c_uint) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_pkcs_schema_get_oid(schema: ::libc::c_uint) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_x509_privkey_init(key: *mut gnutls_x509_privkey_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_deinit(key: gnutls_x509_privkey_t);
}
extern "C" {
    pub fn gnutls_x509_privkey_sec_param(key: gnutls_x509_privkey_t) -> gnutls_sec_param_t::Type;
}
extern "C" {
    pub fn gnutls_x509_privkey_set_pin_function(
        key: gnutls_x509_privkey_t,
        fn_: gnutls_pin_callback_t,
        userdata: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn gnutls_x509_privkey_cpy(
        dst: gnutls_x509_privkey_t,
        src: gnutls_x509_privkey_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_import(
        key: gnutls_x509_privkey_t,
        data: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_import_pkcs8(
        key: gnutls_x509_privkey_t,
        data: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
        password: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_import_openssl(
        key: gnutls_x509_privkey_t,
        data: *const gnutls_datum_t,
        password: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs8_info(
        data: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
        schema: *mut ::libc::c_uint,
        cipher: *mut ::libc::c_uint,
        salt: *mut ::libc::c_void,
        salt_size: *mut ::libc::c_uint,
        iter_count: *mut ::libc::c_uint,
        oid: *mut *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_import2(
        key: gnutls_x509_privkey_t,
        data: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
        password: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_import_rsa_raw(
        key: gnutls_x509_privkey_t,
        m: *const gnutls_datum_t,
        e: *const gnutls_datum_t,
        d: *const gnutls_datum_t,
        p: *const gnutls_datum_t,
        q: *const gnutls_datum_t,
        u: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_import_rsa_raw2(
        key: gnutls_x509_privkey_t,
        m: *const gnutls_datum_t,
        e: *const gnutls_datum_t,
        d: *const gnutls_datum_t,
        p: *const gnutls_datum_t,
        q: *const gnutls_datum_t,
        u: *const gnutls_datum_t,
        e1: *const gnutls_datum_t,
        e2: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_import_ecc_raw(
        key: gnutls_x509_privkey_t,
        curve: gnutls_ecc_curve_t::Type,
        x: *const gnutls_datum_t,
        y: *const gnutls_datum_t,
        k: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_import_gost_raw(
        key: gnutls_x509_privkey_t,
        curve: gnutls_ecc_curve_t::Type,
        digest: gnutls_digest_algorithm_t::Type,
        paramset: gnutls_gost_paramset_t::Type,
        x: *const gnutls_datum_t,
        y: *const gnutls_datum_t,
        k: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_fix(key: gnutls_x509_privkey_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_export_dsa_raw(
        key: gnutls_x509_privkey_t,
        p: *mut gnutls_datum_t,
        q: *mut gnutls_datum_t,
        g: *mut gnutls_datum_t,
        y: *mut gnutls_datum_t,
        x: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_import_dsa_raw(
        key: gnutls_x509_privkey_t,
        p: *const gnutls_datum_t,
        q: *const gnutls_datum_t,
        g: *const gnutls_datum_t,
        y: *const gnutls_datum_t,
        x: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_get_pk_algorithm(key: gnutls_x509_privkey_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_get_pk_algorithm2(
        key: gnutls_x509_privkey_t,
        bits: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_get_spki(
        key: gnutls_x509_privkey_t,
        spki: gnutls_x509_spki_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_set_spki(
        key: gnutls_x509_privkey_t,
        spki: gnutls_x509_spki_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_get_key_id(
        key: gnutls_x509_privkey_t,
        flags: ::libc::c_uint,
        output_data: *mut ::libc::c_uchar,
        output_data_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_generate(
        key: gnutls_x509_privkey_t,
        algo: gnutls_pk_algorithm_t::Type,
        bits: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_set_flags(key: gnutls_x509_privkey_t, flags: ::libc::c_uint);
}
pub mod gnutls_keygen_types_t {
    pub type Type = u32;
    pub const GNUTLS_KEYGEN_SEED: Type = 1;
    pub const GNUTLS_KEYGEN_DIGEST: Type = 2;
    pub const GNUTLS_KEYGEN_SPKI: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_keygen_data_st {
    pub type_: gnutls_keygen_types_t::Type,
    pub data: *mut ::libc::c_uchar,
    pub size: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_gnutls_keygen_data_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_keygen_data_st>(),
        24usize,
        concat!("Size of: ", stringify!(gnutls_keygen_data_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_keygen_data_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_keygen_data_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_keygen_data_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_keygen_data_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_keygen_data_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_keygen_data_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_keygen_data_st>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_keygen_data_st),
            "::",
            stringify!(size)
        )
    );
}
impl Default for gnutls_keygen_data_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn gnutls_x509_privkey_generate2(
        key: gnutls_x509_privkey_t,
        algo: gnutls_pk_algorithm_t::Type,
        bits: ::libc::c_uint,
        flags: ::libc::c_uint,
        data: *const gnutls_keygen_data_st,
        data_size: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_verify_seed(
        key: gnutls_x509_privkey_t,
        arg1: gnutls_digest_algorithm_t::Type,
        seed: *const ::libc::c_void,
        seed_size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_get_seed(
        key: gnutls_x509_privkey_t,
        arg1: *mut gnutls_digest_algorithm_t::Type,
        seed: *mut ::libc::c_void,
        seed_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_verify_params(key: gnutls_x509_privkey_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_export(
        key: gnutls_x509_privkey_t,
        format: gnutls_x509_crt_fmt_t::Type,
        output_data: *mut ::libc::c_void,
        output_data_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_export2(
        key: gnutls_x509_privkey_t,
        format: gnutls_x509_crt_fmt_t::Type,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_export_pkcs8(
        key: gnutls_x509_privkey_t,
        format: gnutls_x509_crt_fmt_t::Type,
        password: *const ::libc::c_char,
        flags: ::libc::c_uint,
        output_data: *mut ::libc::c_void,
        output_data_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_export2_pkcs8(
        key: gnutls_x509_privkey_t,
        format: gnutls_x509_crt_fmt_t::Type,
        password: *const ::libc::c_char,
        flags: ::libc::c_uint,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_export_rsa_raw2(
        key: gnutls_x509_privkey_t,
        m: *mut gnutls_datum_t,
        e: *mut gnutls_datum_t,
        d: *mut gnutls_datum_t,
        p: *mut gnutls_datum_t,
        q: *mut gnutls_datum_t,
        u: *mut gnutls_datum_t,
        e1: *mut gnutls_datum_t,
        e2: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_export_rsa_raw(
        key: gnutls_x509_privkey_t,
        m: *mut gnutls_datum_t,
        e: *mut gnutls_datum_t,
        d: *mut gnutls_datum_t,
        p: *mut gnutls_datum_t,
        q: *mut gnutls_datum_t,
        u: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_export_ecc_raw(
        key: gnutls_x509_privkey_t,
        curve: *mut gnutls_ecc_curve_t::Type,
        x: *mut gnutls_datum_t,
        y: *mut gnutls_datum_t,
        k: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_export_gost_raw(
        key: gnutls_x509_privkey_t,
        curve: *mut gnutls_ecc_curve_t::Type,
        digest: *mut gnutls_digest_algorithm_t::Type,
        paramset: *mut gnutls_gost_paramset_t::Type,
        x: *mut gnutls_datum_t,
        y: *mut gnutls_datum_t,
        k: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_privkey_sign_data(
        key: gnutls_x509_privkey_t,
        digest: gnutls_digest_algorithm_t::Type,
        flags: ::libc::c_uint,
        data: *const gnutls_datum_t,
        signature: *mut ::libc::c_void,
        signature_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_sign(
        crq: gnutls_x509_crq_t,
        key: gnutls_x509_privkey_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_sign2(
        crq: gnutls_x509_crq_t,
        key: gnutls_x509_privkey_t,
        dig: gnutls_digest_algorithm_t::Type,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_print(
        crq: gnutls_x509_crq_t,
        format: gnutls_certificate_print_formats_t,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_verify(crq: gnutls_x509_crq_t, flags: ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_init(crq: *mut gnutls_x509_crq_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_deinit(crq: gnutls_x509_crq_t);
}
extern "C" {
    pub fn gnutls_x509_crq_import(
        crq: gnutls_x509_crq_t,
        data: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_private_key_usage_period(
        cert: gnutls_x509_crq_t,
        activation: *mut time_t,
        expiration: *mut time_t,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_dn(
        crq: gnutls_x509_crq_t,
        buf: *mut ::libc::c_char,
        sizeof_buf: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_dn2(
        crq: gnutls_x509_crq_t,
        dn: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_dn3(
        crq: gnutls_x509_crq_t,
        dn: *mut gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_dn_oid(
        crq: gnutls_x509_crq_t,
        indx: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        sizeof_oid: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_dn_by_oid(
        crq: gnutls_x509_crq_t,
        oid: *const ::libc::c_char,
        indx: ::libc::c_uint,
        raw_flag: ::libc::c_uint,
        buf: *mut ::libc::c_void,
        sizeof_buf: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_dn(
        crq: gnutls_x509_crq_t,
        dn: *const ::libc::c_char,
        err: *mut *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_dn_by_oid(
        crq: gnutls_x509_crq_t,
        oid: *const ::libc::c_char,
        raw_flag: ::libc::c_uint,
        data: *const ::libc::c_void,
        sizeof_data: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_version(
        crq: gnutls_x509_crq_t,
        version: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_version(crq: gnutls_x509_crq_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_key(
        crq: gnutls_x509_crq_t,
        key: gnutls_x509_privkey_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_extension_by_oid(
        crq: gnutls_x509_crq_t,
        oid: *const ::libc::c_char,
        buf: *const ::libc::c_void,
        sizeof_buf: usize,
        critical: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_challenge_password(
        crq: gnutls_x509_crq_t,
        pass: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_challenge_password(
        crq: gnutls_x509_crq_t,
        pass: *mut ::libc::c_char,
        sizeof_pass: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_attribute_by_oid(
        crq: gnutls_x509_crq_t,
        oid: *const ::libc::c_char,
        buf: *mut ::libc::c_void,
        sizeof_buf: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_attribute_by_oid(
        crq: gnutls_x509_crq_t,
        oid: *const ::libc::c_char,
        indx: ::libc::c_uint,
        buf: *mut ::libc::c_void,
        sizeof_buf: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_export(
        crq: gnutls_x509_crq_t,
        format: gnutls_x509_crt_fmt_t::Type,
        output_data: *mut ::libc::c_void,
        output_data_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_export2(
        crq: gnutls_x509_crq_t,
        format: gnutls_x509_crt_fmt_t::Type,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_crq(crt: gnutls_x509_crt_t, crq: gnutls_x509_crq_t)
        -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_crq_extensions(
        crt: gnutls_x509_crt_t,
        crq: gnutls_x509_crq_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_set_crq_extension_by_oid(
        crt: gnutls_x509_crt_t,
        crq: gnutls_x509_crq_t,
        oid: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_private_key_usage_period(
        crq: gnutls_x509_crq_t,
        activation: time_t,
        expiration: time_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_key_rsa_raw(
        crq: gnutls_x509_crq_t,
        m: *const gnutls_datum_t,
        e: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_subject_alt_name(
        crq: gnutls_x509_crq_t,
        nt: gnutls_x509_subject_alt_name_t::Type,
        data: *const ::libc::c_void,
        data_size: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_subject_alt_othername(
        crq: gnutls_x509_crq_t,
        oid: *const ::libc::c_char,
        data: *const ::libc::c_void,
        data_size: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_key_usage(
        crq: gnutls_x509_crq_t,
        usage: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_basic_constraints(
        crq: gnutls_x509_crq_t,
        ca: ::libc::c_uint,
        pathLenConstraint: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_key_purpose_oid(
        crq: gnutls_x509_crq_t,
        oid: *const ::libc::c_void,
        critical: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_key_purpose_oid(
        crq: gnutls_x509_crq_t,
        indx: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        sizeof_oid: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_extension_data(
        crq: gnutls_x509_crq_t,
        indx: ::libc::c_uint,
        data: *mut ::libc::c_void,
        sizeof_data: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_extension_data2(
        crq: gnutls_x509_crq_t,
        indx: ::libc::c_uint,
        data: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_extension_info(
        crq: gnutls_x509_crq_t,
        indx: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        sizeof_oid: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_attribute_data(
        crq: gnutls_x509_crq_t,
        indx: ::libc::c_uint,
        data: *mut ::libc::c_void,
        sizeof_data: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_attribute_info(
        crq: gnutls_x509_crq_t,
        indx: ::libc::c_uint,
        oid: *mut ::libc::c_void,
        sizeof_oid: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_pk_algorithm(
        crq: gnutls_x509_crq_t,
        bits: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_spki(
        crq: gnutls_x509_crq_t,
        spki: gnutls_x509_spki_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_spki(
        crq: gnutls_x509_crq_t,
        spki: gnutls_x509_spki_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_signature_oid(
        crq: gnutls_x509_crq_t,
        oid: *mut ::libc::c_char,
        oid_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_pk_oid(
        crq: gnutls_x509_crq_t,
        oid: *mut ::libc::c_char,
        oid_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_key_id(
        crq: gnutls_x509_crq_t,
        flags: ::libc::c_uint,
        output_data: *mut ::libc::c_uchar,
        output_data_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_key_rsa_raw(
        crq: gnutls_x509_crq_t,
        m: *mut gnutls_datum_t,
        e: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_key_usage(
        crq: gnutls_x509_crq_t,
        key_usage: *mut ::libc::c_uint,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_basic_constraints(
        crq: gnutls_x509_crq_t,
        critical: *mut ::libc::c_uint,
        ca: *mut ::libc::c_uint,
        pathlen: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_subject_alt_name(
        crq: gnutls_x509_crq_t,
        seq: ::libc::c_uint,
        ret: *mut ::libc::c_void,
        ret_size: *mut usize,
        ret_type: *mut ::libc::c_uint,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_subject_alt_othername_oid(
        crq: gnutls_x509_crq_t,
        seq: ::libc::c_uint,
        ret: *mut ::libc::c_void,
        ret_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_extension_by_oid(
        crq: gnutls_x509_crq_t,
        oid: *const ::libc::c_char,
        indx: ::libc::c_uint,
        buf: *mut ::libc::c_void,
        sizeof_buf: *mut usize,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_get_tlsfeatures(
        crq: gnutls_x509_crq_t,
        features: gnutls_x509_tlsfeatures_t,
        flags: ::libc::c_uint,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crq_set_tlsfeatures(
        crq: gnutls_x509_crq_t,
        features: gnutls_x509_tlsfeatures_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_extension_by_oid2(
        cert: gnutls_x509_crt_t,
        oid: *const ::libc::c_char,
        indx: ::libc::c_uint,
        output: *mut gnutls_datum_t,
        critical: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_trust_list_st {
    _unused: [u8; 0],
}
pub type gnutls_x509_trust_list_t = *mut gnutls_x509_trust_list_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_trust_list_iter {
    _unused: [u8; 0],
}
pub type gnutls_x509_trust_list_iter_t = *mut gnutls_x509_trust_list_iter;
extern "C" {
    pub fn gnutls_x509_trust_list_init(
        list: *mut gnutls_x509_trust_list_t,
        size: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_deinit(list: gnutls_x509_trust_list_t, all: ::libc::c_uint);
}
extern "C" {
    pub fn gnutls_x509_trust_list_get_issuer(
        list: gnutls_x509_trust_list_t,
        cert: gnutls_x509_crt_t,
        issuer: *mut gnutls_x509_crt_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_get_issuer_by_dn(
        list: gnutls_x509_trust_list_t,
        dn: *const gnutls_datum_t,
        issuer: *mut gnutls_x509_crt_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_get_issuer_by_subject_key_id(
        list: gnutls_x509_trust_list_t,
        dn: *const gnutls_datum_t,
        spki: *const gnutls_datum_t,
        issuer: *mut gnutls_x509_crt_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
pub mod gnutls_trust_list_flags_t {
    pub type Type = u32;
    pub const GNUTLS_TL_VERIFY_CRL: Type = 1;
    pub const GNUTLS_TL_USE_IN_TLS: Type = 2;
    pub const GNUTLS_TL_NO_DUPLICATES: Type = 4;
    pub const GNUTLS_TL_NO_DUPLICATE_KEY: Type = 8;
    pub const GNUTLS_TL_GET_COPY: Type = 16;
    pub const GNUTLS_TL_FAIL_ON_INVALID_CRL: Type = 32;
}
extern "C" {
    pub fn gnutls_x509_trust_list_add_cas(
        list: gnutls_x509_trust_list_t,
        clist: *const gnutls_x509_crt_t,
        clist_size: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_remove_cas(
        list: gnutls_x509_trust_list_t,
        clist: *const gnutls_x509_crt_t,
        clist_size: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_add_named_crt(
        list: gnutls_x509_trust_list_t,
        cert: gnutls_x509_crt_t,
        name: *const ::libc::c_void,
        name_size: usize,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_add_crls(
        list: gnutls_x509_trust_list_t,
        crl_list: *const gnutls_x509_crl_t,
        crl_size: ::libc::c_uint,
        flags: ::libc::c_uint,
        verification_flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_iter_get_ca(
        list: gnutls_x509_trust_list_t,
        iter: *mut gnutls_x509_trust_list_iter_t,
        crt: *mut gnutls_x509_crt_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_iter_deinit(iter: gnutls_x509_trust_list_iter_t);
}
pub type gnutls_verify_output_function = ::std::option::Option<
    unsafe extern "C" fn(
        cert: gnutls_x509_crt_t,
        issuer: gnutls_x509_crt_t,
        crl: gnutls_x509_crl_t,
        verification_output: ::libc::c_uint,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_session_set_verify_output_function(
        session: gnutls_session_t,
        func: gnutls_verify_output_function,
    );
}
extern "C" {
    pub fn gnutls_x509_trust_list_verify_named_crt(
        list: gnutls_x509_trust_list_t,
        cert: gnutls_x509_crt_t,
        name: *const ::libc::c_void,
        name_size: usize,
        flags: ::libc::c_uint,
        verify: *mut ::libc::c_uint,
        func: gnutls_verify_output_function,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_verify_crt2(
        list: gnutls_x509_trust_list_t,
        cert_list: *mut gnutls_x509_crt_t,
        cert_list_size: ::libc::c_uint,
        data: *mut gnutls_typed_vdata_st,
        elements: ::libc::c_uint,
        flags: ::libc::c_uint,
        voutput: *mut ::libc::c_uint,
        func: gnutls_verify_output_function,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_verify_crt(
        list: gnutls_x509_trust_list_t,
        cert_list: *mut gnutls_x509_crt_t,
        cert_list_size: ::libc::c_uint,
        flags: ::libc::c_uint,
        verify: *mut ::libc::c_uint,
        func: gnutls_verify_output_function,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_add_trust_mem(
        list: gnutls_x509_trust_list_t,
        cas: *const gnutls_datum_t,
        crls: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t::Type,
        tl_flags: ::libc::c_uint,
        tl_vflags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_add_trust_file(
        list: gnutls_x509_trust_list_t,
        ca_file: *const ::libc::c_char,
        crl_file: *const ::libc::c_char,
        type_: gnutls_x509_crt_fmt_t::Type,
        tl_flags: ::libc::c_uint,
        tl_vflags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_add_trust_dir(
        list: gnutls_x509_trust_list_t,
        ca_dir: *const ::libc::c_char,
        crl_dir: *const ::libc::c_char,
        type_: gnutls_x509_crt_fmt_t::Type,
        tl_flags: ::libc::c_uint,
        tl_vflags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_remove_trust_file(
        list: gnutls_x509_trust_list_t,
        ca_file: *const ::libc::c_char,
        type_: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_remove_trust_mem(
        list: gnutls_x509_trust_list_t,
        cas: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_x509_trust_list_add_system_trust(
        list: gnutls_x509_trust_list_t,
        tl_flags: ::libc::c_uint,
        tl_vflags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
pub type gnutls_x509_trust_list_getissuer_function = ::std::option::Option<
    unsafe extern "C" fn(
        list: gnutls_x509_trust_list_t,
        cert: gnutls_x509_crt_t,
        issuers: *mut *mut gnutls_x509_crt_t,
        issuers_size: *mut ::libc::c_uint,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn gnutls_x509_trust_list_set_getissuer_function(
        tlist: gnutls_x509_trust_list_t,
        func: gnutls_x509_trust_list_getissuer_function,
    );
}
extern "C" {
    pub fn gnutls_x509_trust_list_set_ptr(
        tlist: gnutls_x509_trust_list_t,
        ptr: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn gnutls_x509_trust_list_get_ptr(tlist: gnutls_x509_trust_list_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn gnutls_certificate_set_trust_list(
        res: gnutls_certificate_credentials_t,
        tlist: gnutls_x509_trust_list_t,
        flags: ::libc::c_uint,
    );
}
extern "C" {
    pub fn gnutls_certificate_get_trust_list(
        res: gnutls_certificate_credentials_t,
        tlist: *mut gnutls_x509_trust_list_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_ext_st {
    pub oid: *mut ::libc::c_char,
    pub critical: ::libc::c_uint,
    pub data: gnutls_datum_t,
}
#[test]
fn bindgen_test_layout_gnutls_x509_ext_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_x509_ext_st>(),
        32usize,
        concat!("Size of: ", stringify!(gnutls_x509_ext_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_x509_ext_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_x509_ext_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_x509_ext_st>())).oid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_x509_ext_st),
            "::",
            stringify!(oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_x509_ext_st>())).critical as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_x509_ext_st),
            "::",
            stringify!(critical)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_x509_ext_st>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_x509_ext_st),
            "::",
            stringify!(data)
        )
    );
}
impl Default for gnutls_x509_ext_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn gnutls_x509_ext_deinit(ext: *mut gnutls_x509_ext_st);
}
extern "C" {
    pub fn gnutls_x509_ext_print(
        exts: *mut gnutls_x509_ext_st,
        exts_size: ::libc::c_uint,
        format: gnutls_certificate_print_formats_t,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_pkcs7_int {
    _unused: [u8; 0],
}
pub type gnutls_pkcs7_t = *mut gnutls_pkcs7_int;
extern "C" {
    pub fn gnutls_pkcs7_init(pkcs7: *mut gnutls_pkcs7_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_deinit(pkcs7: gnutls_pkcs7_t);
}
extern "C" {
    pub fn gnutls_pkcs7_import(
        pkcs7: gnutls_pkcs7_t,
        data: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_export(
        pkcs7: gnutls_pkcs7_t,
        format: gnutls_x509_crt_fmt_t::Type,
        output_data: *mut ::libc::c_void,
        output_data_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_export2(
        pkcs7: gnutls_pkcs7_t,
        format: gnutls_x509_crt_fmt_t::Type,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_get_signature_count(pkcs7: gnutls_pkcs7_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_get_embedded_data(
        pkcs7: gnutls_pkcs7_t,
        flags: ::libc::c_uint,
        data: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_get_embedded_data_oid(pkcs7: gnutls_pkcs7_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn gnutls_pkcs7_get_crt_count(pkcs7: gnutls_pkcs7_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_get_crt_raw(
        pkcs7: gnutls_pkcs7_t,
        indx: ::libc::c_uint,
        certificate: *mut ::libc::c_void,
        certificate_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_set_crt_raw(
        pkcs7: gnutls_pkcs7_t,
        crt: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_set_crt(pkcs7: gnutls_pkcs7_t, crt: gnutls_x509_crt_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_delete_crt(pkcs7: gnutls_pkcs7_t, indx: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_get_crl_raw(
        pkcs7: gnutls_pkcs7_t,
        indx: ::libc::c_uint,
        crl: *mut ::libc::c_void,
        crl_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_get_crl_count(pkcs7: gnutls_pkcs7_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_set_crl_raw(
        pkcs7: gnutls_pkcs7_t,
        crl: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_set_crl(pkcs7: gnutls_pkcs7_t, crl: gnutls_x509_crl_t) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_delete_crl(pkcs7: gnutls_pkcs7_t, indx: ::libc::c_int) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_pkcs7_attrs_st {
    _unused: [u8; 0],
}
pub type gnutls_pkcs7_attrs_t = *mut gnutls_pkcs7_attrs_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnutls_pkcs7_signature_info_st {
    pub algo: gnutls_sign_algorithm_t::Type,
    pub sig: gnutls_datum_t,
    pub issuer_dn: gnutls_datum_t,
    pub signer_serial: gnutls_datum_t,
    pub issuer_keyid: gnutls_datum_t,
    pub signing_time: time_t,
    pub signed_attrs: gnutls_pkcs7_attrs_t,
    pub unsigned_attrs: gnutls_pkcs7_attrs_t,
    pub pad: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_gnutls_pkcs7_signature_info_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_pkcs7_signature_info_st>(),
        160usize,
        concat!("Size of: ", stringify!(gnutls_pkcs7_signature_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_pkcs7_signature_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_pkcs7_signature_info_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_pkcs7_signature_info_st>())).algo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_pkcs7_signature_info_st),
            "::",
            stringify!(algo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_pkcs7_signature_info_st>())).sig as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_pkcs7_signature_info_st),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_pkcs7_signature_info_st>())).issuer_dn as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_pkcs7_signature_info_st),
            "::",
            stringify!(issuer_dn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_pkcs7_signature_info_st>())).signer_serial as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_pkcs7_signature_info_st),
            "::",
            stringify!(signer_serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_pkcs7_signature_info_st>())).issuer_keyid as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_pkcs7_signature_info_st),
            "::",
            stringify!(issuer_keyid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_pkcs7_signature_info_st>())).signing_time as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_pkcs7_signature_info_st),
            "::",
            stringify!(signing_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_pkcs7_signature_info_st>())).signed_attrs as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_pkcs7_signature_info_st),
            "::",
            stringify!(signed_attrs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_pkcs7_signature_info_st>())).unsigned_attrs as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_pkcs7_signature_info_st),
            "::",
            stringify!(unsigned_attrs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_pkcs7_signature_info_st>())).pad as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_pkcs7_signature_info_st),
            "::",
            stringify!(pad)
        )
    );
}
impl Default for gnutls_pkcs7_signature_info_st {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn gnutls_pkcs7_signature_info_deinit(info: *mut gnutls_pkcs7_signature_info_st);
}
extern "C" {
    pub fn gnutls_pkcs7_get_signature_info(
        pkcs7: gnutls_pkcs7_t,
        idx: ::libc::c_uint,
        info: *mut gnutls_pkcs7_signature_info_st,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_verify_direct(
        pkcs7: gnutls_pkcs7_t,
        signer: gnutls_x509_crt_t,
        idx: ::libc::c_uint,
        data: *const gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_verify(
        pkcs7: gnutls_pkcs7_t,
        tl: gnutls_x509_trust_list_t,
        vdata: *mut gnutls_typed_vdata_st,
        vdata_size: ::libc::c_uint,
        idx: ::libc::c_uint,
        data: *const gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_add_attr(
        list: *mut gnutls_pkcs7_attrs_t,
        oid: *const ::libc::c_char,
        data: *mut gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_attrs_deinit(list: gnutls_pkcs7_attrs_t);
}
extern "C" {
    pub fn gnutls_pkcs7_get_attr(
        list: gnutls_pkcs7_attrs_t,
        idx: ::libc::c_uint,
        oid: *mut *mut ::libc::c_char,
        data: *mut gnutls_datum_t,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
pub mod gnutls_pkcs7_sign_flags {
    pub type Type = u32;
    pub const GNUTLS_PKCS7_EMBED_DATA: Type = 1;
    pub const GNUTLS_PKCS7_INCLUDE_TIME: Type = 2;
    pub const GNUTLS_PKCS7_INCLUDE_CERT: Type = 4;
    pub const GNUTLS_PKCS7_WRITE_SPKI: Type = 8;
}
extern "C" {
    pub fn gnutls_pkcs7_sign(
        pkcs7: gnutls_pkcs7_t,
        signer: gnutls_x509_crt_t,
        signer_key: gnutls_privkey_t,
        data: *const gnutls_datum_t,
        signed_attrs: gnutls_pkcs7_attrs_t,
        unsigned_attrs: gnutls_pkcs7_attrs_t,
        dig: gnutls_digest_algorithm_t::Type,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_get_crt_raw2(
        pkcs7: gnutls_pkcs7_t,
        indx: ::libc::c_uint,
        cert: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_get_crl_raw2(
        pkcs7: gnutls_pkcs7_t,
        indx: ::libc::c_uint,
        crl: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_print(
        pkcs7: gnutls_pkcs7_t,
        format: gnutls_certificate_print_formats_t,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pkcs7_print_signature_info(
        info: *mut gnutls_pkcs7_signature_info_st,
        format: gnutls_certificate_print_formats_t,
        out: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct api_cipher_hd_st {
    _unused: [u8; 0],
}
pub type gnutls_cipher_hd_t = *mut api_cipher_hd_st;
extern "C" {
    pub fn gnutls_cipher_init(
        handle: *mut gnutls_cipher_hd_t,
        cipher: gnutls_cipher_algorithm_t,
        key: *const gnutls_datum_t,
        iv: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_cipher_encrypt(
        handle: gnutls_cipher_hd_t,
        text: *mut ::libc::c_void,
        textlen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_cipher_decrypt(
        handle: gnutls_cipher_hd_t,
        ciphertext: *mut ::libc::c_void,
        ciphertextlen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_cipher_decrypt2(
        handle: gnutls_cipher_hd_t,
        ciphertext: *const ::libc::c_void,
        ciphertextlen: usize,
        text: *mut ::libc::c_void,
        textlen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_cipher_encrypt2(
        handle: gnutls_cipher_hd_t,
        text: *const ::libc::c_void,
        textlen: usize,
        ciphertext: *mut ::libc::c_void,
        ciphertextlen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_cipher_set_iv(handle: gnutls_cipher_hd_t, iv: *mut ::libc::c_void, ivlen: usize);
}
extern "C" {
    pub fn gnutls_cipher_tag(
        handle: gnutls_cipher_hd_t,
        tag: *mut ::libc::c_void,
        tag_size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_cipher_add_auth(
        handle: gnutls_cipher_hd_t,
        text: *const ::libc::c_void,
        text_size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_cipher_deinit(handle: gnutls_cipher_hd_t);
}
extern "C" {
    pub fn gnutls_cipher_get_block_size(algorithm: gnutls_cipher_algorithm_t) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_cipher_get_iv_size(algorithm: gnutls_cipher_algorithm_t) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_cipher_get_tag_size(algorithm: gnutls_cipher_algorithm_t) -> ::libc::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct api_aead_cipher_hd_st {
    _unused: [u8; 0],
}
pub type gnutls_aead_cipher_hd_t = *mut api_aead_cipher_hd_st;
extern "C" {
    pub fn gnutls_aead_cipher_init(
        handle: *mut gnutls_aead_cipher_hd_t,
        cipher: gnutls_cipher_algorithm_t,
        key: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_aead_cipher_decrypt(
        handle: gnutls_aead_cipher_hd_t,
        nonce: *const ::libc::c_void,
        nonce_len: usize,
        auth: *const ::libc::c_void,
        auth_len: usize,
        tag_size: usize,
        ctext: *const ::libc::c_void,
        ctext_len: usize,
        ptext: *mut ::libc::c_void,
        ptext_len: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_aead_cipher_encrypt(
        handle: gnutls_aead_cipher_hd_t,
        nonce: *const ::libc::c_void,
        nonce_len: usize,
        auth: *const ::libc::c_void,
        auth_len: usize,
        tag_size: usize,
        ptext: *const ::libc::c_void,
        ptext_len: usize,
        ctext: *mut ::libc::c_void,
        ctext_len: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_aead_cipher_encryptv(
        handle: gnutls_aead_cipher_hd_t,
        nonce: *const ::libc::c_void,
        nonce_len: usize,
        auth_iov: *const giovec_t,
        auth_iovcnt: ::libc::c_int,
        tag_size: usize,
        iov: *const giovec_t,
        iovcnt: ::libc::c_int,
        ctext: *mut ::libc::c_void,
        ctext_len: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_aead_cipher_encryptv2(
        handle: gnutls_aead_cipher_hd_t,
        nonce: *const ::libc::c_void,
        nonce_len: usize,
        auth_iov: *const giovec_t,
        auth_iovcnt: ::libc::c_int,
        iov: *const giovec_t,
        iovcnt: ::libc::c_int,
        tag: *mut ::libc::c_void,
        tag_size: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_aead_cipher_decryptv2(
        handle: gnutls_aead_cipher_hd_t,
        nonce: *const ::libc::c_void,
        nonce_len: usize,
        auth_iov: *const giovec_t,
        auth_iovcnt: ::libc::c_int,
        iov: *const giovec_t,
        iovcnt: ::libc::c_int,
        tag: *mut ::libc::c_void,
        tag_size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_aead_cipher_deinit(handle: gnutls_aead_cipher_hd_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hash_hd_st {
    _unused: [u8; 0],
}
pub type gnutls_hash_hd_t = *mut hash_hd_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_hd_st {
    _unused: [u8; 0],
}
pub type gnutls_hmac_hd_t = *mut hmac_hd_st;
extern "C" {
    pub fn gnutls_mac_get_nonce_size(algorithm: gnutls_mac_algorithm_t::Type) -> usize;
}
extern "C" {
    pub fn gnutls_hmac_init(
        dig: *mut gnutls_hmac_hd_t,
        algorithm: gnutls_mac_algorithm_t::Type,
        key: *const ::libc::c_void,
        keylen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_hmac_set_nonce(
        handle: gnutls_hmac_hd_t,
        nonce: *const ::libc::c_void,
        nonce_len: usize,
    );
}
extern "C" {
    pub fn gnutls_hmac(
        handle: gnutls_hmac_hd_t,
        text: *const ::libc::c_void,
        textlen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_hmac_output(handle: gnutls_hmac_hd_t, digest: *mut ::libc::c_void);
}
extern "C" {
    pub fn gnutls_hmac_deinit(handle: gnutls_hmac_hd_t, digest: *mut ::libc::c_void);
}
extern "C" {
    pub fn gnutls_hmac_get_len(algorithm: gnutls_mac_algorithm_t::Type) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_hmac_get_key_size(algorithm: gnutls_mac_algorithm_t::Type) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_hmac_fast(
        algorithm: gnutls_mac_algorithm_t::Type,
        key: *const ::libc::c_void,
        keylen: usize,
        text: *const ::libc::c_void,
        textlen: usize,
        digest: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_hmac_copy(handle: gnutls_hmac_hd_t) -> gnutls_hmac_hd_t;
}
extern "C" {
    pub fn gnutls_hash_init(
        dig: *mut gnutls_hash_hd_t,
        algorithm: gnutls_digest_algorithm_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_hash(
        handle: gnutls_hash_hd_t,
        text: *const ::libc::c_void,
        textlen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_hash_output(handle: gnutls_hash_hd_t, digest: *mut ::libc::c_void);
}
extern "C" {
    pub fn gnutls_hash_deinit(handle: gnutls_hash_hd_t, digest: *mut ::libc::c_void);
}
extern "C" {
    pub fn gnutls_hash_get_len(algorithm: gnutls_digest_algorithm_t::Type) -> ::libc::c_uint;
}
extern "C" {
    pub fn gnutls_hash_fast(
        algorithm: gnutls_digest_algorithm_t::Type,
        text: *const ::libc::c_void,
        textlen: usize,
        digest: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_hash_copy(handle: gnutls_hash_hd_t) -> gnutls_hash_hd_t;
}
extern "C" {
    pub fn gnutls_hkdf_extract(
        mac: gnutls_mac_algorithm_t::Type,
        key: *const gnutls_datum_t,
        salt: *const gnutls_datum_t,
        output: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_hkdf_expand(
        mac: gnutls_mac_algorithm_t::Type,
        key: *const gnutls_datum_t,
        info: *const gnutls_datum_t,
        output: *mut ::libc::c_void,
        length: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_pbkdf2(
        mac: gnutls_mac_algorithm_t::Type,
        key: *const gnutls_datum_t,
        salt: *const gnutls_datum_t,
        iter_count: ::libc::c_uint,
        output: *mut ::libc::c_void,
        length: usize,
    ) -> ::libc::c_int;
}
pub mod gnutls_rnd_level {
    pub type Type = u32;
    pub const GNUTLS_RND_NONCE: Type = 0;
    pub const GNUTLS_RND_RANDOM: Type = 1;
    pub const GNUTLS_RND_KEY: Type = 2;
}
pub use self::gnutls_rnd_level::Type as gnutls_rnd_level_t;
extern "C" {
    pub fn gnutls_rnd(
        level: gnutls_rnd_level_t,
        data: *mut ::libc::c_void,
        len: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_rnd_refresh();
}
pub type gnutls_cipher_init_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_cipher_algorithm_t,
        ctx: *mut *mut ::libc::c_void,
        enc: ::libc::c_int,
    ) -> ::libc::c_int,
>;
pub type gnutls_cipher_setkey_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        key: *const ::libc::c_void,
        keysize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_cipher_setiv_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        iv: *const ::libc::c_void,
        ivsize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_cipher_getiv_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        iv: *mut ::libc::c_void,
        ivsize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_cipher_encrypt_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        plain: *const ::libc::c_void,
        plainsize: usize,
        encr: *mut ::libc::c_void,
        encrsize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_cipher_decrypt_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        encr: *const ::libc::c_void,
        encrsize: usize,
        plain: *mut ::libc::c_void,
        plainsize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_cipher_auth_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        data: *const ::libc::c_void,
        datasize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_cipher_tag_func = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::libc::c_void, tag: *mut ::libc::c_void, tagsize: usize),
>;
pub type gnutls_cipher_aead_encrypt_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        nonce: *const ::libc::c_void,
        noncesize: usize,
        auth: *const ::libc::c_void,
        authsize: usize,
        tag_size: usize,
        plain: *const ::libc::c_void,
        plainsize: usize,
        encr: *mut ::libc::c_void,
        encrsize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_cipher_aead_decrypt_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        nonce: *const ::libc::c_void,
        noncesize: usize,
        auth: *const ::libc::c_void,
        authsize: usize,
        tag_size: usize,
        encr: *const ::libc::c_void,
        encrsize: usize,
        plain: *mut ::libc::c_void,
        plainsize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_cipher_deinit_func =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::libc::c_void)>;
extern "C" {
    pub fn gnutls_crypto_register_cipher(
        algorithm: gnutls_cipher_algorithm_t,
        priority: ::libc::c_int,
        init: gnutls_cipher_init_func,
        setkey: gnutls_cipher_setkey_func,
        setiv: gnutls_cipher_setiv_func,
        encrypt: gnutls_cipher_encrypt_func,
        decrypt: gnutls_cipher_decrypt_func,
        deinit: gnutls_cipher_deinit_func,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_crypto_register_aead_cipher(
        algorithm: gnutls_cipher_algorithm_t,
        priority: ::libc::c_int,
        init: gnutls_cipher_init_func,
        setkey: gnutls_cipher_setkey_func,
        aead_encrypt: gnutls_cipher_aead_encrypt_func,
        aead_decrypt: gnutls_cipher_aead_decrypt_func,
        deinit: gnutls_cipher_deinit_func,
    ) -> ::libc::c_int;
}
pub type gnutls_mac_init_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_mac_algorithm_t::Type,
        ctx: *mut *mut ::libc::c_void,
    ) -> ::libc::c_int,
>;
pub type gnutls_mac_setkey_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        key: *const ::libc::c_void,
        keysize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_mac_setnonce_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        nonce: *const ::libc::c_void,
        noncesize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_mac_hash_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        text: *const ::libc::c_void,
        textsize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_mac_output_func = ::std::option::Option<
    unsafe extern "C" fn(
        src_ctx: *mut ::libc::c_void,
        digest: *mut ::libc::c_void,
        digestsize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_mac_deinit_func =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::libc::c_void)>;
pub type gnutls_mac_fast_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_mac_algorithm_t::Type,
        nonce: *const ::libc::c_void,
        nonce_size: usize,
        key: *const ::libc::c_void,
        keysize: usize,
        text: *const ::libc::c_void,
        textsize: usize,
        digest: *mut ::libc::c_void,
    ) -> ::libc::c_int,
>;
pub type gnutls_mac_copy_func =
    ::std::option::Option<unsafe extern "C" fn(ctx: *const ::libc::c_void) -> *mut ::libc::c_void>;
extern "C" {
    pub fn gnutls_crypto_register_mac(
        mac: gnutls_mac_algorithm_t::Type,
        priority: ::libc::c_int,
        init: gnutls_mac_init_func,
        setkey: gnutls_mac_setkey_func,
        setnonce: gnutls_mac_setnonce_func,
        hash: gnutls_mac_hash_func,
        output: gnutls_mac_output_func,
        deinit: gnutls_mac_deinit_func,
        hash_fast: gnutls_mac_fast_func,
    ) -> ::libc::c_int;
}
pub type gnutls_digest_init_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_digest_algorithm_t::Type,
        ctx: *mut *mut ::libc::c_void,
    ) -> ::libc::c_int,
>;
pub type gnutls_digest_hash_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        text: *const ::libc::c_void,
        textsize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_digest_output_func = ::std::option::Option<
    unsafe extern "C" fn(
        src_ctx: *mut ::libc::c_void,
        digest: *mut ::libc::c_void,
        digestsize: usize,
    ) -> ::libc::c_int,
>;
pub type gnutls_digest_deinit_func =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::libc::c_void)>;
pub type gnutls_digest_fast_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_digest_algorithm_t::Type,
        text: *const ::libc::c_void,
        textsize: usize,
        digest: *mut ::libc::c_void,
    ) -> ::libc::c_int,
>;
pub type gnutls_digest_copy_func =
    ::std::option::Option<unsafe extern "C" fn(ctx: *const ::libc::c_void) -> *mut ::libc::c_void>;
extern "C" {
    pub fn gnutls_crypto_register_digest(
        digest: gnutls_digest_algorithm_t::Type,
        priority: ::libc::c_int,
        init: gnutls_digest_init_func,
        hash: gnutls_digest_hash_func,
        output: gnutls_digest_output_func,
        deinit: gnutls_digest_deinit_func,
        hash_fast: gnutls_digest_fast_func,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_encode_ber_digest_info(
        hash: gnutls_digest_algorithm_t::Type,
        digest: *const gnutls_datum_t,
        output: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_decode_ber_digest_info(
        info: *const gnutls_datum_t,
        hash: *mut gnutls_digest_algorithm_t::Type,
        digest: *mut ::libc::c_uchar,
        digest_size: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_decode_rs_value(
        sig_value: *const gnutls_datum_t,
        r: *mut gnutls_datum_t,
        s: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_encode_rs_value(
        sig_value: *mut gnutls_datum_t,
        r: *const gnutls_datum_t,
        s: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_encode_gost_rs_value(
        sig_value: *mut gnutls_datum_t,
        r: *const gnutls_datum_t,
        s: *const gnutls_datum_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_decode_gost_rs_value(
        sig_value: *const gnutls_datum_t,
        r: *mut gnutls_datum_t,
        s: *mut gnutls_datum_t,
    ) -> ::libc::c_int;
}
pub mod gnutls_initstage_t {
    pub type Type = u32;
    pub const GNUTLS_STAGE_EMPTY: Type = 0;
    pub const GNUTLS_STAGE_CRED_ALLOC: Type = 1;
    pub const GNUTLS_STAGE_FILES: Type = 2;
    pub const GNUTLS_STAGE_CALLBACKS: Type = 3;
    pub const GNUTLS_STAGE_INIT: Type = 4;
    pub const GNUTLS_STAGE_PRIORITY: Type = 5;
    pub const GNUTLS_STAGE_CRED_SET: Type = 6;
    pub const GNUTLS_STAGE_HANDSHAKE_CANDO: Type = 6;
    pub const GNUTLS_STAGE_TRANSPORT_POINTERS_SET: Type = 7;
    pub const GNUTLS_STAGE_HANDSHAKE_TRIED: Type = 8;
    pub const GNUTLS_STAGE_READY: Type = 9;
}
extern "C" {
    pub fn emacs_gnutls_write(
        proc_: *mut Lisp_Process,
        buf: *const ::libc::c_char,
        nbyte: isize,
    ) -> isize;
}
extern "C" {
    pub fn emacs_gnutls_read(
        proc_: *mut Lisp_Process,
        buf: *mut ::libc::c_char,
        nbyte: isize,
    ) -> isize;
}
extern "C" {
    pub fn emacs_gnutls_record_check_pending(state: gnutls_session_t) -> isize;
}
extern "C" {
    pub fn emacs_gnutls_deinit(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn emacs_gnutls_global_init() -> Lisp_Object;
}
extern "C" {
    pub fn gnutls_try_handshake(p: *mut Lisp_Process) -> ::libc::c_int;
}
extern "C" {
    pub fn gnutls_verify_boot(proc_: Lisp_Object, proplist: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn syms_of_gnutls();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct position {
    pub bufpos: isize,
    pub bytepos: isize,
    pub hpos: EMACS_INT,
    pub vpos: EMACS_INT,
    pub prevhpos: EMACS_INT,
    pub contin: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_position() {
    assert_eq!(
        ::std::mem::size_of::<position>(),
        48usize,
        concat!("Size of: ", stringify!(position))
    );
    assert_eq!(
        ::std::mem::align_of::<position>(),
        8usize,
        concat!("Alignment of ", stringify!(position))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<position>())).bufpos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(position),
            "::",
            stringify!(bufpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<position>())).bytepos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(position),
            "::",
            stringify!(bytepos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<position>())).hpos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(position),
            "::",
            stringify!(hpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<position>())).vpos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(position),
            "::",
            stringify!(vpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<position>())).prevhpos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(position),
            "::",
            stringify!(prevhpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<position>())).contin as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(position),
            "::",
            stringify!(contin)
        )
    );
}
extern "C" {
    pub fn compute_motion(
        from: isize,
        frombyte: isize,
        fromvpos: EMACS_INT,
        fromhpos: EMACS_INT,
        did_motion: bool,
        to: isize,
        tovpos: EMACS_INT,
        tohpos: EMACS_INT,
        width: EMACS_INT,
        hscroll: isize,
        tab_offset: ::libc::c_int,
        arg1: *mut window,
    ) -> *mut position;
}
extern "C" {
    pub fn vmotion(
        from: isize,
        from_byte: isize,
        vtarget: EMACS_INT,
        arg1: *mut window,
    ) -> *mut position;
}
extern "C" {
    pub fn skip_invisible(
        pos: isize,
        next_boundary_p: *mut isize,
        to: isize,
        window: Lisp_Object,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}last_known_column_point"]
    pub static mut last_known_column_point: isize;
}
extern "C" {
    pub fn disptab_matches_widthtab(
        disptab: *mut Lisp_Char_Table,
        widthtab: *mut Lisp_Vector,
    ) -> bool;
}
extern "C" {
    pub fn recompute_width_table(buf: *mut buffer, disptab: *mut Lisp_Char_Table);
}
#[repr(C)]
pub struct interval {
    pub total_length: isize,
    pub position: isize,
    pub left: *mut interval,
    pub right: *mut interval,
    pub up: interval__bindgen_ty_1,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub plist: Lisp_Object,
}
#[repr(C)]
#[repr(align(8))]
pub union interval__bindgen_ty_1 {
    pub interval: *mut interval,
    pub obj: Lisp_Object,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_interval__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<interval__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(interval__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<interval__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(interval__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<interval__bindgen_ty_1>())).interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interval__bindgen_ty_1),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<interval__bindgen_ty_1>())).obj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interval__bindgen_ty_1),
            "::",
            stringify!(obj)
        )
    );
}
impl Default for interval__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_interval() {
    assert_eq!(
        ::std::mem::size_of::<interval>(),
        56usize,
        concat!("Size of: ", stringify!(interval))
    );
    assert_eq!(
        ::std::mem::align_of::<interval>(),
        8usize,
        concat!("Alignment of ", stringify!(interval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<interval>())).total_length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(interval),
            "::",
            stringify!(total_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<interval>())).position as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(interval),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<interval>())).left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(interval),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<interval>())).right as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(interval),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<interval>())).up as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(interval),
            "::",
            stringify!(up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<interval>())).plist as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(interval),
            "::",
            stringify!(plist)
        )
    );
}
impl Default for interval {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl interval {
    #[inline]
    pub fn up_obj(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_up_obj(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gcmarkbit(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gcmarkbit(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_protect(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_protect(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn visible(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_visible(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn front_sticky(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_front_sticky(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rear_sticky(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rear_sticky(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        up_obj: bool_bf,
        gcmarkbit: bool_bf,
        write_protect: bool_bf,
        visible: bool_bf,
        front_sticky: bool_bf,
        rear_sticky: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let up_obj: u8 = unsafe { ::std::mem::transmute(up_obj) };
            up_obj as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let gcmarkbit: u8 = unsafe { ::std::mem::transmute(gcmarkbit) };
            gcmarkbit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let write_protect: u8 = unsafe { ::std::mem::transmute(write_protect) };
            write_protect as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let visible: u8 = unsafe { ::std::mem::transmute(visible) };
            visible as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let front_sticky: u8 = unsafe { ::std::mem::transmute(front_sticky) };
            front_sticky as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rear_sticky: u8 = unsafe { ::std::mem::transmute(rear_sticky) };
            rear_sticky as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn set_interval_object(i: INTERVAL, obj: Lisp_Object);
}
extern "C" {
    pub fn set_interval_parent(i: INTERVAL, parent: INTERVAL);
}
extern "C" {
    pub fn set_interval_plist(i: INTERVAL, plist: Lisp_Object);
}
extern "C" {
    pub fn make_interval() -> INTERVAL;
}
extern "C" {
    pub fn create_root_interval(arg1: Lisp_Object) -> INTERVAL;
}
extern "C" {
    pub fn copy_properties(arg1: INTERVAL, arg2: INTERVAL);
}
extern "C" {
    pub fn intervals_equal(arg1: INTERVAL, arg2: INTERVAL) -> bool;
}
extern "C" {
    pub fn traverse_intervals(
        arg1: INTERVAL,
        arg2: isize,
        arg3: ::std::option::Option<unsafe extern "C" fn(arg1: INTERVAL, arg2: Lisp_Object)>,
        arg4: Lisp_Object,
    );
}
extern "C" {
    pub fn traverse_intervals_noorder(
        arg1: INTERVAL,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: INTERVAL, arg2: *mut ::libc::c_void),
        >,
        arg3: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn split_interval_right(arg1: INTERVAL, arg2: isize) -> INTERVAL;
}
extern "C" {
    pub fn split_interval_left(arg1: INTERVAL, arg2: isize) -> INTERVAL;
}
extern "C" {
    pub fn find_interval(arg1: INTERVAL, arg2: isize) -> INTERVAL;
}
extern "C" {
    pub fn next_interval(arg1: INTERVAL) -> INTERVAL;
}
extern "C" {
    pub fn previous_interval(arg1: INTERVAL) -> INTERVAL;
}
extern "C" {
    pub fn merge_interval_left(arg1: INTERVAL) -> INTERVAL;
}
extern "C" {
    pub fn offset_intervals(arg1: *mut buffer, arg2: isize, arg3: isize);
}
extern "C" {
    pub fn graft_intervals_into_buffer(
        arg1: INTERVAL,
        arg2: isize,
        arg3: isize,
        arg4: *mut buffer,
        arg5: bool,
    );
}
extern "C" {
    pub fn verify_interval_modification(arg1: *mut buffer, arg2: isize, arg3: isize);
}
extern "C" {
    pub fn balance_intervals(arg1: INTERVAL) -> INTERVAL;
}
extern "C" {
    pub fn copy_intervals_to_string(arg1: Lisp_Object, arg2: *mut buffer, arg3: isize, arg4: isize);
}
extern "C" {
    pub fn copy_intervals(arg1: INTERVAL, arg2: isize, arg3: isize) -> INTERVAL;
}
extern "C" {
    pub fn compare_string_intervals(arg1: Lisp_Object, arg2: Lisp_Object) -> bool;
}
extern "C" {
    pub fn textget(arg1: Lisp_Object, arg2: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn lookup_char_property(arg1: Lisp_Object, arg2: Lisp_Object, arg3: bool) -> Lisp_Object;
}
extern "C" {
    pub fn move_if_not_intangible(arg1: isize);
}
extern "C" {
    pub fn get_property_and_range(
        arg1: isize,
        arg2: Lisp_Object,
        arg3: *mut Lisp_Object,
        arg4: *mut isize,
        arg5: *mut isize,
        arg6: Lisp_Object,
    ) -> bool;
}
extern "C" {
    pub fn get_local_map(arg1: isize, arg2: *mut buffer, arg3: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn update_interval(arg1: INTERVAL, arg2: isize) -> INTERVAL;
}
extern "C" {
    pub fn set_intervals_multibyte(arg1: bool);
}
extern "C" {
    pub fn validate_interval_range(
        arg1: Lisp_Object,
        arg2: *mut Lisp_Object,
        arg3: *mut Lisp_Object,
        arg4: bool,
    ) -> INTERVAL;
}
extern "C" {
    pub fn interval_of(arg1: isize, arg2: Lisp_Object) -> INTERVAL;
}
extern "C" {
    pub fn invisible_prop(arg1: Lisp_Object, arg2: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    pub fn copy_text_properties(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
        arg6: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn set_text_properties(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn set_text_properties_1(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: INTERVAL,
    );
}
extern "C" {
    pub fn text_property_list(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn add_text_properties_from_list(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object);
}
extern "C" {
    pub fn extend_property_ranges(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn get_char_property_and_overlay(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: *mut Lisp_Object,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn text_property_stickiness(
        prop: Lisp_Object,
        pos: Lisp_Object,
        buffer: Lisp_Object,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn syms_of_textprop();
}
pub type KBOARD = kboard;
#[repr(C)]
pub struct kboard {
    pub next_kboard: *mut KBOARD,
    pub Voverriding_terminal_local_map_: Lisp_Object,
    pub Vlast_command_: Lisp_Object,
    pub Vreal_last_command_: Lisp_Object,
    pub Vkeyboard_translate_table_: Lisp_Object,
    pub Vlast_repeatable_command_: Lisp_Object,
    pub Vprefix_arg_: Lisp_Object,
    pub Vlast_prefix_arg_: Lisp_Object,
    pub kbd_queue_: Lisp_Object,
    pub defining_kbd_macro_: Lisp_Object,
    pub kbd_macro_buffer: *mut Lisp_Object,
    pub kbd_macro_ptr: *mut Lisp_Object,
    pub kbd_macro_end: *mut Lisp_Object,
    pub kbd_macro_bufsize: isize,
    pub Vlast_kbd_macro_: Lisp_Object,
    pub Vsystem_key_alist_: Lisp_Object,
    pub system_key_syms_: Lisp_Object,
    pub Vwindow_system_: Lisp_Object,
    pub Vlocal_function_key_map_: Lisp_Object,
    pub Vinput_decode_map_: Lisp_Object,
    pub Vdefault_minibuffer_frame_: Lisp_Object,
    pub reference_count: ::libc::c_int,
    pub echo_string_: Lisp_Object,
    pub kbd_queue_has_data: bool_bf,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub echo_prompt_: Lisp_Object,
}
#[test]
fn bindgen_test_layout_kboard() {
    assert_eq!(
        ::std::mem::size_of::<kboard>(),
        200usize,
        concat!("Size of: ", stringify!(kboard))
    );
    assert_eq!(
        ::std::mem::align_of::<kboard>(),
        8usize,
        concat!("Alignment of ", stringify!(kboard))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).next_kboard as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(next_kboard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kboard>())).Voverriding_terminal_local_map_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Voverriding_terminal_local_map_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).Vlast_command_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Vlast_command_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).Vreal_last_command_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Vreal_last_command_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kboard>())).Vkeyboard_translate_table_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Vkeyboard_translate_table_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kboard>())).Vlast_repeatable_command_ as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Vlast_repeatable_command_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).Vprefix_arg_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Vprefix_arg_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).Vlast_prefix_arg_ as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Vlast_prefix_arg_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).kbd_queue_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(kbd_queue_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).defining_kbd_macro_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(defining_kbd_macro_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).kbd_macro_buffer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(kbd_macro_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).kbd_macro_ptr as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(kbd_macro_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).kbd_macro_end as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(kbd_macro_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).kbd_macro_bufsize as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(kbd_macro_bufsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).Vlast_kbd_macro_ as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Vlast_kbd_macro_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).Vsystem_key_alist_ as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Vsystem_key_alist_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).system_key_syms_ as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(system_key_syms_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).Vwindow_system_ as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Vwindow_system_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).Vlocal_function_key_map_ as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Vlocal_function_key_map_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).Vinput_decode_map_ as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Vinput_decode_map_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kboard>())).Vdefault_minibuffer_frame_ as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(Vdefault_minibuffer_frame_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).reference_count as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(reference_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).echo_string_ as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(echo_string_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).kbd_queue_has_data as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(kbd_queue_has_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kboard>())).echo_prompt_ as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(kboard),
            "::",
            stringify!(echo_prompt_)
        )
    );
}
impl Default for kboard {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl kboard {
    #[inline]
    pub fn immediate_echo(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_immediate_echo(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(immediate_echo: bool_bf) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let immediate_echo: u8 = unsafe { ::std::mem::transmute(immediate_echo) };
            immediate_echo as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn kset_default_minibuffer_frame(kb: *mut kboard, val: Lisp_Object);
}
extern "C" {
    pub fn kset_defining_kbd_macro(kb: *mut kboard, val: Lisp_Object);
}
extern "C" {
    pub fn kset_input_decode_map(kb: *mut kboard, val: Lisp_Object);
}
extern "C" {
    pub fn kset_last_command(kb: *mut kboard, val: Lisp_Object);
}
extern "C" {
    pub fn kset_last_kbd_macro(kb: *mut kboard, val: Lisp_Object);
}
extern "C" {
    pub fn kset_prefix_arg(kb: *mut kboard, val: Lisp_Object);
}
extern "C" {
    pub fn kset_system_key_alist(kb: *mut kboard, val: Lisp_Object);
}
extern "C" {
    pub fn kset_window_system(kb: *mut kboard, val: Lisp_Object);
}
#[repr(C)]
#[repr(align(8))]
pub struct buffered_input_event {
    pub _bitfield_1: __BindgenUnionField<__BindgenBitfieldUnit<[u8; 2usize], u16>>,
    pub ie: __BindgenUnionField<input_event>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_buffered_input_event() {
    assert_eq!(
        ::std::mem::size_of::<buffered_input_event>(),
        56usize,
        concat!("Size of: ", stringify!(buffered_input_event))
    );
    assert_eq!(
        ::std::mem::align_of::<buffered_input_event>(),
        8usize,
        concat!("Alignment of ", stringify!(buffered_input_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<buffered_input_event>())).ie as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(buffered_input_event),
            "::",
            stringify!(ie)
        )
    );
}
impl Default for buffered_input_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl buffered_input_event {
    #[inline]
    pub fn kind(&self) -> event_kind::Type {
        unsafe { ::std::mem::transmute(self._bitfield_1.as_ref().get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_kind(&mut self, val: event_kind::Type) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.as_mut().set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(kind: event_kind::Type) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let kind: u32 = unsafe { ::std::mem::transmute(kind) };
            kind as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}initial_kboard"]
    pub static mut initial_kboard: *mut KBOARD;
}
extern "C" {
    #[link_name = "\u{1}current_kboard"]
    pub static mut current_kboard: *mut KBOARD;
}
extern "C" {
    #[link_name = "\u{1}num_input_events"]
    pub static mut num_input_events: uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}point_before_last_command_or_undo"]
    pub static mut point_before_last_command_or_undo: isize;
}
extern "C" {
    #[link_name = "\u{1}buffer_before_last_command_or_undo"]
    pub static mut buffer_before_last_command_or_undo: *mut buffer;
}
extern "C" {
    #[link_name = "\u{1}prev_buffer"]
    pub static mut prev_buffer: *mut buffer;
}
extern "C" {
    #[link_name = "\u{1}poll_suppress_count"]
    pub static mut poll_suppress_count: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}this_command_keys"]
    pub static mut this_command_keys: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}this_command_key_count"]
    pub static mut this_command_key_count: isize;
}
extern "C" {
    #[link_name = "\u{1}internal_last_event_frame"]
    pub static mut internal_last_event_frame: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}item_properties"]
    pub static mut item_properties: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}menu_items"]
    pub static mut menu_items: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}menu_items_inuse"]
    pub static mut menu_items_inuse: bool;
}
extern "C" {
    #[link_name = "\u{1}menu_items_allocated"]
    pub static mut menu_items_allocated: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}menu_items_used"]
    pub static mut menu_items_used: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}menu_items_n_panes"]
    pub static mut menu_items_n_panes: ::libc::c_int;
}
pub mod menu_item_idx {
    pub type Type = u32;
    pub const MENU_ITEMS_ITEM_NAME: Type = 0;
    pub const MENU_ITEMS_ITEM_ENABLE: Type = 1;
    pub const MENU_ITEMS_ITEM_VALUE: Type = 2;
    pub const MENU_ITEMS_ITEM_EQUIV_KEY: Type = 3;
    pub const MENU_ITEMS_ITEM_DEFINITION: Type = 4;
    pub const MENU_ITEMS_ITEM_TYPE: Type = 5;
    pub const MENU_ITEMS_ITEM_SELECTED: Type = 6;
    pub const MENU_ITEMS_ITEM_HELP: Type = 7;
    pub const MENU_ITEMS_ITEM_LENGTH: Type = 8;
}
extern "C" {
    pub fn unuse_menu_items();
}
extern "C" {
    #[link_name = "\u{1}input_available_clear_time"]
    pub static mut input_available_clear_time: *mut timespec;
}
extern "C" {
    #[link_name = "\u{1}ignore_mouse_drag_p"]
    pub static mut ignore_mouse_drag_p: bool;
}
extern "C" {
    pub fn parse_modifiers(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn reorder_modifiers(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn read_char(
        arg1: ::libc::c_int,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: *mut bool,
        arg5: *mut timespec,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn parse_solitary_modifier(symbol: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}real_this_command"]
    pub static mut real_this_command: Lisp_Object;
}
extern "C" {
    #[link_name = "\u{1}quit_char"]
    pub static mut quit_char: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}input_was_pending"]
    pub static mut input_was_pending: bool;
}
extern "C" {
    #[link_name = "\u{1}timers_run"]
    pub static mut timers_run: ::libc::c_uint;
}
extern "C" {
    pub fn menu_separator_name_p(arg1: *const ::libc::c_char) -> bool;
}
extern "C" {
    pub fn parse_menu_item(arg1: Lisp_Object, arg2: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn init_raw_keybuf_count();
}
extern "C" {
    pub fn allocate_kboard(arg1: Lisp_Object) -> *mut KBOARD;
}
extern "C" {
    pub fn delete_kboard(arg1: *mut KBOARD);
}
extern "C" {
    pub fn not_single_kboard_state(arg1: *mut KBOARD);
}
extern "C" {
    pub fn push_kboard(arg1: *mut kboard);
}
extern "C" {
    pub fn push_frame_kboard(arg1: *mut frame);
}
extern "C" {
    pub fn pop_kboard();
}
extern "C" {
    pub fn temporarily_switch_to_single_kboard(arg1: *mut frame);
}
extern "C" {
    pub fn input_poll_signal(arg1: ::libc::c_int);
}
extern "C" {
    pub fn start_polling();
}
extern "C" {
    pub fn stop_polling();
}
extern "C" {
    pub fn set_poll_suppress_count(arg1: ::libc::c_int);
}
extern "C" {
    pub fn gobble_input() -> ::libc::c_int;
}
extern "C" {
    pub fn input_polling_used() -> bool;
}
extern "C" {
    pub fn clear_input_pending();
}
extern "C" {
    pub fn requeued_events_pending_p() -> bool;
}
extern "C" {
    pub fn bind_polling_period(arg1: ::libc::c_int);
}
extern "C" {
    pub fn make_ctrl_char(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn stuff_buffered_input(arg1: Lisp_Object);
}
extern "C" {
    pub fn clear_waiting_for_input();
}
extern "C" {
    pub fn swallow_events(arg1: bool);
}
extern "C" {
    pub fn lucid_event_type_list_p(arg1: Lisp_Object) -> bool;
}
extern "C" {
    pub fn kbd_buffer_store_event(arg1: *mut input_event);
}
extern "C" {
    pub fn kbd_buffer_store_buffered_event(arg1: *mut buffered_input_event, arg2: *mut input_event);
}
extern "C" {
    pub fn kbd_buffer_store_event_hold(event: *mut input_event, hold_quit: *mut input_event);
}
extern "C" {
    pub fn poll_for_input_1();
}
extern "C" {
    pub fn show_help_echo(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
    );
}
extern "C" {
    pub fn gen_help_event(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: Lisp_Object,
        arg4: Lisp_Object,
        arg5: isize,
    );
}
extern "C" {
    pub fn kbd_buffer_store_help_event(arg1: Lisp_Object, arg2: Lisp_Object);
}
extern "C" {
    pub fn menu_item_eval_property(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn kbd_buffer_events_waiting() -> bool;
}
extern "C" {
    pub fn add_user_signal(arg1: ::libc::c_int, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn tty_read_avail_input(arg1: *mut terminal, arg2: *mut input_event) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}pending_signals"]
    pub static mut pending_signals: bool;
}
extern "C" {
    pub fn process_pending_signals();
}
extern "C" {
    pub fn timer_check() -> timespec;
}
extern "C" {
    pub fn mark_kboards();
}
extern "C" {
    #[link_name = "\u{1}DEV_TTY"]
    pub static mut DEV_TTY: [::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}current_global_map"]
    pub static mut current_global_map: Lisp_Object;
}
extern "C" {
    pub fn push_key_description(arg1: EMACS_INT, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn access_keymap(
        arg1: Lisp_Object,
        arg2: Lisp_Object,
        arg3: bool,
        arg4: bool,
        arg5: bool,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn get_keymap(arg1: Lisp_Object, arg2: bool, arg3: bool) -> Lisp_Object;
}
extern "C" {
    pub fn current_minor_maps(arg1: *mut *mut Lisp_Object, arg2: *mut *mut Lisp_Object) -> isize;
}
extern "C" {
    pub fn initial_define_lispy_key(
        arg1: Lisp_Object,
        arg2: *const ::libc::c_char,
        arg3: *const ::libc::c_char,
    );
}
extern "C" {
    pub fn syms_of_keymap();
}
pub type map_keymap_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        key: Lisp_Object,
        val: Lisp_Object,
        args: Lisp_Object,
        data: *mut ::libc::c_void,
    ),
>;
extern "C" {
    pub fn map_keymap(
        arg1: Lisp_Object,
        arg2: map_keymap_function_t,
        arg3: Lisp_Object,
        arg4: *mut ::libc::c_void,
        arg5: bool,
    );
}
extern "C" {
    pub fn map_keymap_canonical(
        map: Lisp_Object,
        fun: map_keymap_function_t,
        args: Lisp_Object,
        data: *mut ::libc::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}executing_kbd_macro_iterations"]
    pub static mut executing_kbd_macro_iterations: EMACS_INT;
}
extern "C" {
    #[link_name = "\u{1}executing_kbd_macro"]
    pub static mut executing_kbd_macro: Lisp_Object;
}
extern "C" {
    pub fn end_kbd_macro();
}
extern "C" {
    pub fn finalize_kbd_macro_chars();
}
extern "C" {
    pub fn store_kbd_macro_char(arg1: Lisp_Object);
}
extern "C" {
    #[link_name = "\u{1}mac_uvs_table_adobe_japan1_bytes"]
    pub static mut mac_uvs_table_adobe_japan1_bytes: [::libc::c_uchar; 73650usize];
}
pub mod change_type {
    pub type Type = u32;
    pub const NO_CHANGE: Type = 0;
    pub const INVISIBLE_CHANGE: Type = 1;
    pub const VISIBLE_CHANGE: Type = 2;
    pub const STRUCTURAL_CHANGE: Type = 3;
}
pub mod button_type {
    pub type Type = u32;
    pub const BUTTON_TYPE_NONE: Type = 0;
    pub const BUTTON_TYPE_TOGGLE: Type = 1;
    pub const BUTTON_TYPE_RADIO: Type = 2;
}
#[repr(C)]
pub struct _widget_value {
    pub lname: Lisp_Object,
    pub name: *mut ::libc::c_char,
    pub value: *mut ::libc::c_char,
    pub lkey: Lisp_Object,
    pub key: *mut ::libc::c_char,
    pub help: Lisp_Object,
    pub enabled: bool,
    pub selected: bool,
    pub edited: bool,
    pub button_type: button_type::Type,
    pub contents: *mut _widget_value,
    pub call_data: *mut ::libc::c_void,
    pub next: *mut _widget_value,
}
#[test]
fn bindgen_test_layout__widget_value() {
    assert_eq!(
        ::std::mem::size_of::<_widget_value>(),
        80usize,
        concat!("Size of: ", stringify!(_widget_value))
    );
    assert_eq!(
        ::std::mem::align_of::<_widget_value>(),
        8usize,
        concat!("Alignment of ", stringify!(_widget_value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).lname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(lname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).lkey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(lkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).key as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).help as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(help)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).enabled as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).selected as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(selected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).edited as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(edited)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).button_type as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(button_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).contents as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).call_data as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(call_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_widget_value>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget_value),
            "::",
            stringify!(next)
        )
    );
}
impl Default for _widget_value {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type widget_value = _widget_value;
pub mod _bindgen_ty_53 {
    pub type Type = u32;
    pub const MENU_KEYMAPS: Type = 1;
    pub const MENU_FOR_CLICK: Type = 2;
    pub const MENU_KBD_NAVIGATION: Type = 4;
}
extern "C" {
    pub fn init_menu_items();
}
extern "C" {
    pub fn finish_menu_items();
}
extern "C" {
    pub fn discard_menu_items();
}
extern "C" {
    pub fn save_menu_items();
}
extern "C" {
    pub fn parse_single_submenu(arg1: Lisp_Object, arg2: Lisp_Object, arg3: Lisp_Object) -> bool;
}
extern "C" {
    pub fn list_of_panes(arg1: Lisp_Object);
}
extern "C" {
    pub fn tty_menu_show(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: ::libc::c_int,
        arg5: Lisp_Object,
        arg6: *mut *const ::libc::c_char,
    ) -> Lisp_Object;
}
extern "C" {
    pub fn menu_item_width(arg1: *const ::libc::c_uchar) -> isize;
}
extern "C" {
    pub fn x_popup_menu_1(position: Lisp_Object, menu: Lisp_Object) -> Lisp_Object;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flock {
    pub l_type: ::libc::c_short,
    pub l_whence: ::libc::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        32usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_whence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_pid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flock64 {
    pub l_type: ::libc::c_short,
    pub l_whence: ::libc::c_short,
    pub l_start: __off64_t,
    pub l_len: __off64_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock64() {
    assert_eq!(
        ::std::mem::size_of::<flock64>(),
        32usize,
        concat!("Size of: ", stringify!(flock64))
    );
    assert_eq!(
        ::std::mem::align_of::<flock64>(),
        8usize,
        concat!("Alignment of ", stringify!(flock64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_whence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_pid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_pid)
        )
    );
}
pub mod __pid_type {
    pub type Type = u32;
    pub const F_OWNER_TID: Type = 0;
    pub const F_OWNER_PID: Type = 1;
    pub const F_OWNER_PGRP: Type = 2;
    pub const F_OWNER_GID: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct f_owner_ex {
    pub type_: __pid_type::Type,
    pub pid: __pid_t,
}
#[test]
fn bindgen_test_layout_f_owner_ex() {
    assert_eq!(
        ::std::mem::size_of::<f_owner_ex>(),
        8usize,
        concat!("Size of: ", stringify!(f_owner_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<f_owner_ex>(),
        4usize,
        concat!("Alignment of ", stringify!(f_owner_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<f_owner_ex>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(f_owner_ex),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<f_owner_ex>())).pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(f_owner_ex),
            "::",
            stringify!(pid)
        )
    );
}
impl Default for f_owner_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct file_handle {
    pub handle_bytes: ::libc::c_uint,
    pub handle_type: ::libc::c_int,
    pub f_handle: __IncompleteArrayField<::libc::c_uchar>,
}
#[test]
fn bindgen_test_layout_file_handle() {
    assert_eq!(
        ::std::mem::size_of::<file_handle>(),
        8usize,
        concat!("Size of: ", stringify!(file_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<file_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(file_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_handle>())).handle_bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_handle),
            "::",
            stringify!(handle_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_handle>())).handle_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(file_handle),
            "::",
            stringify!(handle_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_handle>())).f_handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_handle),
            "::",
            stringify!(f_handle)
        )
    );
}
extern "C" {
    pub fn readahead(__fd: ::libc::c_int, __offset: __off64_t, __count: usize) -> __ssize_t;
}
extern "C" {
    pub fn sync_file_range(
        __fd: ::libc::c_int,
        __offset: __off64_t,
        __count: __off64_t,
        __flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vmsplice(
        __fdout: ::libc::c_int,
        __iov: *const iovec,
        __count: usize,
        __flags: ::libc::c_uint,
    ) -> __ssize_t;
}
extern "C" {
    pub fn splice(
        __fdin: ::libc::c_int,
        __offin: *mut __off64_t,
        __fdout: ::libc::c_int,
        __offout: *mut __off64_t,
        __len: usize,
        __flags: ::libc::c_uint,
    ) -> __ssize_t;
}
extern "C" {
    pub fn tee(
        __fdin: ::libc::c_int,
        __fdout: ::libc::c_int,
        __len: usize,
        __flags: ::libc::c_uint,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fallocate(
        __fd: ::libc::c_int,
        __mode: ::libc::c_int,
        __offset: __off_t,
        __len: __off_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fallocate64(
        __fd: ::libc::c_int,
        __mode: ::libc::c_int,
        __offset: __off64_t,
        __len: __off64_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn name_to_handle_at(
        __dfd: ::libc::c_int,
        __name: *const ::libc::c_char,
        __handle: *mut file_handle,
        __mnt_id: *mut ::libc::c_int,
        __flags: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn open_by_handle_at(
        __mountdirfd: ::libc::c_int,
        __handle: *mut file_handle,
        __flags: ::libc::c_int,
    ) -> ::libc::c_int;
}
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__pad0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atim as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtim as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctim as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__glibc_reserved as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
impl Default for stat {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct stat64 {
    pub st_dev: __dev_t,
    pub st_ino: __ino64_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt64_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat64() {
    assert_eq!(
        ::std::mem::size_of::<stat64>(),
        144usize,
        concat!("Size of: ", stringify!(stat64))
    );
    assert_eq!(
        ::std::mem::align_of::<stat64>(),
        8usize,
        concat!("Alignment of ", stringify!(stat64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_uid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).__pad0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_atim as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_mtim as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).st_ctim as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat64>())).__glibc_reserved as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
impl Default for stat64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn fcntl(__fd: ::libc::c_int, __cmd: ::libc::c_int, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn fcntl64(__fd: ::libc::c_int, __cmd: ::libc::c_int, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn open(__file: *const ::libc::c_char, __oflag: ::libc::c_int, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn open64(__file: *const ::libc::c_char, __oflag: ::libc::c_int, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn openat(
        __fd: ::libc::c_int,
        __file: *const ::libc::c_char,
        __oflag: ::libc::c_int,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn openat64(
        __fd: ::libc::c_int,
        __file: *const ::libc::c_char,
        __oflag: ::libc::c_int,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn creat(__file: *const ::libc::c_char, __mode: mode_t) -> ::libc::c_int;
}
extern "C" {
    pub fn creat64(__file: *const ::libc::c_char, __mode: mode_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lockf(__fd: ::libc::c_int, __cmd: ::libc::c_int, __len: off_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lockf64(__fd: ::libc::c_int, __cmd: ::libc::c_int, __len: off64_t) -> ::libc::c_int;
}
extern "C" {
    pub fn posix_fadvise(
        __fd: ::libc::c_int,
        __offset: off_t,
        __len: off_t,
        __advise: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn posix_fadvise64(
        __fd: ::libc::c_int,
        __offset: off64_t,
        __len: off64_t,
        __advise: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn posix_fallocate(__fd: ::libc::c_int, __offset: off_t, __len: off_t) -> ::libc::c_int;
}
extern "C" {
    pub fn posix_fallocate64(
        __fd: ::libc::c_int,
        __offset: off64_t,
        __len: off64_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn rpl_fcntl(fd: ::libc::c_int, action: ::libc::c_int, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn emacs_fopen(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn errputc(arg1: ::libc::c_int);
}
extern "C" {
    pub fn errwrite(arg1: *const ::libc::c_void, arg2: isize);
}
extern "C" {
    pub fn close_output_streams();
}
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(__name: *const ::libc::c_char, __type: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn euidaccess(__name: *const ::libc::c_char, __type: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn eaccess(__name: *const ::libc::c_char, __type: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::libc::c_int,
        __file: *const ::libc::c_char,
        __type: ::libc::c_int,
        __flag: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn lseek(__fd: ::libc::c_int, __offset: __off_t, __whence: ::libc::c_int) -> __off_t;
}
extern "C" {
    pub fn lseek64(__fd: ::libc::c_int, __offset: __off64_t, __whence: ::libc::c_int) -> __off64_t;
}
extern "C" {
    pub fn close(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn read(__fd: ::libc::c_int, __buf: *mut ::libc::c_void, __nbytes: usize) -> isize;
}
extern "C" {
    pub fn write(__fd: ::libc::c_int, __buf: *const ::libc::c_void, __n: usize) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: ::libc::c_int,
        __buf: *mut ::libc::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::libc::c_int,
        __buf: *const ::libc::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pread64(
        __fd: ::libc::c_int,
        __buf: *mut ::libc::c_void,
        __nbytes: usize,
        __offset: __off64_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite64(
        __fd: ::libc::c_int,
        __buf: *const ::libc::c_void,
        __n: usize,
        __offset: __off64_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn pipe2(__pipedes: *mut ::libc::c_int, __flags: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::libc::c_uint) -> ::libc::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::libc::c_uint) -> ::libc::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pause() -> ::libc::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::libc::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fchown(__fd: ::libc::c_int, __owner: __uid_t, __group: __gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::libc::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::libc::c_int,
        __file: *const ::libc::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::libc::c_char, __size: usize) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn get_current_dir_name() -> *mut ::libc::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn dup(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::libc::c_int, __fd2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn dup3(__fd: ::libc::c_int, __fd2: ::libc::c_int, __flags: ::libc::c_int)
        -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__environ"]
    pub static mut __environ: *mut *mut ::libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}environ"]
    pub static mut environ: *mut *mut ::libc::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::libc::c_char,
        __argv: *const *mut ::libc::c_char,
        __envp: *const *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::libc::c_int,
        __argv: *const *mut ::libc::c_char,
        __envp: *const *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::libc::c_char,
        __argv: *const *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::libc::c_char,
        __arg: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn execl(__path: *const ::libc::c_char, __arg: *const ::libc::c_char, ...)
        -> ::libc::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::libc::c_char,
        __argv: *const *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::libc::c_char,
        __arg: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn execvpe(
        __file: *const ::libc::c_char,
        __argv: *const *mut ::libc::c_char,
        __envp: *const *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn nice(__inc: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn _exit(__status: ::libc::c_int);
}
pub mod _bindgen_ty_54 {
    pub type Type = u32;
    pub const _PC_LINK_MAX: Type = 0;
    pub const _PC_MAX_CANON: Type = 1;
    pub const _PC_MAX_INPUT: Type = 2;
    pub const _PC_NAME_MAX: Type = 3;
    pub const _PC_PATH_MAX: Type = 4;
    pub const _PC_PIPE_BUF: Type = 5;
    pub const _PC_CHOWN_RESTRICTED: Type = 6;
    pub const _PC_NO_TRUNC: Type = 7;
    pub const _PC_VDISABLE: Type = 8;
    pub const _PC_SYNC_IO: Type = 9;
    pub const _PC_ASYNC_IO: Type = 10;
    pub const _PC_PRIO_IO: Type = 11;
    pub const _PC_SOCK_MAXBUF: Type = 12;
    pub const _PC_FILESIZEBITS: Type = 13;
    pub const _PC_REC_INCR_XFER_SIZE: Type = 14;
    pub const _PC_REC_MAX_XFER_SIZE: Type = 15;
    pub const _PC_REC_MIN_XFER_SIZE: Type = 16;
    pub const _PC_REC_XFER_ALIGN: Type = 17;
    pub const _PC_ALLOC_SIZE_MIN: Type = 18;
    pub const _PC_SYMLINK_MAX: Type = 19;
    pub const _PC_2_SYMLINKS: Type = 20;
}
pub mod _bindgen_ty_55 {
    pub type Type = u32;
    pub const _SC_ARG_MAX: Type = 0;
    pub const _SC_CHILD_MAX: Type = 1;
    pub const _SC_CLK_TCK: Type = 2;
    pub const _SC_NGROUPS_MAX: Type = 3;
    pub const _SC_OPEN_MAX: Type = 4;
    pub const _SC_STREAM_MAX: Type = 5;
    pub const _SC_TZNAME_MAX: Type = 6;
    pub const _SC_JOB_CONTROL: Type = 7;
    pub const _SC_SAVED_IDS: Type = 8;
    pub const _SC_REALTIME_SIGNALS: Type = 9;
    pub const _SC_PRIORITY_SCHEDULING: Type = 10;
    pub const _SC_TIMERS: Type = 11;
    pub const _SC_ASYNCHRONOUS_IO: Type = 12;
    pub const _SC_PRIORITIZED_IO: Type = 13;
    pub const _SC_SYNCHRONIZED_IO: Type = 14;
    pub const _SC_FSYNC: Type = 15;
    pub const _SC_MAPPED_FILES: Type = 16;
    pub const _SC_MEMLOCK: Type = 17;
    pub const _SC_MEMLOCK_RANGE: Type = 18;
    pub const _SC_MEMORY_PROTECTION: Type = 19;
    pub const _SC_MESSAGE_PASSING: Type = 20;
    pub const _SC_SEMAPHORES: Type = 21;
    pub const _SC_SHARED_MEMORY_OBJECTS: Type = 22;
    pub const _SC_AIO_LISTIO_MAX: Type = 23;
    pub const _SC_AIO_MAX: Type = 24;
    pub const _SC_AIO_PRIO_DELTA_MAX: Type = 25;
    pub const _SC_DELAYTIMER_MAX: Type = 26;
    pub const _SC_MQ_OPEN_MAX: Type = 27;
    pub const _SC_MQ_PRIO_MAX: Type = 28;
    pub const _SC_VERSION: Type = 29;
    pub const _SC_PAGESIZE: Type = 30;
    pub const _SC_RTSIG_MAX: Type = 31;
    pub const _SC_SEM_NSEMS_MAX: Type = 32;
    pub const _SC_SEM_VALUE_MAX: Type = 33;
    pub const _SC_SIGQUEUE_MAX: Type = 34;
    pub const _SC_TIMER_MAX: Type = 35;
    pub const _SC_BC_BASE_MAX: Type = 36;
    pub const _SC_BC_DIM_MAX: Type = 37;
    pub const _SC_BC_SCALE_MAX: Type = 38;
    pub const _SC_BC_STRING_MAX: Type = 39;
    pub const _SC_COLL_WEIGHTS_MAX: Type = 40;
    pub const _SC_EQUIV_CLASS_MAX: Type = 41;
    pub const _SC_EXPR_NEST_MAX: Type = 42;
    pub const _SC_LINE_MAX: Type = 43;
    pub const _SC_RE_DUP_MAX: Type = 44;
    pub const _SC_CHARCLASS_NAME_MAX: Type = 45;
    pub const _SC_2_VERSION: Type = 46;
    pub const _SC_2_C_BIND: Type = 47;
    pub const _SC_2_C_DEV: Type = 48;
    pub const _SC_2_FORT_DEV: Type = 49;
    pub const _SC_2_FORT_RUN: Type = 50;
    pub const _SC_2_SW_DEV: Type = 51;
    pub const _SC_2_LOCALEDEF: Type = 52;
    pub const _SC_PII: Type = 53;
    pub const _SC_PII_XTI: Type = 54;
    pub const _SC_PII_SOCKET: Type = 55;
    pub const _SC_PII_INTERNET: Type = 56;
    pub const _SC_PII_OSI: Type = 57;
    pub const _SC_POLL: Type = 58;
    pub const _SC_SELECT: Type = 59;
    pub const _SC_UIO_MAXIOV: Type = 60;
    pub const _SC_IOV_MAX: Type = 60;
    pub const _SC_PII_INTERNET_STREAM: Type = 61;
    pub const _SC_PII_INTERNET_DGRAM: Type = 62;
    pub const _SC_PII_OSI_COTS: Type = 63;
    pub const _SC_PII_OSI_CLTS: Type = 64;
    pub const _SC_PII_OSI_M: Type = 65;
    pub const _SC_T_IOV_MAX: Type = 66;
    pub const _SC_THREADS: Type = 67;
    pub const _SC_THREAD_SAFE_FUNCTIONS: Type = 68;
    pub const _SC_GETGR_R_SIZE_MAX: Type = 69;
    pub const _SC_GETPW_R_SIZE_MAX: Type = 70;
    pub const _SC_LOGIN_NAME_MAX: Type = 71;
    pub const _SC_TTY_NAME_MAX: Type = 72;
    pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: Type = 73;
    pub const _SC_THREAD_KEYS_MAX: Type = 74;
    pub const _SC_THREAD_STACK_MIN: Type = 75;
    pub const _SC_THREAD_THREADS_MAX: Type = 76;
    pub const _SC_THREAD_ATTR_STACKADDR: Type = 77;
    pub const _SC_THREAD_ATTR_STACKSIZE: Type = 78;
    pub const _SC_THREAD_PRIORITY_SCHEDULING: Type = 79;
    pub const _SC_THREAD_PRIO_INHERIT: Type = 80;
    pub const _SC_THREAD_PRIO_PROTECT: Type = 81;
    pub const _SC_THREAD_PROCESS_SHARED: Type = 82;
    pub const _SC_NPROCESSORS_CONF: Type = 83;
    pub const _SC_NPROCESSORS_ONLN: Type = 84;
    pub const _SC_PHYS_PAGES: Type = 85;
    pub const _SC_AVPHYS_PAGES: Type = 86;
    pub const _SC_ATEXIT_MAX: Type = 87;
    pub const _SC_PASS_MAX: Type = 88;
    pub const _SC_XOPEN_VERSION: Type = 89;
    pub const _SC_XOPEN_XCU_VERSION: Type = 90;
    pub const _SC_XOPEN_UNIX: Type = 91;
    pub const _SC_XOPEN_CRYPT: Type = 92;
    pub const _SC_XOPEN_ENH_I18N: Type = 93;
    pub const _SC_XOPEN_SHM: Type = 94;
    pub const _SC_2_CHAR_TERM: Type = 95;
    pub const _SC_2_C_VERSION: Type = 96;
    pub const _SC_2_UPE: Type = 97;
    pub const _SC_XOPEN_XPG2: Type = 98;
    pub const _SC_XOPEN_XPG3: Type = 99;
    pub const _SC_XOPEN_XPG4: Type = 100;
    pub const _SC_CHAR_BIT: Type = 101;
    pub const _SC_CHAR_MAX: Type = 102;
    pub const _SC_CHAR_MIN: Type = 103;
    pub const _SC_INT_MAX: Type = 104;
    pub const _SC_INT_MIN: Type = 105;
    pub const _SC_LONG_BIT: Type = 106;
    pub const _SC_WORD_BIT: Type = 107;
    pub const _SC_MB_LEN_MAX: Type = 108;
    pub const _SC_NZERO: Type = 109;
    pub const _SC_SSIZE_MAX: Type = 110;
    pub const _SC_SCHAR_MAX: Type = 111;
    pub const _SC_SCHAR_MIN: Type = 112;
    pub const _SC_SHRT_MAX: Type = 113;
    pub const _SC_SHRT_MIN: Type = 114;
    pub const _SC_UCHAR_MAX: Type = 115;
    pub const _SC_UINT_MAX: Type = 116;
    pub const _SC_ULONG_MAX: Type = 117;
    pub const _SC_USHRT_MAX: Type = 118;
    pub const _SC_NL_ARGMAX: Type = 119;
    pub const _SC_NL_LANGMAX: Type = 120;
    pub const _SC_NL_MSGMAX: Type = 121;
    pub const _SC_NL_NMAX: Type = 122;
    pub const _SC_NL_SETMAX: Type = 123;
    pub const _SC_NL_TEXTMAX: Type = 124;
    pub const _SC_XBS5_ILP32_OFF32: Type = 125;
    pub const _SC_XBS5_ILP32_OFFBIG: Type = 126;
    pub const _SC_XBS5_LP64_OFF64: Type = 127;
    pub const _SC_XBS5_LPBIG_OFFBIG: Type = 128;
    pub const _SC_XOPEN_LEGACY: Type = 129;
    pub const _SC_XOPEN_REALTIME: Type = 130;
    pub const _SC_XOPEN_REALTIME_THREADS: Type = 131;
    pub const _SC_ADVISORY_INFO: Type = 132;
    pub const _SC_BARRIERS: Type = 133;
    pub const _SC_BASE: Type = 134;
    pub const _SC_C_LANG_SUPPORT: Type = 135;
    pub const _SC_C_LANG_SUPPORT_R: Type = 136;
    pub const _SC_CLOCK_SELECTION: Type = 137;
    pub const _SC_CPUTIME: Type = 138;
    pub const _SC_THREAD_CPUTIME: Type = 139;
    pub const _SC_DEVICE_IO: Type = 140;
    pub const _SC_DEVICE_SPECIFIC: Type = 141;
    pub const _SC_DEVICE_SPECIFIC_R: Type = 142;
    pub const _SC_FD_MGMT: Type = 143;
    pub const _SC_FIFO: Type = 144;
    pub const _SC_PIPE: Type = 145;
    pub const _SC_FILE_ATTRIBUTES: Type = 146;
    pub const _SC_FILE_LOCKING: Type = 147;
    pub const _SC_FILE_SYSTEM: Type = 148;
    pub const _SC_MONOTONIC_CLOCK: Type = 149;
    pub const _SC_MULTI_PROCESS: Type = 150;
    pub const _SC_SINGLE_PROCESS: Type = 151;
    pub const _SC_NETWORKING: Type = 152;
    pub const _SC_READER_WRITER_LOCKS: Type = 153;
    pub const _SC_SPIN_LOCKS: Type = 154;
    pub const _SC_REGEXP: Type = 155;
    pub const _SC_REGEX_VERSION: Type = 156;
    pub const _SC_SHELL: Type = 157;
    pub const _SC_SIGNALS: Type = 158;
    pub const _SC_SPAWN: Type = 159;
    pub const _SC_SPORADIC_SERVER: Type = 160;
    pub const _SC_THREAD_SPORADIC_SERVER: Type = 161;
    pub const _SC_SYSTEM_DATABASE: Type = 162;
    pub const _SC_SYSTEM_DATABASE_R: Type = 163;
    pub const _SC_TIMEOUTS: Type = 164;
    pub const _SC_TYPED_MEMORY_OBJECTS: Type = 165;
    pub const _SC_USER_GROUPS: Type = 166;
    pub const _SC_USER_GROUPS_R: Type = 167;
    pub const _SC_2_PBS: Type = 168;
    pub const _SC_2_PBS_ACCOUNTING: Type = 169;
    pub const _SC_2_PBS_LOCATE: Type = 170;
    pub const _SC_2_PBS_MESSAGE: Type = 171;
    pub const _SC_2_PBS_TRACK: Type = 172;
    pub const _SC_SYMLOOP_MAX: Type = 173;
    pub const _SC_STREAMS: Type = 174;
    pub const _SC_2_PBS_CHECKPOINT: Type = 175;
    pub const _SC_V6_ILP32_OFF32: Type = 176;
    pub const _SC_V6_ILP32_OFFBIG: Type = 177;
    pub const _SC_V6_LP64_OFF64: Type = 178;
    pub const _SC_V6_LPBIG_OFFBIG: Type = 179;
    pub const _SC_HOST_NAME_MAX: Type = 180;
    pub const _SC_TRACE: Type = 181;
    pub const _SC_TRACE_EVENT_FILTER: Type = 182;
    pub const _SC_TRACE_INHERIT: Type = 183;
    pub const _SC_TRACE_LOG: Type = 184;
    pub const _SC_LEVEL1_ICACHE_SIZE: Type = 185;
    pub const _SC_LEVEL1_ICACHE_ASSOC: Type = 186;
    pub const _SC_LEVEL1_ICACHE_LINESIZE: Type = 187;
    pub const _SC_LEVEL1_DCACHE_SIZE: Type = 188;
    pub const _SC_LEVEL1_DCACHE_ASSOC: Type = 189;
    pub const _SC_LEVEL1_DCACHE_LINESIZE: Type = 190;
    pub const _SC_LEVEL2_CACHE_SIZE: Type = 191;
    pub const _SC_LEVEL2_CACHE_ASSOC: Type = 192;
    pub const _SC_LEVEL2_CACHE_LINESIZE: Type = 193;
    pub const _SC_LEVEL3_CACHE_SIZE: Type = 194;
    pub const _SC_LEVEL3_CACHE_ASSOC: Type = 195;
    pub const _SC_LEVEL3_CACHE_LINESIZE: Type = 196;
    pub const _SC_LEVEL4_CACHE_SIZE: Type = 197;
    pub const _SC_LEVEL4_CACHE_ASSOC: Type = 198;
    pub const _SC_LEVEL4_CACHE_LINESIZE: Type = 199;
    pub const _SC_IPV6: Type = 235;
    pub const _SC_RAW_SOCKETS: Type = 236;
    pub const _SC_V7_ILP32_OFF32: Type = 237;
    pub const _SC_V7_ILP32_OFFBIG: Type = 238;
    pub const _SC_V7_LP64_OFF64: Type = 239;
    pub const _SC_V7_LPBIG_OFFBIG: Type = 240;
    pub const _SC_SS_REPL_MAX: Type = 241;
    pub const _SC_TRACE_EVENT_NAME_MAX: Type = 242;
    pub const _SC_TRACE_NAME_MAX: Type = 243;
    pub const _SC_TRACE_SYS_MAX: Type = 244;
    pub const _SC_TRACE_USER_EVENT_MAX: Type = 245;
    pub const _SC_XOPEN_STREAMS: Type = 246;
    pub const _SC_THREAD_ROBUST_PRIO_INHERIT: Type = 247;
    pub const _SC_THREAD_ROBUST_PRIO_PROTECT: Type = 248;
}
pub mod _bindgen_ty_56 {
    pub type Type = u32;
    pub const _CS_PATH: Type = 0;
    pub const _CS_V6_WIDTH_RESTRICTED_ENVS: Type = 1;
    pub const _CS_GNU_LIBC_VERSION: Type = 2;
    pub const _CS_GNU_LIBPTHREAD_VERSION: Type = 3;
    pub const _CS_V5_WIDTH_RESTRICTED_ENVS: Type = 4;
    pub const _CS_V7_WIDTH_RESTRICTED_ENVS: Type = 5;
    pub const _CS_LFS_CFLAGS: Type = 1000;
    pub const _CS_LFS_LDFLAGS: Type = 1001;
    pub const _CS_LFS_LIBS: Type = 1002;
    pub const _CS_LFS_LINTFLAGS: Type = 1003;
    pub const _CS_LFS64_CFLAGS: Type = 1004;
    pub const _CS_LFS64_LDFLAGS: Type = 1005;
    pub const _CS_LFS64_LIBS: Type = 1006;
    pub const _CS_LFS64_LINTFLAGS: Type = 1007;
    pub const _CS_XBS5_ILP32_OFF32_CFLAGS: Type = 1100;
    pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: Type = 1101;
    pub const _CS_XBS5_ILP32_OFF32_LIBS: Type = 1102;
    pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: Type = 1103;
    pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: Type = 1104;
    pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: Type = 1105;
    pub const _CS_XBS5_ILP32_OFFBIG_LIBS: Type = 1106;
    pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: Type = 1107;
    pub const _CS_XBS5_LP64_OFF64_CFLAGS: Type = 1108;
    pub const _CS_XBS5_LP64_OFF64_LDFLAGS: Type = 1109;
    pub const _CS_XBS5_LP64_OFF64_LIBS: Type = 1110;
    pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: Type = 1111;
    pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: Type = 1112;
    pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: Type = 1113;
    pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: Type = 1114;
    pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: Type = 1115;
    pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: Type = 1116;
    pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: Type = 1117;
    pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: Type = 1118;
    pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: Type = 1119;
    pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: Type = 1120;
    pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: Type = 1121;
    pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: Type = 1122;
    pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: Type = 1123;
    pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: Type = 1124;
    pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: Type = 1125;
    pub const _CS_POSIX_V6_LP64_OFF64_LIBS: Type = 1126;
    pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: Type = 1127;
    pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: Type = 1128;
    pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: Type = 1129;
    pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: Type = 1130;
    pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: Type = 1131;
    pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: Type = 1132;
    pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: Type = 1133;
    pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: Type = 1134;
    pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: Type = 1135;
    pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: Type = 1136;
    pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: Type = 1137;
    pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: Type = 1138;
    pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: Type = 1139;
    pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: Type = 1140;
    pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: Type = 1141;
    pub const _CS_POSIX_V7_LP64_OFF64_LIBS: Type = 1142;
    pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: Type = 1143;
    pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: Type = 1144;
    pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: Type = 1145;
    pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: Type = 1146;
    pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: Type = 1147;
    pub const _CS_V6_ENV: Type = 1148;
    pub const _CS_V7_ENV: Type = 1149;
}
extern "C" {
    pub fn pathconf(__path: *const ::libc::c_char, __name: ::libc::c_int) -> ::libc::c_long;
}
extern "C" {
    pub fn fpathconf(__fd: ::libc::c_int, __name: ::libc::c_int) -> ::libc::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::libc::c_int) -> ::libc::c_long;
}
extern "C" {
    pub fn confstr(__name: ::libc::c_int, __buf: *mut ::libc::c_char, __len: usize) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::libc::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::libc::c_int, __list: *mut __gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn group_member(__gid: __gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn getresuid(
        __ruid: *mut __uid_t,
        __euid: *mut __uid_t,
        __suid: *mut __uid_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getresgid(
        __rgid: *mut __gid_t,
        __egid: *mut __gid_t,
        __sgid: *mut __gid_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn setresuid(__ruid: __uid_t, __euid: __uid_t, __suid: __uid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn setresgid(__rgid: __gid_t, __egid: __gid_t, __sgid: __gid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::libc::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::libc::c_int,
        __buf: *mut ::libc::c_char,
        __buflen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::libc::c_int;
}
extern "C" {
    pub fn link(__from: *const ::libc::c_char, __to: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::libc::c_int,
        __from: *const ::libc::c_char,
        __tofd: ::libc::c_int,
        __to: *const ::libc::c_char,
        __flags: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn symlink(__from: *const ::libc::c_char, __to: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::libc::c_char,
        __buf: *mut ::libc::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::libc::c_char,
        __tofd: ::libc::c_int,
        __to: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::libc::c_int,
        __path: *const ::libc::c_char,
        __buf: *mut ::libc::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::libc::c_int,
        __name: *const ::libc::c_char,
        __flag: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::libc::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::libc::c_int, __pgrp_id: __pid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::libc::c_char;
}
extern "C" {
    pub fn getlogin_r(__name: *mut ::libc::c_char, __name_len: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}optarg"]
    pub static mut optarg: *mut ::libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}optind"]
    pub static mut optind: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}opterr"]
    pub static mut opterr: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}optopt"]
    pub static mut optopt: ::libc::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::libc::c_int,
        ___argv: *const *mut ::libc::c_char,
        __shortopts: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::libc::c_char, __len: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn sethostname(__name: *const ::libc::c_char, __len: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn getdomainname(__name: *mut ::libc::c_char, __len: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn setdomainname(__name: *const ::libc::c_char, __len: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn vhangup() -> ::libc::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::libc::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::libc::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(__nochdir: ::libc::c_int, __noclose: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn syncfs(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn gethostid() -> ::libc::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::libc::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::libc::c_int;
}
extern "C" {
    pub fn truncate(__file: *const ::libc::c_char, __length: __off_t) -> ::libc::c_int;
}
extern "C" {
    pub fn truncate64(__file: *const ::libc::c_char, __length: __off64_t) -> ::libc::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::libc::c_int, __length: __off_t) -> ::libc::c_int;
}
extern "C" {
    pub fn ftruncate64(__fd: ::libc::c_int, __length: __off64_t) -> ::libc::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::libc::c_long, ...) -> ::libc::c_long;
}
extern "C" {
    pub fn copy_file_range(
        __infd: ::libc::c_int,
        __pinoff: *mut __off64_t,
        __outfd: ::libc::c_int,
        __poutoff: *mut __off64_t,
        __length: usize,
        __flags: ::libc::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn fdatasync(__fildes: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::libc::c_char,
        __salt: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn swab(__from: *const ::libc::c_void, __to: *mut ::libc::c_void, __n: isize);
}
extern "C" {
    pub fn getentropy(__buffer: *mut ::libc::c_void, __length: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn gettid() -> __pid_t;
}
extern "C" {
    pub fn rpl_pipe2(fd: *mut ::libc::c_int, flags: ::libc::c_int) -> ::libc::c_int;
}
pub mod _bindgen_ty_57 {
    pub type Type = u32;
    pub const PROCESS_OPEN_FDS: Type = 6;
}
#[repr(C)]
pub struct Lisp_Process {
    pub header: vectorlike_header,
    pub tty_name: Lisp_Object,
    pub name: Lisp_Object,
    pub command: Lisp_Object,
    pub filter: Lisp_Object,
    pub sentinel: Lisp_Object,
    pub log: Lisp_Object,
    pub buffer: Lisp_Object,
    pub childp: Lisp_Object,
    pub plist: Lisp_Object,
    pub type_: Lisp_Object,
    pub mark: Lisp_Object,
    pub status: Lisp_Object,
    pub decode_coding_system: Lisp_Object,
    pub decoding_buf: Lisp_Object,
    pub encode_coding_system: Lisp_Object,
    pub encoding_buf: Lisp_Object,
    pub write_queue: Lisp_Object,
    pub gnutls_cred_type: Lisp_Object,
    pub gnutls_boot_parameters: Lisp_Object,
    pub stderrproc: Lisp_Object,
    pub thread: Lisp_Object,
    pub pid: pid_t,
    pub infd: ::libc::c_int,
    pub nbytes_read: uintmax_t,
    pub outfd: ::libc::c_int,
    pub open_fd: [::libc::c_int; 6usize],
    pub tick: EMACS_INT,
    pub update_tick: EMACS_INT,
    pub decoding_carryover: ::libc::c_int,
    pub read_output_delay: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub raw_status: ::libc::c_int,
    pub backlog: ::libc::c_int,
    pub port: ::libc::c_int,
    pub socktype: ::libc::c_int,
    pub dns_request: *mut gaicb,
    pub gnutls_initstage: gnutls_initstage_t::Type,
    pub gnutls_state: gnutls_session_t,
    pub gnutls_x509_cred: gnutls_certificate_client_credentials,
    pub gnutls_anon_cred: gnutls_anon_client_credentials_t,
    pub gnutls_certificates: *mut gnutls_x509_crt_t,
    pub gnutls_certificates_length: ::libc::c_int,
    pub gnutls_peer_verification: ::libc::c_uint,
    pub gnutls_extra_peer_verification: ::libc::c_uint,
    pub gnutls_log_level: ::libc::c_int,
    pub gnutls_handshakes_tried: ::libc::c_int,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_Lisp_Process() {
    assert_eq!(
        ::std::mem::size_of::<Lisp_Process>(),
        344usize,
        concat!("Size of: ", stringify!(Lisp_Process))
    );
    assert_eq!(
        ::std::mem::align_of::<Lisp_Process>(),
        8usize,
        concat!("Alignment of ", stringify!(Lisp_Process))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).tty_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(tty_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).command as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).filter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).sentinel as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(sentinel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).log as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).buffer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).childp as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(childp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).plist as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(plist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).type_ as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).mark as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).status as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Process>())).decode_coding_system as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(decode_coding_system)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).decoding_buf as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(decoding_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Process>())).encode_coding_system as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(encode_coding_system)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).encoding_buf as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(encoding_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).write_queue as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).gnutls_cred_type as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(gnutls_cred_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Process>())).gnutls_boot_parameters as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(gnutls_boot_parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).stderrproc as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(stderrproc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).thread as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).pid as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).infd as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(infd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).nbytes_read as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(nbytes_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).outfd as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(outfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).open_fd as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(open_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).tick as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).update_tick as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(update_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).decoding_carryover as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(decoding_carryover)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).read_output_delay as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(read_output_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).raw_status as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(raw_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).backlog as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(backlog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).port as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).socktype as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(socktype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).dns_request as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(dns_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).gnutls_initstage as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(gnutls_initstage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).gnutls_state as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(gnutls_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).gnutls_x509_cred as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(gnutls_x509_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).gnutls_anon_cred as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(gnutls_anon_cred)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Process>())).gnutls_certificates as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(gnutls_certificates)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Process>())).gnutls_certificates_length as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(gnutls_certificates_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Process>())).gnutls_peer_verification as *const _ as usize
        },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(gnutls_peer_verification)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Process>())).gnutls_extra_peer_verification as *const _
                as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(gnutls_extra_peer_verification)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Lisp_Process>())).gnutls_log_level as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(gnutls_log_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Lisp_Process>())).gnutls_handshakes_tried as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(Lisp_Process),
            "::",
            stringify!(gnutls_handshakes_tried)
        )
    );
}
impl Default for Lisp_Process {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl Lisp_Process {
    #[inline]
    pub fn adaptive_read_buffering(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_adaptive_read_buffering(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn read_output_skip(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_output_skip(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn kill_without_query(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_kill_without_query(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pty_flag(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pty_flag(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inherit_coding_system_flag(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inherit_coding_system_flag(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn alive(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_alive(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn raw_status_new(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_raw_status_new(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_non_blocking_client(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_non_blocking_client(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_server(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_server(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        adaptive_read_buffering: ::libc::c_uint,
        read_output_skip: bool_bf,
        kill_without_query: bool_bf,
        pty_flag: bool_bf,
        inherit_coding_system_flag: bool_bf,
        alive: bool_bf,
        raw_status_new: bool_bf,
        is_non_blocking_client: bool_bf,
        is_server: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let adaptive_read_buffering: u32 =
                unsafe { ::std::mem::transmute(adaptive_read_buffering) };
            adaptive_read_buffering as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let read_output_skip: u8 = unsafe { ::std::mem::transmute(read_output_skip) };
            read_output_skip as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let kill_without_query: u8 = unsafe { ::std::mem::transmute(kill_without_query) };
            kill_without_query as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let pty_flag: u8 = unsafe { ::std::mem::transmute(pty_flag) };
            pty_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let inherit_coding_system_flag: u8 =
                unsafe { ::std::mem::transmute(inherit_coding_system_flag) };
            inherit_coding_system_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let alive: u8 = unsafe { ::std::mem::transmute(alive) };
            alive as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let raw_status_new: u8 = unsafe { ::std::mem::transmute(raw_status_new) };
            raw_status_new as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let is_non_blocking_client: u8 =
                unsafe { ::std::mem::transmute(is_non_blocking_client) };
            is_non_blocking_client as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_server: u8 = unsafe { ::std::mem::transmute(is_server) };
            is_server as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn gnutls_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gnutls_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gnutls_complete_negotiation_p(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gnutls_complete_negotiation_p(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        gnutls_p: bool_bf,
        gnutls_complete_negotiation_p: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gnutls_p: u8 = unsafe { ::std::mem::transmute(gnutls_p) };
            gnutls_p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let gnutls_complete_negotiation_p: u8 =
                unsafe { ::std::mem::transmute(gnutls_complete_negotiation_p) };
            gnutls_complete_negotiation_p as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn PROCESSP(a: Lisp_Object) -> bool;
}
extern "C" {
    pub fn CHECK_PROCESS(x: Lisp_Object);
}
extern "C" {
    pub fn XPROCESS(a: Lisp_Object) -> *mut Lisp_Process;
}
extern "C" {
    pub fn pset_childp(p: *mut Lisp_Process, val: Lisp_Object);
}
extern "C" {
    pub fn pset_status(p: *mut Lisp_Process, val: Lisp_Object);
}
extern "C" {
    pub fn pset_gnutls_cred_type(p: *mut Lisp_Process, val: Lisp_Object);
}
extern "C" {
    #[link_name = "\u{1}inhibit_sentinels"]
    pub static mut inhibit_sentinels: bool;
}
pub mod _bindgen_ty_58 {
    pub type Type = u32;
    pub const EXIT_CANCELED: Type = 125;
    pub const EXIT_CANNOT_INVOKE: Type = 126;
    pub const EXIT_ENOENT: Type = 127;
}
extern "C" {
    pub fn encode_current_directory() -> Lisp_Object;
}
extern "C" {
    pub fn record_kill_process(arg1: *mut Lisp_Process, arg2: Lisp_Object);
}
extern "C" {
    pub fn list_system_processes() -> Lisp_Object;
}
extern "C" {
    pub fn system_process_attributes(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn record_deleted_pid(arg1: pid_t, arg2: Lisp_Object);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn conv_sockaddr_to_lisp(arg1: *mut sockaddr, arg2: isize) -> Lisp_Object;
}
extern "C" {
    pub fn hold_keyboard_input();
}
extern "C" {
    pub fn unhold_keyboard_input();
}
extern "C" {
    pub fn kbd_on_hold_p() -> bool;
}
pub type fd_callback =
    ::std::option::Option<unsafe extern "C" fn(fd: ::libc::c_int, data: *mut ::libc::c_void)>;
extern "C" {
    pub fn add_read_fd(fd: ::libc::c_int, func: fd_callback, data: *mut ::libc::c_void);
}
extern "C" {
    pub fn delete_read_fd(fd: ::libc::c_int);
}
extern "C" {
    pub fn add_write_fd(fd: ::libc::c_int, func: fd_callback, data: *mut ::libc::c_void);
}
extern "C" {
    pub fn delete_write_fd(fd: ::libc::c_int);
}
extern "C" {
    pub fn catch_child_signal();
}
extern "C" {
    pub fn restore_nofile_limit();
}
extern "C" {
    pub fn remove_slash_colon(arg1: Lisp_Object) -> Lisp_Object;
}
extern "C" {
    pub fn update_processes_for_thread_death(arg1: Lisp_Object);
}
extern "C" {
    pub fn dissociate_controlling_tty();
}
extern "C" {
    pub fn open_channel_for_module(arg1: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    pub fn pure_write_error(arg1: Lisp_Object);
}
extern "C" {
    #[link_name = "\u{1}pure"]
    pub static mut pure_: [EMACS_INT; 0usize];
}
extern "C" {
    pub fn PURE_P(ptr: *mut ::libc::c_void) -> bool;
}
extern "C" {
    pub fn CHECK_IMPURE(obj: Lisp_Object, ptr: *mut ::libc::c_void);
}
extern "C" {
    pub fn new_region_cache() -> *mut region_cache;
}
extern "C" {
    pub fn free_region_cache(arg1: *mut region_cache);
}
extern "C" {
    pub fn know_region_cache(BUF: *mut buffer, CACHE: *mut region_cache, START: isize, END: isize);
}
extern "C" {
    pub fn invalidate_region_cache(
        BUF: *mut buffer,
        CACHE: *mut region_cache,
        HEAD: isize,
        TAIL: isize,
    );
}
extern "C" {
    pub fn region_cache_forward(
        buf: *mut buffer,
        c: *mut region_cache,
        pos: isize,
        next: *mut isize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn region_cache_backward(
        buf: *mut buffer,
        c: *mut region_cache,
        pos: isize,
        next: *mut isize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn rust_make_temp(template: *mut ::libc::c_char, flags: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn rust_count_trailing_zero_bits(val: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn rust_count_one_bits(val: usize) -> ::libc::c_int;
}
pub mod _bindgen_ty_59 {
    pub type Type = u32;
    pub const STATIC_HEAP_SIZE: Type = 33554432;
}
extern "C" {
    #[link_name = "\u{1}bss_sbrk_buffer"]
    pub static mut bss_sbrk_buffer: [::libc::c_char; 33554432usize];
}
extern "C" {
    #[link_name = "\u{1}max_bss_sbrk_ptr"]
    pub static mut max_bss_sbrk_ptr: *mut ::libc::c_char;
}
extern "C" {
    pub fn bss_sbrk(arg1: isize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn update_syntax_table(arg1: isize, arg2: EMACS_INT, arg3: bool, arg4: Lisp_Object);
}
extern "C" {
    pub fn update_syntax_table_forward(arg1: isize, arg2: bool, arg3: Lisp_Object);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum syntaxcode {
    Swhitespace = 0,
    Spunct = 1,
    Sword = 2,
    Ssymbol = 3,
    Sopen = 4,
    Sclose = 5,
    Squote = 6,
    Sstring = 7,
    Smath = 8,
    Sescape = 9,
    Scharquote = 10,
    Scomment = 11,
    Sendcomment = 12,
    Sinherit = 13,
    Scomment_fence = 14,
    Sstring_fence = 15,
    Smax = 16,
}
#[repr(C)]
pub struct gl_state_s {
    pub object: Lisp_Object,
    pub start: isize,
    pub stop: isize,
    pub use_global: bool,
    pub global_code: Lisp_Object,
    pub current_syntax_table: Lisp_Object,
    pub old_prop: Lisp_Object,
    pub b_property: isize,
    pub e_property: isize,
    pub e_property_truncated: bool,
    pub forward_i: INTERVAL,
    pub backward_i: INTERVAL,
    pub offset: isize,
}
#[test]
fn bindgen_test_layout_gl_state_s() {
    assert_eq!(
        ::std::mem::size_of::<gl_state_s>(),
        104usize,
        concat!("Size of: ", stringify!(gl_state_s))
    );
    assert_eq!(
        ::std::mem::align_of::<gl_state_s>(),
        8usize,
        concat!("Alignment of ", stringify!(gl_state_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).stop as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).use_global as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(use_global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).global_code as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(global_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).current_syntax_table as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(current_syntax_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).old_prop as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(old_prop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).b_property as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(b_property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).e_property as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(e_property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).e_property_truncated as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(e_property_truncated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).forward_i as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(forward_i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).backward_i as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(backward_i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gl_state_s>())).offset as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(gl_state_s),
            "::",
            stringify!(offset)
        )
    );
}
impl Default for gl_state_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}gl_state"]
    pub static mut gl_state: gl_state_s;
}
extern "C" {
    pub fn syntax_property_entry(c: ::libc::c_int, via_property: bool) -> Lisp_Object;
}
extern "C" {
    pub fn SYNTAX_ENTRY(c: ::libc::c_int) -> Lisp_Object;
}
extern "C" {
    pub fn syntax_property_with_flags(c: ::libc::c_int, via_property: bool) -> ::libc::c_int;
}
extern "C" {
    pub fn SYNTAX_WITH_FLAGS(c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn syntax_property(c: ::libc::c_int, via_property: bool) -> syntaxcode;
}
extern "C" {
    pub fn SYNTAX(c: ::libc::c_int) -> syntaxcode;
}
extern "C" {
    pub fn syntax_prefix_flag_p(c: ::libc::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}syntax_spec_code"]
    pub static mut syntax_spec_code: [::libc::c_uchar; 256usize];
}
extern "C" {
    #[link_name = "\u{1}syntax_code_spec"]
    pub static mut syntax_code_spec: [::libc::c_char; 16usize];
}
extern "C" {
    pub fn SYNTAX_TABLE_BYTE_TO_CHAR(bytepos: isize) -> isize;
}
extern "C" {
    pub fn UPDATE_SYNTAX_TABLE_FORWARD(charpos: isize);
}
extern "C" {
    pub fn UPDATE_SYNTAX_TABLE_BACKWARD(charpos: isize);
}
extern "C" {
    pub fn UPDATE_SYNTAX_TABLE(charpos: isize);
}
extern "C" {
    pub fn SETUP_BUFFER_SYNTAX_TABLE();
}
extern "C" {
    pub fn scan_words(arg1: isize, arg2: EMACS_INT) -> isize;
}
extern "C" {
    pub fn SETUP_SYNTAX_TABLE_FOR_OBJECT(arg1: Lisp_Object, arg2: isize, arg3: isize);
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::libc::c_int,
    pub sival_ptr: *mut ::libc::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
impl Default for sigval {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::libc::c_int,
    pub si_errno: ::libc::c_int,
    pub si_code: ::libc::c_int,
    pub __pad0: ::libc::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::libc::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
    _bindgen_union_align: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::libc::c_int,
    pub si_overrun: ::libc::c_int,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_tid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_overrun as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_sigval)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_sigval)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::libc::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_status as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_utime as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_utime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_stime as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::libc::c_void,
    pub si_addr_lsb: ::libc::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::libc::c_void,
    pub _upper: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
            >()))
            ._lower as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
            >()))
            ._upper as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))
                ._addr_bnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._pkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_pkey)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr_lsb
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr_lsb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()))._bounds as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_bounds)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::libc::c_long,
    pub si_fd: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_band as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_fd as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::libc::c_void,
    pub _syscall: ::libc::c_int,
    pub _arch: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._call_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._syscall as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._arch as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigchld as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigfault as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigpoll as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigsys)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).__pad0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>()))._sifields as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(_sifields)
        )
    );
}
impl Default for siginfo_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod _bindgen_ty_60 {
    pub type Type = i32;
    pub const SI_ASYNCNL: Type = -60;
    pub const SI_DETHREAD: Type = -7;
    pub const SI_TKILL: Type = -6;
    pub const SI_SIGIO: Type = -5;
    pub const SI_ASYNCIO: Type = -4;
    pub const SI_MESGQ: Type = -3;
    pub const SI_TIMER: Type = -2;
    pub const SI_QUEUE: Type = -1;
    pub const SI_USER: Type = 0;
    pub const SI_KERNEL: Type = 128;
}
pub mod _bindgen_ty_61 {
    pub type Type = u32;
    pub const ILL_ILLOPC: Type = 1;
    pub const ILL_ILLOPN: Type = 2;
    pub const ILL_ILLADR: Type = 3;
    pub const ILL_ILLTRP: Type = 4;
    pub const ILL_PRVOPC: Type = 5;
    pub const ILL_PRVREG: Type = 6;
    pub const ILL_COPROC: Type = 7;
    pub const ILL_BADSTK: Type = 8;
    pub const ILL_BADIADDR: Type = 9;
}
pub mod _bindgen_ty_62 {
    pub type Type = u32;
    pub const FPE_INTDIV: Type = 1;
    pub const FPE_INTOVF: Type = 2;
    pub const FPE_FLTDIV: Type = 3;
    pub const FPE_FLTOVF: Type = 4;
    pub const FPE_FLTUND: Type = 5;
    pub const FPE_FLTRES: Type = 6;
    pub const FPE_FLTINV: Type = 7;
    pub const FPE_FLTSUB: Type = 8;
    pub const FPE_FLTUNK: Type = 14;
    pub const FPE_CONDTRAP: Type = 15;
}
pub mod _bindgen_ty_63 {
    pub type Type = u32;
    pub const SEGV_MAPERR: Type = 1;
    pub const SEGV_ACCERR: Type = 2;
    pub const SEGV_BNDERR: Type = 3;
    pub const SEGV_PKUERR: Type = 4;
    pub const SEGV_ACCADI: Type = 5;
    pub const SEGV_ADIDERR: Type = 6;
    pub const SEGV_ADIPERR: Type = 7;
    pub const SEGV_MTEAERR: Type = 8;
    pub const SEGV_MTESERR: Type = 9;
}
pub mod _bindgen_ty_64 {
    pub type Type = u32;
    pub const BUS_ADRALN: Type = 1;
    pub const BUS_ADRERR: Type = 2;
    pub const BUS_OBJERR: Type = 3;
    pub const BUS_MCEERR_AR: Type = 4;
    pub const BUS_MCEERR_AO: Type = 5;
}
pub mod _bindgen_ty_65 {
    pub type Type = u32;
    pub const TRAP_BRKPT: Type = 1;
    pub const TRAP_TRACE: Type = 2;
    pub const TRAP_BRANCH: Type = 3;
    pub const TRAP_HWBKPT: Type = 4;
    pub const TRAP_UNK: Type = 5;
}
pub mod _bindgen_ty_66 {
    pub type Type = u32;
    pub const CLD_EXITED: Type = 1;
    pub const CLD_KILLED: Type = 2;
    pub const CLD_DUMPED: Type = 3;
    pub const CLD_TRAPPED: Type = 4;
    pub const CLD_STOPPED: Type = 5;
    pub const CLD_CONTINUED: Type = 6;
}
pub mod _bindgen_ty_67 {
    pub type Type = u32;
    pub const POLL_IN: Type = 1;
    pub const POLL_OUT: Type = 2;
    pub const POLL_MSG: Type = 3;
    pub const POLL_ERR: Type = 4;
    pub const POLL_PRI: Type = 5;
    pub const POLL_HUP: Type = 6;
}
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::libc::c_int,
    pub sigev_notify: ::libc::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::libc::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._sigev_thread as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
impl Default for sigevent__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>()))._sigev_un as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
impl Default for sigevent {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type sigevent_t = sigevent;
pub mod _bindgen_ty_68 {
    pub type Type = u32;
    pub const SIGEV_SIGNAL: Type = 0;
    pub const SIGEV_NONE: Type = 1;
    pub const SIGEV_THREAD: Type = 2;
    pub const SIGEV_THREAD_ID: Type = 4;
}
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::libc::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn sysv_signal(__sig: ::libc::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::libc::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn raise(__sig: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::libc::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::libc::c_int, __s: *const ::libc::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::libc::c_char);
}
extern "C" {
    #[link_name = "\u{1}__xpg_sigpause"]
    pub fn sigpause(__sig: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigblock(__mask: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::libc::c_int;
}
pub type sighandler_t = __sighandler_t;
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigismember(__set: *const sigset_t, __signo: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigisemptyset(__set: *const sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigandset(
        __set: *mut sigset_t,
        __left: *const sigset_t,
        __right: *const sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigorset(
        __set: *mut sigset_t,
        __left: *const sigset_t,
        __right: *const sigset_t,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::libc::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::libc::c_int, arg2: *mut siginfo_t, arg3: *mut ::libc::c_void),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_sigaction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
impl Default for sigaction__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
impl Default for sigaction {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn sigprocmask(
        __how: ::libc::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaction(
        __sig: ::libc::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwait(__set: *const sigset_t, __sig: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigqueue(__pid: __pid_t, __sig: ::libc::c_int, __val: sigval) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(
        ::std::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).magic1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).extended_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_bv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).__glibc_reserved1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::libc::c_ushort; 4usize],
    pub exponent: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::libc::c_ushort; 4usize],
    pub exponent: ::libc::c_ushort,
    pub __glibc_reserved1: [::libc::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).__glibc_reserved1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).__glibc_reserved1 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::libc::c_ushort,
    pub gs: ::libc::c_ushort,
    pub fs: ::libc::c_ushort,
    pub __pad0: ::libc::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).fpstate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).__fpstate_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(__fpstate_word)
        )
    );
}
impl Default for sigcontext__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r9 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r11 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r12 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r13 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r14 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r15 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rdi as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rsi as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rbp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rbx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rdx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rax as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rcx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rsp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).eflags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).gs as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).fs as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__pad0 as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).err as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).trapno as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).oldmask as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cr2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved1)
        )
    );
}
impl Default for sigcontext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(
        ::std::mem::size_of::<_xsave_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<_xsave_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).xstate_bv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).__glibc_reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).__glibc_reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(
        ::std::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ymmh_state>())).ymmh_space as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
impl Default for _ymmh_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(
        ::std::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).fpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).xstate_hdr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).ymmh as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
impl Default for _xstate {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_flags: ::libc::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_stack_t() {
    assert_eq!(
        ::std::mem::size_of::<stack_t>(),
        24usize,
        concat!("Size of: ", stringify!(stack_t))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_t>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_size)
        )
    );
}
impl Default for stack_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type greg_t = ::libc::c_longlong;
pub type gregset_t = [greg_t; 23usize];
pub mod _bindgen_ty_69 {
    pub type Type = u32;
    pub const REG_R8: Type = 0;
    pub const REG_R9: Type = 1;
    pub const REG_R10: Type = 2;
    pub const REG_R11: Type = 3;
    pub const REG_R12: Type = 4;
    pub const REG_R13: Type = 5;
    pub const REG_R14: Type = 6;
    pub const REG_R15: Type = 7;
    pub const REG_RDI: Type = 8;
    pub const REG_RSI: Type = 9;
    pub const REG_RBP: Type = 10;
    pub const REG_RBX: Type = 11;
    pub const REG_RDX: Type = 12;
    pub const REG_RAX: Type = 13;
    pub const REG_RCX: Type = 14;
    pub const REG_RSP: Type = 15;
    pub const REG_RIP: Type = 16;
    pub const REG_EFL: Type = 17;
    pub const REG_CSGSFS: Type = 18;
    pub const REG_ERR: Type = 19;
    pub const REG_TRAPNO: Type = 20;
    pub const REG_OLDMASK: Type = 21;
    pub const REG_CR2: Type = 22;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::libc::c_ushort; 4usize],
    pub exponent: ::libc::c_ushort,
    pub __glibc_reserved1: [::libc::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).__glibc_reserved1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).__glibc_reserved1 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::libc::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(
        ::std::mem::size_of::<mcontext_t>(),
        256usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mcontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).gregs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(gregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).fpregs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(fpregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(__reserved1)
        )
    );
}
impl Default for mcontext_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::libc::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [::libc::c_ulonglong; 4usize],
}
#[test]
fn bindgen_test_layout_ucontext_t() {
    assert_eq!(
        ::std::mem::size_of::<ucontext_t>(),
        968usize,
        concat!("Size of: ", stringify!(ucontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_stack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_mcontext as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_sigmask as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).__fpregs_mem as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__fpregs_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).__ssp as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__ssp)
        )
    );
}
impl Default for ucontext_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn siginterrupt(__sig: ::libc::c_int, __interrupt: ::libc::c_int) -> ::libc::c_int;
}
pub mod _bindgen_ty_70 {
    pub type Type = u32;
    pub const SS_ONSTACK: Type = 1;
    pub const SS_DISABLE: Type = 2;
}
extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_onstack: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
impl Default for sigstack {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::libc::c_int;
}
extern "C" {
    pub fn sighold(__sig: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigrelse(__sig: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigignore(__sig: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigset(__sig: ::libc::c_int, __disp: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: ::libc::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_kill(__threadid: pthread_t, __signo: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_sigqueue(
        __threadid: pthread_t,
        __signo: ::libc::c_int,
        __value: sigval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::libc::c_int;
}
extern "C" {
    pub fn tgkill(__tgid: __pid_t, __tid: __pid_t, __signal: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn init_signals();
}
extern "C" {
    pub fn block_child_signal(arg1: *mut sigset_t);
}
extern "C" {
    pub fn unblock_child_signal(arg1: *const sigset_t);
}
extern "C" {
    pub fn block_interrupt_signal(arg1: *mut sigset_t);
}
extern "C" {
    pub fn restore_signal_mask(arg1: *const sigset_t);
}
extern "C" {
    pub fn block_tty_out_signal(arg1: *mut sigset_t);
}
extern "C" {
    pub fn unblock_tty_out_signal(arg1: *const sigset_t);
}
extern "C" {
    #[link_name = "\u{1}empty_mask"]
    pub static mut empty_mask: sigset_t;
}
pub type signal_handler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>;
extern "C" {
    pub fn emacs_sigaction_init(arg1: *mut sigaction, arg2: signal_handler_t);
}
extern "C" {
    pub fn safe_strsignal(arg1: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn deliver_process_signal(arg1: ::libc::c_int, arg2: signal_handler_t);
}
pub type cc_t = ::libc::c_uchar;
pub type speed_t = ::libc::c_uint;
pub type tcflag_t = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_line: cc_t,
    pub c_cc: [cc_t; 32usize],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[test]
fn bindgen_test_layout_termios() {
    assert_eq!(
        ::std::mem::size_of::<termios>(),
        60usize,
        concat!("Size of: ", stringify!(termios))
    );
    assert_eq!(
        ::std::mem::align_of::<termios>(),
        4usize,
        concat!("Alignment of ", stringify!(termios))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_iflag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_iflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_oflag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_oflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_cflag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_cflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_lflag as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_lflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_cc as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_cc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_ispeed as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_ispeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_ospeed as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_ospeed)
        )
    );
}
extern "C" {
    pub fn cfgetospeed(__termios_p: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfgetispeed(__termios_p: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfsetospeed(__termios_p: *mut termios, __speed: speed_t) -> ::libc::c_int;
}
extern "C" {
    pub fn cfsetispeed(__termios_p: *mut termios, __speed: speed_t) -> ::libc::c_int;
}
extern "C" {
    pub fn cfsetspeed(__termios_p: *mut termios, __speed: speed_t) -> ::libc::c_int;
}
extern "C" {
    pub fn tcgetattr(__fd: ::libc::c_int, __termios_p: *mut termios) -> ::libc::c_int;
}
extern "C" {
    pub fn tcsetattr(
        __fd: ::libc::c_int,
        __optional_actions: ::libc::c_int,
        __termios_p: *const termios,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn cfmakeraw(__termios_p: *mut termios);
}
extern "C" {
    pub fn tcsendbreak(__fd: ::libc::c_int, __duration: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn tcdrain(__fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn tcflush(__fd: ::libc::c_int, __queue_selector: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn tcflow(__fd: ::libc::c_int, __action: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn tcgetsid(__fd: ::libc::c_int) -> __pid_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct emacs_tty {
    pub main: termios,
}
#[test]
fn bindgen_test_layout_emacs_tty() {
    assert_eq!(
        ::std::mem::size_of::<emacs_tty>(),
        60usize,
        concat!("Size of: ", stringify!(emacs_tty))
    );
    assert_eq!(
        ::std::mem::align_of::<emacs_tty>(),
        4usize,
        concat!("Alignment of ", stringify!(emacs_tty))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<emacs_tty>())).main as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(emacs_tty),
            "::",
            stringify!(main)
        )
    );
}
extern "C" {
    pub fn emacs_get_tty(arg1: ::libc::c_int, arg2: *mut emacs_tty) -> ::libc::c_int;
}
extern "C" {
    pub fn emacs_set_tty(arg1: ::libc::c_int, arg2: *mut emacs_tty, arg3: bool) -> ::libc::c_int;
}
extern "C" {
    pub fn suppress_echo_on_tty(arg1: ::libc::c_int);
}
extern "C" {
    pub fn serial_open(arg1: Lisp_Object) -> ::libc::c_int;
}
extern "C" {
    pub fn serial_configure(arg1: *mut Lisp_Process, arg2: Lisp_Object);
}
pub mod idtype_t {
    pub type Type = u32;
    pub const P_ALL: Type = 0;
    pub const P_PID: Type = 1;
    pub const P_PGID: Type = 2;
}
extern "C" {
    pub fn wait(__stat_loc: *mut ::libc::c_int) -> __pid_t;
}
extern "C" {
    pub fn waitpid(
        __pid: __pid_t,
        __stat_loc: *mut ::libc::c_int,
        __options: ::libc::c_int,
    ) -> __pid_t;
}
extern "C" {
    pub fn waitid(
        __idtype: idtype_t::Type,
        __id: __id_t,
        __infop: *mut siginfo_t,
        __options: ::libc::c_int,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wait3(
        __stat_loc: *mut ::libc::c_int,
        __options: ::libc::c_int,
        __usage: *mut rusage,
    ) -> __pid_t;
}
extern "C" {
    pub fn wait4(
        __pid: __pid_t,
        __stat_loc: *mut ::libc::c_int,
        __options: ::libc::c_int,
        __usage: *mut rusage,
    ) -> __pid_t;
}
extern "C" {
    pub fn wait_for_termination(arg1: pid_t, arg2: *mut ::libc::c_int, arg3: bool) -> bool;
}
extern "C" {
    pub fn child_status_changed(
        arg1: pid_t,
        arg2: *mut ::libc::c_int,
        arg3: ::libc::c_int,
    ) -> pid_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_output {
    pub display_info: *mut tty_display_info,
}
#[test]
fn bindgen_test_layout_tty_output() {
    assert_eq!(
        ::std::mem::size_of::<tty_output>(),
        8usize,
        concat!("Size of: ", stringify!(tty_output))
    );
    assert_eq!(
        ::std::mem::align_of::<tty_output>(),
        8usize,
        concat!("Alignment of ", stringify!(tty_output))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_output>())).display_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_output),
            "::",
            stringify!(display_info)
        )
    );
}
impl Default for tty_output {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod _bindgen_ty_71 {
    pub type Type = u32;
    pub const TERMCAP_BUFFER_SIZE: Type = 4096;
}
#[repr(C)]
pub struct tty_display_info {
    pub next: *mut tty_display_info,
    pub name: *mut ::libc::c_char,
    pub type_: *mut ::libc::c_char,
    pub input: *mut FILE,
    pub output: *mut FILE,
    pub termscript: *mut FILE,
    pub old_tty: *mut emacs_tty,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub reference_count: ::libc::c_int,
    pub terminal: *mut terminal,
    pub Wcm: *mut cm,
    pub top_frame: Lisp_Object,
    pub previous_frame: *mut frame,
    pub previous_color_mode: ::libc::c_int,
    pub mouse_highlight: Mouse_HLInfo,
    pub termcap_term_buffer: [::libc::c_char; 4096usize],
    pub termcap_strings_buffer: [::libc::c_char; 4096usize],
    pub TS_ins_line: *const ::libc::c_char,
    pub TS_ins_multi_lines: *const ::libc::c_char,
    pub TS_bell: *const ::libc::c_char,
    pub TS_clr_to_bottom: *const ::libc::c_char,
    pub TS_clr_line: *const ::libc::c_char,
    pub TS_clr_frame: *const ::libc::c_char,
    pub TS_set_scroll_region: *const ::libc::c_char,
    pub TS_set_scroll_region_1: *const ::libc::c_char,
    pub TS_del_char: *const ::libc::c_char,
    pub TS_del_multi_chars: *const ::libc::c_char,
    pub TS_del_line: *const ::libc::c_char,
    pub TS_del_multi_lines: *const ::libc::c_char,
    pub TS_delete_mode: *const ::libc::c_char,
    pub TS_end_delete_mode: *const ::libc::c_char,
    pub TS_end_insert_mode: *const ::libc::c_char,
    pub TS_ins_char: *const ::libc::c_char,
    pub TS_ins_multi_chars: *const ::libc::c_char,
    pub TS_insert_mode: *const ::libc::c_char,
    pub TS_pad_inserted_char: *const ::libc::c_char,
    pub TS_end_keypad_mode: *const ::libc::c_char,
    pub TS_keypad_mode: *const ::libc::c_char,
    pub TS_pad_char: *const ::libc::c_char,
    pub TS_repeat: *const ::libc::c_char,
    pub TS_end_standout_mode: *const ::libc::c_char,
    pub TS_fwd_scroll: *const ::libc::c_char,
    pub TS_standout_mode: *const ::libc::c_char,
    pub TS_rev_scroll: *const ::libc::c_char,
    pub TS_end_termcap_modes: *const ::libc::c_char,
    pub TS_termcap_modes: *const ::libc::c_char,
    pub TS_visible_bell: *const ::libc::c_char,
    pub TS_cursor_normal: *const ::libc::c_char,
    pub TS_cursor_visible: *const ::libc::c_char,
    pub TS_cursor_invisible: *const ::libc::c_char,
    pub TS_set_window: *const ::libc::c_char,
    pub TS_enter_bold_mode: *const ::libc::c_char,
    pub TS_enter_italic_mode: *const ::libc::c_char,
    pub TS_enter_dim_mode: *const ::libc::c_char,
    pub TS_enter_reverse_mode: *const ::libc::c_char,
    pub TS_exit_underline_mode: *const ::libc::c_char,
    pub TS_enter_underline_mode: *const ::libc::c_char,
    pub TS_enter_strike_through_mode: *const ::libc::c_char,
    pub TS_enter_alt_charset_mode: *const ::libc::c_char,
    pub TS_exit_alt_charset_mode: *const ::libc::c_char,
    pub TS_exit_attribute_mode: *const ::libc::c_char,
    pub TN_no_color_video: ::libc::c_int,
    pub TN_max_colors: ::libc::c_int,
    pub TS_orig_pair: *const ::libc::c_char,
    pub TS_set_foreground: *const ::libc::c_char,
    pub TS_set_background: *const ::libc::c_char,
    pub TF_hazeltine: ::libc::c_int,
    pub TF_insmode_motion: ::libc::c_int,
    pub TF_standout_motion: ::libc::c_int,
    pub TF_underscore: ::libc::c_int,
    pub TF_teleray: ::libc::c_int,
    pub RPov: ::libc::c_int,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub meta_key: ::libc::c_int,
    pub specified_window: ::libc::c_int,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub scroll_region_cost: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_tty_display_info() {
    assert_eq!(
        ::std::mem::size_of::<tty_display_info>(),
        8800usize,
        concat!("Size of: ", stringify!(tty_display_info))
    );
    assert_eq!(
        ::std::mem::align_of::<tty_display_info>(),
        8usize,
        concat!("Alignment of ", stringify!(tty_display_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).input as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).output as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).termscript as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(termscript)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).old_tty as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(old_tty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).reference_count as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(reference_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).terminal as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(terminal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).Wcm as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(Wcm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).top_frame as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(top_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).previous_frame as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(previous_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).previous_color_mode as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(previous_color_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).mouse_highlight as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(mouse_highlight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).termcap_term_buffer as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(termcap_term_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).termcap_strings_buffer as *const _ as usize
        },
        4272usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(termcap_strings_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_ins_line as *const _ as usize },
        8368usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_ins_line)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_ins_multi_lines as *const _ as usize
        },
        8376usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_ins_multi_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_bell as *const _ as usize },
        8384usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_bell)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_clr_to_bottom as *const _ as usize
        },
        8392usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_clr_to_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_clr_line as *const _ as usize },
        8400usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_clr_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_clr_frame as *const _ as usize },
        8408usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_clr_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_set_scroll_region as *const _ as usize
        },
        8416usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_set_scroll_region)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_set_scroll_region_1 as *const _ as usize
        },
        8424usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_set_scroll_region_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_del_char as *const _ as usize },
        8432usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_del_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_del_multi_chars as *const _ as usize
        },
        8440usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_del_multi_chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_del_line as *const _ as usize },
        8448usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_del_line)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_del_multi_lines as *const _ as usize
        },
        8456usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_del_multi_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_delete_mode as *const _ as usize },
        8464usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_delete_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_end_delete_mode as *const _ as usize
        },
        8472usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_end_delete_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_end_insert_mode as *const _ as usize
        },
        8480usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_end_insert_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_ins_char as *const _ as usize },
        8488usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_ins_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_ins_multi_chars as *const _ as usize
        },
        8496usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_ins_multi_chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_insert_mode as *const _ as usize },
        8504usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_insert_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_pad_inserted_char as *const _ as usize
        },
        8512usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_pad_inserted_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_end_keypad_mode as *const _ as usize
        },
        8520usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_end_keypad_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_keypad_mode as *const _ as usize },
        8528usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_keypad_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_pad_char as *const _ as usize },
        8536usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_pad_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_repeat as *const _ as usize },
        8544usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_repeat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_end_standout_mode as *const _ as usize
        },
        8552usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_end_standout_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_fwd_scroll as *const _ as usize },
        8560usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_fwd_scroll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_standout_mode as *const _ as usize
        },
        8568usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_standout_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_rev_scroll as *const _ as usize },
        8576usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_rev_scroll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_end_termcap_modes as *const _ as usize
        },
        8584usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_end_termcap_modes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_termcap_modes as *const _ as usize
        },
        8592usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_termcap_modes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_visible_bell as *const _ as usize
        },
        8600usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_visible_bell)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_cursor_normal as *const _ as usize
        },
        8608usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_cursor_normal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_cursor_visible as *const _ as usize
        },
        8616usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_cursor_visible)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_cursor_invisible as *const _ as usize
        },
        8624usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_cursor_invisible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_set_window as *const _ as usize },
        8632usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_set_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_enter_bold_mode as *const _ as usize
        },
        8640usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_enter_bold_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_enter_italic_mode as *const _ as usize
        },
        8648usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_enter_italic_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_enter_dim_mode as *const _ as usize
        },
        8656usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_enter_dim_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_enter_reverse_mode as *const _ as usize
        },
        8664usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_enter_reverse_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_exit_underline_mode as *const _ as usize
        },
        8672usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_exit_underline_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_enter_underline_mode as *const _
                as usize
        },
        8680usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_enter_underline_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_enter_strike_through_mode as *const _
                as usize
        },
        8688usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_enter_strike_through_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_enter_alt_charset_mode as *const _
                as usize
        },
        8696usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_enter_alt_charset_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_exit_alt_charset_mode as *const _
                as usize
        },
        8704usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_exit_alt_charset_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_exit_attribute_mode as *const _ as usize
        },
        8712usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_exit_attribute_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TN_no_color_video as *const _ as usize
        },
        8720usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TN_no_color_video)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TN_max_colors as *const _ as usize },
        8724usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TN_max_colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TS_orig_pair as *const _ as usize },
        8728usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_orig_pair)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_set_foreground as *const _ as usize
        },
        8736usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_set_foreground)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TS_set_background as *const _ as usize
        },
        8744usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TS_set_background)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TF_hazeltine as *const _ as usize },
        8752usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TF_hazeltine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TF_insmode_motion as *const _ as usize
        },
        8756usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TF_insmode_motion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).TF_standout_motion as *const _ as usize
        },
        8760usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TF_standout_motion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TF_underscore as *const _ as usize },
        8764usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TF_underscore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).TF_teleray as *const _ as usize },
        8768usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(TF_teleray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).RPov as *const _ as usize },
        8772usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(RPov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tty_display_info>())).meta_key as *const _ as usize },
        8780usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(meta_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).specified_window as *const _ as usize
        },
        8784usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(specified_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tty_display_info>())).scroll_region_cost as *const _ as usize
        },
        8792usize,
        concat!(
            "Offset of field: ",
            stringify!(tty_display_info),
            "::",
            stringify!(scroll_region_cost)
        )
    );
}
impl Default for tty_display_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl tty_display_info {
    #[inline]
    pub fn term_initted(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_term_initted(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(term_initted: bool_bf) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let term_initted: u8 = unsafe { ::std::mem::transmute(term_initted) };
            term_initted as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn delete_in_insert_mode(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_delete_in_insert_mode(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn costs_set(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_costs_set(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn insert_mode(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_insert_mode(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn standout_mode(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_standout_mode(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        delete_in_insert_mode: bool_bf,
        costs_set: bool_bf,
        insert_mode: bool_bf,
        standout_mode: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let delete_in_insert_mode: u8 = unsafe { ::std::mem::transmute(delete_in_insert_mode) };
            delete_in_insert_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let costs_set: u8 = unsafe { ::std::mem::transmute(costs_set) };
            costs_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let insert_mode: u8 = unsafe { ::std::mem::transmute(insert_mode) };
            insert_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let standout_mode: u8 = unsafe { ::std::mem::transmute(standout_mode) };
            standout_mode as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn cursor_hidden(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cursor_hidden(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flow_control(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flow_control(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn showing_menu(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_showing_menu(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn must_write_spaces(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_must_write_spaces(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn line_ins_del_ok(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_line_ins_del_ok(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn char_ins_del_ok(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_char_ins_del_ok(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scroll_region_ok(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scroll_region_ok(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memory_below_frame(&self) -> bool_bf {
        unsafe { ::std::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_memory_below_frame(&mut self, val: bool_bf) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        cursor_hidden: bool_bf,
        flow_control: bool_bf,
        showing_menu: bool_bf,
        must_write_spaces: bool_bf,
        line_ins_del_ok: bool_bf,
        char_ins_del_ok: bool_bf,
        scroll_region_ok: bool_bf,
        memory_below_frame: bool_bf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cursor_hidden: u8 = unsafe { ::std::mem::transmute(cursor_hidden) };
            cursor_hidden as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flow_control: u8 = unsafe { ::std::mem::transmute(flow_control) };
            flow_control as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let showing_menu: u8 = unsafe { ::std::mem::transmute(showing_menu) };
            showing_menu as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let must_write_spaces: u8 = unsafe { ::std::mem::transmute(must_write_spaces) };
            must_write_spaces as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let line_ins_del_ok: u8 = unsafe { ::std::mem::transmute(line_ins_del_ok) };
            line_ins_del_ok as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let char_ins_del_ok: u8 = unsafe { ::std::mem::transmute(char_ins_del_ok) };
            char_ins_del_ok as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scroll_region_ok: u8 = unsafe { ::std::mem::transmute(scroll_region_ok) };
            scroll_region_ok as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let memory_below_frame: u8 = unsafe { ::std::mem::transmute(memory_below_frame) };
            memory_below_frame as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}tty_list"]
    pub static mut tty_list: *mut tty_display_info;
}
extern "C" {
    pub fn tty_handle_tab_bar_click(
        arg1: *mut frame,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: bool,
        arg5: *mut input_event,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}interrupt_input"]
    pub static mut interrupt_input: bool;
}
extern "C" {
    #[link_name = "\u{1}interrupts_deferred"]
    pub static mut interrupts_deferred: bool;
}
extern "C" {
    pub fn xg_select(
        max_fds: ::libc::c_int,
        rfds: *mut fd_set,
        wfds: *mut fd_set,
        efds: *mut fd_set,
        timeout: *mut timespec,
        sigmask: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn release_select_lock();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wr_bitmap_record {
    pub file: *mut ::libc::c_char,
    pub refcount: ::libc::c_int,
    pub height: ::libc::c_int,
    pub width: ::libc::c_int,
    pub depth: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_wr_bitmap_record() {
    assert_eq!(
        ::std::mem::size_of::<wr_bitmap_record>(),
        24usize,
        concat!("Size of: ", stringify!(wr_bitmap_record))
    );
    assert_eq!(
        ::std::mem::align_of::<wr_bitmap_record>(),
        8usize,
        concat!("Alignment of ", stringify!(wr_bitmap_record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_bitmap_record>())).file as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_bitmap_record),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_bitmap_record>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_bitmap_record),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_bitmap_record>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_bitmap_record),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_bitmap_record>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_bitmap_record),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_bitmap_record>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_bitmap_record),
            "::",
            stringify!(depth)
        )
    );
}
impl Default for wr_bitmap_record {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type Screen = ::libc::c_int;
#[repr(C)]
pub struct wr_display_info {
    pub next: *mut wr_display_info,
    pub terminal: *mut terminal,
    pub name_list_element: Lisp_Object,
    pub resx: f64,
    pub resy: f64,
    pub n_planes: ::libc::c_int,
    pub grabbed: ::libc::c_int,
    pub root_window: Window,
    pub vertical_scroll_bar_cursor: Emacs_Cursor,
    pub rdb: XrmDatabase,
    pub smallest_char_width: ::libc::c_int,
    pub smallest_font_height: ::libc::c_int,
    pub mouse_highlight: Mouse_HLInfo,
    pub n_fonts: ::libc::c_int,
    pub bitmaps: *mut wr_bitmap_record,
    pub bitmaps_size: isize,
    pub bitmaps_last: isize,
    pub highlight_frame: *mut frame,
    pub last_mouse_frame: *mut frame,
    pub last_mouse_motion_frame: *mut frame,
    pub last_mouse_motion_x: ::libc::c_int,
    pub last_mouse_motion_y: ::libc::c_int,
    pub inner: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_wr_display_info() {
    assert_eq!(
        ::std::mem::size_of::<wr_display_info>(),
        224usize,
        concat!("Size of: ", stringify!(wr_display_info))
    );
    assert_eq!(
        ::std::mem::align_of::<wr_display_info>(),
        8usize,
        concat!("Alignment of ", stringify!(wr_display_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).terminal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(terminal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_display_info>())).name_list_element as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(name_list_element)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).resx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(resx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).resy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(resy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).n_planes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(n_planes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).grabbed as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(grabbed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).root_window as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(root_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_display_info>())).vertical_scroll_bar_cursor as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(vertical_scroll_bar_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).rdb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(rdb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_display_info>())).smallest_char_width as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(smallest_char_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_display_info>())).smallest_font_height as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(smallest_font_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).mouse_highlight as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(mouse_highlight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).n_fonts as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(n_fonts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).bitmaps as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(bitmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).bitmaps_size as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(bitmaps_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).bitmaps_last as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(bitmaps_last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).highlight_frame as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(highlight_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_display_info>())).last_mouse_frame as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(last_mouse_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_display_info>())).last_mouse_motion_frame as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(last_mouse_motion_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_display_info>())).last_mouse_motion_x as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(last_mouse_motion_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_display_info>())).last_mouse_motion_y as *const _ as usize
        },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(last_mouse_motion_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_display_info>())).inner as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_display_info),
            "::",
            stringify!(inner)
        )
    );
}
impl Default for wr_display_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}wr_display_list"]
    pub static mut wr_display_list: *mut wr_display_info;
}
#[repr(C)]
#[derive(Debug)]
pub struct wr_output {
    pub parent_desc: Window,
    pub text_cursor: Emacs_Cursor,
    pub nontext_cursor: Emacs_Cursor,
    pub modeline_cursor: Emacs_Cursor,
    pub hand_cursor: Emacs_Cursor,
    pub hourglass_cursor: Emacs_Cursor,
    pub horizontal_drag_cursor: Emacs_Cursor,
    pub vertical_drag_cursor: Emacs_Cursor,
    pub left_edge_cursor: Emacs_Cursor,
    pub top_left_corner_cursor: Emacs_Cursor,
    pub top_edge_cursor: Emacs_Cursor,
    pub top_right_corner_cursor: Emacs_Cursor,
    pub right_edge_cursor: Emacs_Cursor,
    pub bottom_right_corner_cursor: Emacs_Cursor,
    pub bottom_edge_cursor: Emacs_Cursor,
    pub bottom_left_corner_cursor: Emacs_Cursor,
    pub display_info: *mut wr_display_info,
}
#[test]
fn bindgen_test_layout_wr_output() {
    assert_eq!(
        ::std::mem::size_of::<wr_output>(),
        136usize,
        concat!("Size of: ", stringify!(wr_output))
    );
    assert_eq!(
        ::std::mem::align_of::<wr_output>(),
        8usize,
        concat!("Alignment of ", stringify!(wr_output))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_output>())).parent_desc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(parent_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_output>())).text_cursor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(text_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_output>())).nontext_cursor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(nontext_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_output>())).modeline_cursor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(modeline_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_output>())).hand_cursor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(hand_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_output>())).hourglass_cursor as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(hourglass_cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_output>())).horizontal_drag_cursor as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(horizontal_drag_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_output>())).vertical_drag_cursor as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(vertical_drag_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_output>())).left_edge_cursor as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(left_edge_cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_output>())).top_left_corner_cursor as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(top_left_corner_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_output>())).top_edge_cursor as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(top_edge_cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_output>())).top_right_corner_cursor as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(top_right_corner_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_output>())).right_edge_cursor as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(right_edge_cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_output>())).bottom_right_corner_cursor as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(bottom_right_corner_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_output>())).bottom_edge_cursor as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(bottom_edge_cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wr_output>())).bottom_left_corner_cursor as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(bottom_left_corner_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wr_output>())).display_info as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wr_output),
            "::",
            stringify!(display_info)
        )
    );
}
impl Default for wr_output {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn wr_get_window_desc(output: *mut wr_output) -> Window;
}
extern "C" {
    pub fn wr_get_fontset(output: *mut wr_output) -> ::libc::c_int;
}
extern "C" {
    pub fn wr_get_font(output: *mut wr_output) -> *mut font;
}
extern "C" {
    pub fn wr_get_display_info(output: *mut wr_output) -> *mut wr_display_info;
}
extern "C" {
    pub fn wr_get_display(output: *mut wr_display_info) -> *mut Display;
}
extern "C" {
    pub fn wr_get_screen(output: *mut wr_display_info) -> Screen;
}
extern "C" {
    pub fn wr_get_baseline_offset(output: *mut wr_output) -> ::libc::c_int;
}
extern "C" {
    pub fn wr_get_pixel(ximg: *mut WRImage, x: ::libc::c_int, y: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn wr_put_pixel(
        ximg: *mut WRImage,
        x: ::libc::c_int,
        y: ::libc::c_int,
        pixel: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::libc::c_uint,
    pub fp_offset: ::libc::c_uint,
    pub overflow_arg_area: *mut ::libc::c_void,
    pub reg_save_area: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct catchtag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct region_cache {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xwidget {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct image_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct emacs_runtime_private {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct emacs_env_private {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct x_display_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct w32_display_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ns_display_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct x_output {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct w32_output {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ns_output {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gaicb {
    pub _address: u8,
}
